Opal.modules.thread=function(Opal){var $nesting=[],$$=Opal.$r($nesting),nil=Opal.nil,$$$=Opal.$$$,$klass=Opal.klass,$truthy=Opal.truthy,$defs=Opal.defs,$def=Opal.def,$send=Opal.send,$hash2=Opal.hash2,$Opal=Opal.Opal,$alias=Opal.alias,$return_ivar=Opal.return_ivar,$const_set=Opal.const_set,$assign_ivar_val=Opal.assign_ivar_val;return Opal.add_stubs("allocate,core_initialize!,current,raise,[],coerce_key_name,[]=,key?,keys,private,coerce_to!,clear,empty?,size,shift,push,each,to_proc,pop,=~,last_match,to_i,inspect,attr_reader,path,locked?,lock,unlock"),$klass($nesting[0],$$("StandardError"),"ThreadError"),function($base,$super,$parent_nesting){var self=$klass($base,null,"Thread"),$nesting=[self].concat($parent_nesting),$$=Opal.$r($nesting),$proto=self.$$prototype;$proto.fiber_locals=$proto.thread_locals=nil,$defs(self,"$current",(function(){return null==this.current&&(this.current=nil),$truthy(this.current)||(this.current=this.$allocate(),this.current["$core_initialize!"]()),this.current}),0),$defs(self,"$list",(function(){return[this.$current()]}),0),$def(self,"$initialize",(function($a){var self=this;return Opal.slice.call(arguments),self.$raise($$("NotImplementedError"),"Thread creation not available")}),-1),$def(self,"$[]",(function(key){return this.fiber_locals["$[]"](this.$coerce_key_name(key))}),1),$def(self,"$[]=",(function(key,value){var $a;return $a=[this.$coerce_key_name(key),value],$send(this.fiber_locals,"[]=",$a),$a[$a.length-1]}),2),$def(self,"$key?",(function(key){return this.fiber_locals["$key?"](this.$coerce_key_name(key))}),1),$def(self,"$keys",(function(){return this.fiber_locals.$keys()}),0),$def(self,"$thread_variable_get",(function(key){return this.thread_locals["$[]"](this.$coerce_key_name(key))}),1),$def(self,"$thread_variable_set",(function(key,value){var $a;return $a=[this.$coerce_key_name(key),value],$send(this.thread_locals,"[]=",$a),$a[$a.length-1]}),2),$def(self,"$thread_variable?",(function(key){return this.thread_locals["$key?"](this.$coerce_key_name(key))}),1),$def(self,"$thread_variables",(function(){return this.thread_locals.$keys()}),0),self.$private(),$def(self,"$core_initialize!",(function(){return this.thread_locals=$hash2([],{}),this.fiber_locals=$hash2([],{})}),0),$def(self,"$coerce_key_name",(function(key){return $Opal["$coerce_to!"](key,$$("String"),"to_s")}),1),function($base,$super,$parent_nesting){var self=$klass($base,null,"Queue"),$nesting=[self].concat($parent_nesting),$$=Opal.$r($nesting);self.$$prototype.storage=nil,$def(self,"$initialize",(function(){return this.$clear()}),0),$def(self,"$clear",(function(){return this.storage=[]}),0),$def(self,"$empty?",(function(){return this.storage["$empty?"]()}),0),$def(self,"$size",(function(){return this.storage.$size()}),0),$def(self,"$pop",(function(non_block){return null==non_block&&(non_block=!1),$truthy(this["$empty?"]())&&($truthy(non_block)&&this.$raise($$("ThreadError"),"Queue empty"),this.$raise($$("ThreadError"),"Deadlock")),this.storage.$shift()}),-1),$def(self,"$push",(function(value){return this.storage.$push(value)}),1),$def(self,"$each",(function $$each(){var block=$$each.$$p||nil;return delete $$each.$$p,$send(this.storage,"each",[],block.$to_proc())}),0),$alias(self,"<<","push"),$alias(self,"deq","pop"),$alias(self,"enq","push"),$alias(self,"length","size"),$alias(self,"shift","pop")}($nesting[0],0,$nesting),function($base,$super,$parent_nesting){var $nesting=[$klass($base,null,"Backtrace")].concat($parent_nesting);(function($base,$super,$parent_nesting){var self=$klass($base,null,"Location"),$nesting=[self].concat($parent_nesting),$$=Opal.$r($nesting),$proto=self.$$prototype;$proto.label=$proto.str=nil,$def(self,"$initialize",(function(str){var $ret_or_1;return this.str=str,str["$=~"](/^(.*?):(\d+):(\d+):in `(.*?)'$/),this.path=$$("Regexp").$last_match(1),this.label=$$("Regexp").$last_match(4),this.lineno=$$("Regexp").$last_match(2).$to_i(),this.label["$=~"](/(\w+)$/),this.base_label=$truthy($ret_or_1=$$("Regexp").$last_match(1))?$ret_or_1:this.label}),1),$def(self,"$to_s",$return_ivar("str"),0),$def(self,"$inspect",(function(){return this.str.$inspect()}),0),self.$attr_reader("base_label","label","lineno","path"),$alias(self,"absolute_path","path")})($nesting[0],0,$nesting)}($nesting[0],0,$nesting)}($nesting[0],0,$nesting),$const_set($nesting[0],"Queue",$$$($$("Thread"),"Queue")),function($base,$super,$parent_nesting){var self=$klass($base,null,"Mutex"),$nesting=[self].concat($parent_nesting),$$=Opal.$r($nesting);return self.$$prototype.locked=nil,$def(self,"$initialize",$assign_ivar_val("locked",!1),0),$def(self,"$lock",(function(){return $truthy(this.locked)&&this.$raise($$("ThreadError"),"Deadlock"),this.locked=!0,this}),0),$def(self,"$locked?",$return_ivar("locked"),0),$def(self,"$owned?",$return_ivar("locked"),0),$def(self,"$try_lock",(function(){return!$truthy(this["$locked?"]())&&(this.$lock(),!0)}),0),$def(self,"$unlock",(function(){return $truthy(this.locked)||this.$raise($$("ThreadError"),"Mutex not locked"),this.locked=!1,this}),0),$def(self,"$synchronize",(function $$synchronize(){var $yield=$$synchronize.$$p||nil,self=this;return delete $$synchronize.$$p,self.$lock(),function(){try{return Opal.yieldX($yield,[])}finally{self.$unlock()}}()}),0)}($nesting[0],0,$nesting)};
