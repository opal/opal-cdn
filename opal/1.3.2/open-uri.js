Opal.modules["stringio"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$call', '$close', '$attr_accessor', '$check_readable', '$==', '$length', '$===', '$>=', '$raise', '$>', '$+', '$-', '$seek', '$check_writable', '$String', '$[]', '$eof?', '$write', '$read']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $StringIO_open$1, $StringIO_initialize$2, $StringIO_eof$ques$3, $StringIO_seek$4, $StringIO_tell$5, $StringIO_rewind$6, $StringIO_write$7, $StringIO_read$8, $StringIO_sysread$9;

    self.$$prototype.position = self.$$prototype.string = nil;
    
    Opal.defs(self, '$open', $StringIO_open$1 = function $$open(string, mode) {
      var $iter = $StringIO_open$1.$$p, block = $iter || nil, self = this, io = nil, res = nil;

      if ($iter) $StringIO_open$1.$$p = null;
      
      
      if ($iter) $StringIO_open$1.$$p = null;;
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = nil;
      };
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, $StringIO_open$1.$$arity = -1);
    self.$attr_accessor("string");
    
    Opal.def(self, '$initialize', $StringIO_initialize$2 = function $$initialize(string, mode) {
      var $iter = $StringIO_initialize$2.$$p, $yield = $iter || nil, self = this;

      if ($iter) $StringIO_initialize$2.$$p = null;
      
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = "rw";
      };
      self.string = string;
      self.position = 0;
      return $send2(self, $find_super(self, 'initialize', $StringIO_initialize$2, false, true), 'initialize', [nil, mode], null);
    }, $StringIO_initialize$2.$$arity = -1);
    
    Opal.def(self, '$eof?', $StringIO_eof$ques$3 = function() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, $StringIO_eof$ques$3.$$arity = 0);
    $alias(self, "eof", "eof?");
    
    Opal.def(self, '$seek', $StringIO_seek$4 = function $$seek(pos, whence) {
      var self = this, $case = nil;

      
      
      if (whence == null) {
        whence = $$$($$($nesting, 'IO'), 'SEEK_SET');
      };
      self.read_buffer = "";
      $case = whence;
      if ($$$($$($nesting, 'IO'), 'SEEK_SET')['$===']($case)) {
      if ($truthy($rb_ge(pos, 0))) {
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'))
      };
      self.position = pos;}
      else if ($$$($$($nesting, 'IO'), 'SEEK_CUR')['$===']($case)) {if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
        self.position = self.string.$length()
      } else {
        self.position = $rb_plus(self.position, pos)
      }}
      else if ($$$($$($nesting, 'IO'), 'SEEK_END')['$===']($case)) {if ($truthy($rb_gt(pos, self.string.$length()))) {
        self.position = 0
      } else {
        self.position = $rb_minus(self.position, pos)
      }};
      return 0;
    }, $StringIO_seek$4.$$arity = -2);
    
    Opal.def(self, '$tell', $StringIO_tell$5 = function $$tell() {
      var self = this;

      return self.position
    }, $StringIO_tell$5.$$arity = 0);
    $alias(self, "pos", "tell");
    $alias(self, "pos=", "seek");
    
    Opal.def(self, '$rewind', $StringIO_rewind$6 = function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, $StringIO_rewind$6.$$arity = 0);
    
    Opal.def(self, '$write', $StringIO_write$7 = function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      self.read_buffer = "";
      string = self.$String(string);
      if (self.string.$length()['$=='](self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, $StringIO_write$7.$$arity = 1);
    
    Opal.def(self, '$read', $StringIO_read$8 = function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      
      if (length == null) {
        length = nil;
      };
      
      if (outbuf == null) {
        outbuf = nil;
      };
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil};
      string = (function() {if ($truthy(length)) {
        
        str = self.string['$[]'](self.position, length);
        self.position = $rb_plus(self.position, length);
        if ($truthy($rb_gt(self.position, self.string.$length()))) {
          self.position = self.string.$length()};
        return str;
      } else {
        
        str = self.string['$[]'](Opal.Range.$new(self.position, -1, false));
        self.position = self.string.$length();
        return str;
      }; return nil; })();
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, $StringIO_read$8.$$arity = -1);
    
    Opal.def(self, '$sysread', $StringIO_sysread$9 = function $$sysread(length) {
      var self = this;

      
      self.$check_readable();
      return self.$read(length);
    }, $StringIO_sysread$9.$$arity = 1);
    return $alias(self, "readpartial", "read");
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

Opal.modules["corelib/pack_unpack/format_string_parser"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$raise']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'PackUnpack');

    var $nesting = [self].concat($parent_nesting);

    
    var directives = [
      // Integer
      'C',
      'S',
      'L',
      'Q',
      'J',

      'c',
      's',
      'l',
      'q',
      'j',

      'n',
      'N',
      'v',
      'V',

      'U',
      'w',

      // Float
      'D',
      'd',
      'F',
      'f',
      'E',
      'e',
      'G',
      'g',

      // String
      'A',
      'a',
      'Z',
      'B',
      'b',
      'H',
      'h',
      'u',
      'M',
      'm',

      'P',
      'p',

      // Misc
      '@',
      'X',
      'x'
    ];

    var modifiers = [
      '!', // ignored
      '_', // ignored
      '>', // big endian
      '<'  // little endian
    ];

    self.eachDirectiveAndCount = function(format, callback) {
      var currentDirective,
          currentCount,
          currentModifiers,
          countSpecified;

      function reset() {
        currentDirective = null;
        currentCount = 0;
        currentModifiers = [];
        countSpecified = false;
      }

      reset();

      function yieldAndReset() {
        if (currentDirective == null) {
          reset();
          return;
        }

        var directiveSupportsModifiers = /[sSiIlLqQjJ]/.test(currentDirective);

        if (!directiveSupportsModifiers && currentModifiers.length > 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "'" + (currentModifiers[0]) + "' allowed only after types sSiIlLqQjJ")
        }

        if (currentModifiers.indexOf('<') !== -1 && currentModifiers.indexOf('>') !== -1) {
          self.$raise($$($nesting, 'RangeError'), "Can't use both '<' and '>'")
        }

        if (!countSpecified) {
          currentCount = 1;
        }

        if (currentModifiers.indexOf('>') !== -1) {
          currentDirective = currentDirective + '>';
        }

        callback(currentDirective, currentCount);

        reset();
      }

      for (var i = 0; i < format.length; i++) {
        var currentChar = format[i];

        if (directives.indexOf(currentChar) !== -1) {
          // Directive char always resets current state
          yieldAndReset();
          currentDirective = currentChar;
        } else if (currentDirective) {
          if (/\d/.test(currentChar)) {
            // Count can be represented as a sequence of digits
            currentCount = currentCount * 10 + parseInt(currentChar, 10);
            countSpecified = true;
          } else if (currentChar === '*' && countSpecified === false) {
            // Count can be represented by a star character
            currentCount = Infinity;
            countSpecified = true;
          } else if (modifiers.indexOf(currentChar) !== -1 && countSpecified === false) {
            // Directives can be specified only after directive and before count
            currentModifiers.push(currentChar);
          } else {
            yieldAndReset();
          }
        }
      }

      yieldAndReset();
    }
  
  })($nesting[0], $nesting)
};

Opal.modules["corelib/array/pack"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass;

  Opal.add_stubs(['$require', '$raise', '$delete', '$gsub', '$coerce_to!', '$inspect']);
  
  self.$require("corelib/pack_unpack/format_string_parser");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_pack$1;

    
    
    // Format Parser
    var eachDirectiveAndCount = Opal.PackUnpack.eachDirectiveAndCount;

    function identityFunction(value) { return value; }

    function utf8BytesToUtf16LEString(bytes) {
      var str = String.fromCharCode.apply(null, bytes), out = "", i = 0, len = str.length, c, char2, char3;
      while (i < len) {
        c = str.charCodeAt(i++);
        switch (c >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            // 0xxxxxxx
            out += str.charAt(i - 1);
            break;
          case 12:
          case 13:
            // 110x xxxx 10xx xxxx
            char2 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
            break;
          case 14:
            // 1110 xxxx10xx xxxx10xx xxxx
            char2 = str.charCodeAt(i++);
            char3 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
            break;
        }
      }
      return out;
    }

    function asciiBytesToUtf16LEString(bytes) {
      return String.fromCharCode.apply(null, bytes);
    }

    function asciiStringFromUnsignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function asciiStringFromSignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data),
            bits = bytes * 8,
            limit = Math.pow(2, bits);

        return buffer.map(function(item) {
          if (item < 0) {
            item += limit;
          }

          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function toInt(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$($nesting, 'Integer'), 'to_int')
        });
      }
    }

    function ToStr(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$($nesting, 'String'), 'to_str')
        });
      }
    }

    function fromCodePoint(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.map(function(item) {
          try {
            return String.fromCodePoint(item);
          } catch (error) {
            if (error instanceof RangeError) {
              self.$raise($$($nesting, 'RangeError'), "value out of range");
            }
            throw error;
          }
        });
      }
    }

    function joinChars(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.join('');
      }
    }

    var handlers = {
      // Integer
      'C': joinChars(asciiStringFromUnsignedInt(1, toInt(identityFunction))),
      'S': joinChars(asciiStringFromUnsignedInt(2, toInt(identityFunction))),
      'L': joinChars(asciiStringFromUnsignedInt(4, toInt(identityFunction))),
      'Q': joinChars(asciiStringFromUnsignedInt(8, toInt(identityFunction))),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': joinChars(asciiStringFromSignedInt(1, toInt(identityFunction))),
      's': joinChars(asciiStringFromSignedInt(2, toInt(identityFunction))),
      'l': joinChars(asciiStringFromSignedInt(4, toInt(identityFunction))),
      'q': joinChars(asciiStringFromSignedInt(8, toInt(identityFunction))),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': joinChars(fromCodePoint(toInt(identityFunction))),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': joinChars(identityFunction),
      'a': joinChars(identityFunction),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    function readNTimesFromBufferAndMerge(callback) {
      return function(buffer, count) {
        var chunk = [], chunkData;

        if (count === Infinity) {
          while (buffer.length > 0) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        } else {
          if (buffer.length < count) {
            self.$raise($$($nesting, 'ArgumentError'), "too few arguments");
          }
          for (var i = 0; i < count; i++) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    function readItem(buffer) {
      var chunk = buffer.slice(0, 1);
      buffer = buffer.slice(1, buffer.length);
      return { chunk: chunk, rest: buffer };
    }

    function readNCharsFromTheFirstItemAndMergeWithFallback(fallback, callback) {
      return function(buffer, count) {
        var chunk = [], source = buffer[0];

        if (source === nil) {
          source = '';
        } else if (source === undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "too few arguments");
        } else {
          source = $coerce_to(source, $$($nesting, 'String'), 'to_str');
        }

        buffer = buffer.slice(1, buffer.length);

        function infiniteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = []
          }

          chunk = chunk.concat(subChunk);
        }

        function finiteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 0) {
            subChunk = [fallback];
          }

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = [fallback];
          }

          chunk = chunk.concat(subChunk);
        }

        if (count === Infinity) {
          while (source.length > 0) {
            infiniteReeder();
          }
        } else {
          for (var i = 0; i < count; i++) {
            finiteReeder();
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    var readChunk = {
      // Integer
      'C': readNTimesFromBufferAndMerge(readItem),
      'S': readNTimesFromBufferAndMerge(readItem),
      'L': readNTimesFromBufferAndMerge(readItem),
      'Q': readNTimesFromBufferAndMerge(readItem),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': readNTimesFromBufferAndMerge(readItem),
      's': readNTimesFromBufferAndMerge(readItem),
      'l': readNTimesFromBufferAndMerge(readItem),
      'q': readNTimesFromBufferAndMerge(readItem),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': readNTimesFromBufferAndMerge(readItem),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': readNCharsFromTheFirstItemAndMergeWithFallback(" ", readItem),
      'a': readNCharsFromTheFirstItemAndMergeWithFallback("\x00", readItem),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    var autocompletion = {
      // Integer
      'C': false,
      'S': false,
      'L': false,
      'Q': false,
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': false,
      's': false,
      'l': false,
      'q': false,
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': false,
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': false,
      'a': false,
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': false,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };
  ;
    return (Opal.def(self, '$pack', $Array_pack$1 = function $$pack(format) {
      var self = this;

      
      format = $$($nesting, 'Opal')['$coerce_to!'](format, $$($nesting, 'String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      
      var output = '';

      var buffer = self.slice();

      function autocomplete(array, size) {
        while (array.length < size) {
          array.push(nil);
        }

        return array;
      }

      function processChunk(directive, count) {
        var chunk,
            chunkReader = readChunk[directive];

        if (chunkReader == null) {
          self.$raise("" + "Unsupported pack directive " + ((directive).$inspect()) + " (no chunk reader defined)")
        }

        var chunkData = chunkReader(buffer, count);
        chunk = chunkData.chunk;
        buffer = chunkData.rest;

        var handler = handlers[directive];

        if (handler == null) {
          self.$raise("" + "Unsupported pack directive " + ((directive).$inspect()) + " (no handler defined)")
        }

        return handler(chunk);
      }

      eachDirectiveAndCount(format, function(directive, count) {
        var part = processChunk(directive, count);

        if (count !== Infinity) {
          var shouldAutocomplete = autocompletion[directive]

          if (shouldAutocomplete == null) {
            self.$raise("" + "Unsupported pack directive " + ((directive).$inspect()) + " (no autocompletion rule defined)")
          }

          if (shouldAutocomplete) {
            autocomplete(part, count);
          }
        }

        output = output.concat(part);
      });

      if (format.match(/^(U\*?)+$/)) {
        return output;
      }
      else {
        return Opal.enc(output, "binary");
      }
    ;
    }, $Array_pack$1.$$arity = 1), nil) && 'pack';
  })($nesting[0], null, $nesting);
};

Opal.modules["open-uri"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $alias = Opal.alias, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs(['$require', '$private', '$respond_to?', '$=~', '$open_uri', '$to_proc', '$open_uri_original_open', '$module_function', '$open_loop', '$rewind', '$close_io', '$close!', '$closed?', '$close', '$request', '$==', '$build_response', '$raise', '$new', '$<<', '$pack', '$data', '$io', '$status=', '$-', '$meta_add_field', '$attr_reader', '$+', '$length', '$===', '$init', '$extend', '$instance_eval', '$status', '$base_uri', '$base_uri=', '$each', '$metas', '$meta_add_field2', '$attr_accessor', '$charset', '$find_encoding', '$set_encoding', '$force_encoding', '$string', '$find', '$downcase', '$[]=', '$join', '$meta_setup_encoding', '$[]', '$utc', '$at', '$content_type_parse', '$scheme', '$open', '$read']);
  
  self.$require("stringio");
  self.$require("corelib/array/pack");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_open$1;

    
    self.$private();
    $alias(self, "open_uri_original_open", "open");
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return $alias(self, "open_uri_original_open", "open")
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$open', $Kernel_open$1 = function $$open(name, $a) {
      var $iter = $Kernel_open$1.$$p, block = $iter || nil, $post_args, rest, self = this, $ret_or_1 = nil;

      if ($iter) $Kernel_open$1.$$p = null;
      
      
      if ($iter) $Kernel_open$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      rest = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = name['$respond_to?']("to_str")))) {
        return /^[A-Za-z][A-Za-z0-9+\-\.]*:\/\//['$=~'](name)
      } else {
        return $ret_or_1
      }; return nil; })())) {
        return $send($$($nesting, 'OpenURI'), 'open_uri', [name].concat(Opal.to_a(rest)), block.$to_proc())
      } else {
        return $send(self, 'open_uri_original_open', [name].concat(Opal.to_a(rest)), block.$to_proc())
      };
    }, $Kernel_open$1.$$arity = -2);
    return self.$module_function("open");
  })($nesting[0], $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'OpenURI');

    var $nesting = [self].concat($parent_nesting), $OpenURI_open_uri$2, $OpenURI_close_io$3, $OpenURI_open_loop$4, $OpenURI_build_response$5, $OpenURI_data$6, $OpenURI_request$7;

    
    Opal.defs(self, '$open_uri', $OpenURI_open_uri$2 = function $$open_uri(name, $a) {
      var $post_args, rest, $iter = $OpenURI_open_uri$2.$$p, $yield = $iter || nil, self = this, io = nil;

      if ($iter) $OpenURI_open_uri$2.$$p = null;
      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      rest = $post_args;;
      io = self.$open_loop(name, $hash2([], {}));
      io.$rewind();
      if (($yield !== nil)) {
        
        return (function() { try {
        return Opal.yield1($yield, io);
        } finally {
          self.$close_io(io)
        }; })();
      } else {
        return io
      };
    }, $OpenURI_open_uri$2.$$arity = -2);
    Opal.defs(self, '$close_io', $OpenURI_close_io$3 = function $$close_io(io) {
      var self = this;

      if ($truthy(io['$respond_to?']("close!"))) {
        return io['$close!']()
      } else if ($truthy(io['$closed?']())) {
        return nil
      } else {
        return io.$close()
      }
    }, $OpenURI_close_io$3.$$arity = 1);
    Opal.defs(self, '$open_loop', $OpenURI_open_loop$4 = function $$open_loop(uri, options) {
      var self = this, req = nil, data = nil, status = nil, status_text = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      
      req = self.$request(uri);
      data = req.responseText;
      status = req.status;
      status_text = req.statusText && req.statusText.errno ? req.statusText.errno : req.statusText;
      if ($truthy((function() {if ($truthy(($ret_or_2 = status['$=='](200)))) {
        return $ret_or_2
      } else {
        
        if ($truthy(($ret_or_3 = status['$=='](0)))) {
          return data
        } else {
          return $ret_or_3
        };
      }; return nil; })())) {
        return self.$build_response(req, status, status_text)
      } else {
        return self.$raise($$$($$($nesting, 'OpenURI'), 'HTTPError').$new("" + (status) + " " + (status_text), ""))
      };
    }, $OpenURI_open_loop$4.$$arity = 2);
    Opal.defs(self, '$build_response', $OpenURI_build_response$5 = function $$build_response(req, status, status_text) {
      var self = this, buf = nil, io = nil, $writer = nil, last_modified = nil;

      
      buf = $$($nesting, 'Buffer').$new();
      buf['$<<'](self.$data(req).$pack("c*"));
      io = buf.$io();
      
      $writer = ["" + (status) + " " + (status_text)];
      $send(io, 'status=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      io.$meta_add_field("content-type", req.getResponseHeader("Content-Type") || '');
      last_modified = req.getResponseHeader("Last-Modified");
      if ($truthy(last_modified)) {
        io.$meta_add_field("last-modified", last_modified)};
      return io;
    }, $OpenURI_build_response$5.$$arity = 3);
    Opal.defs(self, '$data', $OpenURI_data$6 = function $$data(req) {
      var self = this;

      
      var binStr = req.responseText;
      var byteArray = [];
      for (var i = 0, len = binStr.length; i < len; ++i) {
        var c = binStr.charCodeAt(i);
        var byteCode = c & 0xff; // byte at offset i
        byteArray.push(byteCode);
      }
      return byteArray;
    
    }, $OpenURI_data$6.$$arity = 1);
    Opal.defs(self, '$request', $OpenURI_request$7 = function $$request(uri) {
      var self = this;

      
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', uri, false);
        // We cannot use xhr.responseType = "arraybuffer" because XMLHttpRequest is used in synchronous mode.
        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType#Synchronous_XHR_restrictions
        xhr.overrideMimeType('text/plain; charset=x-user-defined');
        xhr.send();
        return xhr;
      } catch (error) {
        self.$raise($$$($$($nesting, 'OpenURI'), 'HTTPError').$new(error.message, ""))
      }
    
    }, $OpenURI_request$7.$$arity = 1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTTPError');

      var $nesting = [self].concat($parent_nesting), $HTTPError_initialize$8;

      
      
      Opal.def(self, '$initialize', $HTTPError_initialize$8 = function $$initialize(message, io) {
        var $iter = $HTTPError_initialize$8.$$p, $yield = $iter || nil, self = this;

        if ($iter) $HTTPError_initialize$8.$$p = null;
        
        $send2(self, $find_super(self, 'initialize', $HTTPError_initialize$8, false, true), 'initialize', [message, io], null);
        return (self.io = io);
      }, $HTTPError_initialize$8.$$arity = 2);
      return self.$attr_reader("io");
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Buffer');

      var $nesting = [self].concat($parent_nesting), $Buffer_initialize$9, $Buffer_$lt$lt$10, $Buffer_io$11;

      self.$$prototype.io = self.$$prototype.size = nil;
      
      
      Opal.def(self, '$initialize', $Buffer_initialize$9 = function $$initialize() {
        var self = this;

        
        self.io = $$($nesting, 'StringIO').$new();
        return (self.size = 0);
      }, $Buffer_initialize$9.$$arity = 0);
      self.$attr_reader("size");
      
      Opal.def(self, '$<<', $Buffer_$lt$lt$10 = function(str) {
        var self = this;

        
        self.io['$<<'](str);
        return (self.size = $rb_plus(self.size, str.$length()));
      }, $Buffer_$lt$lt$10.$$arity = 1);
      return (Opal.def(self, '$io', $Buffer_io$11 = function $$io() {
        var self = this;

        
        if ($truthy($$($nesting, 'Meta')['$==='](self.io))) {
        } else {
          $$($nesting, 'Meta').$init(self.io)
        };
        return self.io;
      }, $Buffer_io$11.$$arity = 0), nil) && 'io';
    })($nesting[0], null, $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Meta');

      var $nesting = [self].concat($parent_nesting), $Meta_init$12, $Meta_meta_setup_encoding$15, $Meta_set_encoding$16, $Meta_find_encoding$17, $Meta_meta_add_field2$18, $Meta_meta_add_field$19, $Meta_last_modified$20, $Meta_content_type_parse$21, $Meta_charset$22, $Meta_content_type$23;

      
      Opal.defs($$($nesting, 'Meta'), '$init', $Meta_init$12 = function $$init(obj, src) {
        var $$13, $$14, self = this, $writer = nil;

        
        
        if (src == null) {
          src = nil;
        };
        obj.$extend($$($nesting, 'Meta'));
        $send(obj, 'instance_eval', [], ($$13 = function(){var self = $$13.$$s == null ? this : $$13.$$s;

          
          self.base_uri = nil;
          self.meta = $hash2([], {});
          return (self.metas = $hash2([], {}));}, $$13.$$s = self, $$13.$$arity = 0, $$13));
        if ($truthy(src)) {
          
          
          $writer = [src.$status()];
          $send(obj, 'status=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = [src.$base_uri()];
          $send(obj, 'base_uri=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return $send(src.$metas(), 'each', [], ($$14 = function(name, values){var self = $$14.$$s == null ? this : $$14.$$s;

            
            
            if (name == null) {
              name = nil;
            };
            
            if (values == null) {
              values = nil;
            };
            return obj.$meta_add_field2(name, values);}, $$14.$$s = self, $$14.$$arity = 2, $$14));
        } else {
          return nil
        };
      }, $Meta_init$12.$$arity = -2);
      self.$attr_accessor("status");
      self.$attr_accessor("base_uri");
      self.$attr_reader("meta");
      self.$attr_reader("metas");
      
      Opal.def(self, '$meta_setup_encoding', $Meta_meta_setup_encoding$15 = function $$meta_setup_encoding() {
        var self = this, charset = nil, enc = nil;

        
        charset = self.$charset();
        enc = self.$find_encoding(charset);
        return self.$set_encoding(enc);
      }, $Meta_meta_setup_encoding$15.$$arity = 0);
      
      Opal.def(self, '$set_encoding', $Meta_set_encoding$16 = function $$set_encoding(enc) {
        var self = this;

        if ($truthy(self['$respond_to?']("force_encoding"))) {
          return self.$force_encoding(enc)
        } else if ($truthy(self['$respond_to?']("string"))) {
          return self.$string().$force_encoding(enc)
        } else {
          return self.$set_encoding(enc)
        }
      }, $Meta_set_encoding$16.$$arity = 1);
      
      Opal.def(self, '$find_encoding', $Meta_find_encoding$17 = function $$find_encoding(charset) {
        var self = this, enc = nil;

        
        enc = nil;
        if ($truthy(charset)) {
          
          try {
            enc = $$($nesting, 'Encoding').$find(charset)
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
              try {
                nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };};
        if ($truthy(enc)) {
        } else {
          enc = $$$($$($nesting, 'Encoding'), 'ASCII_8BIT')
        };
        return enc;
      }, $Meta_find_encoding$17.$$arity = 1);
      
      Opal.def(self, '$meta_add_field2', $Meta_meta_add_field2$18 = function $$meta_add_field2(name, values) {
        var self = this, $writer = nil;
        if (self.metas == null) self.metas = nil;
        if (self.meta == null) self.meta = nil;

        
        name = name.$downcase();
        
        $writer = [name, values];
        $send(self.metas, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [name, values.$join(", ")];
        $send(self.meta, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if (name['$==']("content-type")) {
          return self.$meta_setup_encoding()
        } else {
          return nil
        };
      }, $Meta_meta_add_field2$18.$$arity = 2);
      
      Opal.def(self, '$meta_add_field', $Meta_meta_add_field$19 = function $$meta_add_field(name, value) {
        var self = this;

        return self.$meta_add_field2(name, [value])
      }, $Meta_meta_add_field$19.$$arity = 2);
      
      Opal.def(self, '$last_modified', $Meta_last_modified$20 = function $$last_modified() {
        var self = this, vs = nil;
        if (self.metas == null) self.metas = nil;

        if ($truthy((vs = self.metas['$[]']("last-modified")))) {
          return $$($nesting, 'Time').$at(Date.parse(vs.$join(", ")) / 1000).$utc()
        } else {
          return nil
        }
      }, $Meta_last_modified$20.$$arity = 0);
      
      Opal.def(self, '$content_type_parse', $Meta_content_type_parse$21 = function $$content_type_parse() {
        var self = this, content_type = nil;
        if (self.metas == null) self.metas = nil;

        
        content_type = self.metas['$[]']("content-type");
        return content_type.$join(", ");
      }, $Meta_content_type_parse$21.$$arity = 0);
      
      Opal.def(self, '$charset', $Meta_charset$22 = function $$charset() {
        var self = this, type = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil;
        if (self.base_uri == null) self.base_uri = nil;

        
        type = self.$content_type_parse();
        if ($truthy((function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = type))) {
          return /^text\//['$=~'](type)
        } else {
          return $ret_or_6
        }; return nil; })()))) {
          return self.base_uri
        } else {
          return $ret_or_5
        }; return nil; })()))) {
          return /^http$/i['$=~'](self.base_uri.$scheme())
        } else {
          return $ret_or_4
        }; return nil; })())) {
          return "iso-8859-1"
        } else {
          return nil
        };
      }, $Meta_charset$22.$$arity = 0);
      return (Opal.def(self, '$content_type', $Meta_content_type$23 = function $$content_type() {
        var self = this, type = nil, $ret_or_7 = nil;

        
        type = self.$content_type_parse();
        if ($truthy(($ret_or_7 = type))) {
          return $ret_or_7
        } else {
          return "application/octet-stream"
        };
      }, $Meta_content_type$23.$$arity = 0), nil) && 'content_type';
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'OpenRead');

      var $nesting = [self].concat($parent_nesting), $OpenRead_open$24, $OpenRead_read$25;

      
      
      Opal.def(self, '$open', $OpenRead_open$24 = function $$open($a) {
        var $iter = $OpenRead_open$24.$$p, block = $iter || nil, $post_args, rest, self = this;

        if ($iter) $OpenRead_open$24.$$p = null;
        
        
        if ($iter) $OpenRead_open$24.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        rest = $post_args;;
        return $send($$($nesting, 'OpenURI'), 'open_uri', [self].concat(Opal.to_a(rest)), block.$to_proc());
      }, $OpenRead_open$24.$$arity = -1);
      return (Opal.def(self, '$read', $OpenRead_read$25 = function $$read(options) {
        var $$26, self = this;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        return $send(self, 'open', [options], ($$26 = function(f){var self = $$26.$$s == null ? this : $$26.$$s, str = nil;

          
          
          if (f == null) {
            f = nil;
          };
          str = f.$read();
          $$($nesting, 'Meta').$init(str, f);
          return str;}, $$26.$$s = self, $$26.$$arity = 1, $$26));
      }, $OpenRead_read$25.$$arity = -1), nil) && 'read';
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
};
