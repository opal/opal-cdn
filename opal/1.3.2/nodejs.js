Opal.modules["native"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range, $alias = Opal.alias, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $gvars = Opal.gvars;

  Opal.add_stubs(['$try_convert', '$native?', '$respond_to?', '$to_n', '$raise', '$inspect', '$Native', '$proc', '$map!', '$end_with?', '$define_method', '$[]', '$convert', '$call', '$to_proc', '$new', '$each', '$native_reader', '$native_writer', '$extend', '$warn', '$include', '$is_a?', '$map', '$to_a', '$_Array', '$method_missing', '$bind', '$instance_method', '$slice', '$-', '$length', '$[]=', '$enum_for', '$===', '$>=', '$<<', '$each_pair', '$method_defined?', '$_initialize', '$name', '$native_module']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $Native_is_a$ques$1, $Native_try_convert$2, $Native_convert$3, $Native_call$4, $Native_proc$5, $Native_included$22;

    
    Opal.defs(self, '$is_a?', $Native_is_a$ques$1 = function(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    }, $Native_is_a$ques$1.$$arity = 2);
    Opal.defs(self, '$try_convert', $Native_try_convert$2 = function $$try_convert(value, default$) {
      var self = this;

      
      
      if (default$ == null) {
        default$ = nil;
      };
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, $Native_try_convert$2.$$arity = -2);
    Opal.defs(self, '$convert', $Native_convert$3 = function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    }, $Native_convert$3.$$arity = 1);
    Opal.defs(self, '$call', $Native_call$4 = function $$call(obj, key, $a) {
      var $iter = $Native_call$4.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Native_call$4.$$p = null;
      
      
      if ($iter) $Native_call$4.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 2, arguments.length);
      
      args = $post_args;;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, $Native_call$4.$$arity = -3);
    Opal.defs(self, '$proc', $Native_proc$5 = function $$proc() {
      var $iter = $Native_proc$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Native_proc$5.$$p = null;
      
      
      if ($iter) $Native_proc$5.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      };
      return $send($$$('::', 'Kernel'), 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $post_args, args, $$7, instance = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        $send(args, 'map!', [], ($$7 = function(arg){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (arg == null) {
            arg = nil;
          };
          return self.$Native(arg);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, $$6.$$s = self, $$6.$$arity = -1, $$6));
    }, $Native_proc$5.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $Helpers_alias_native$8, $Helpers_native_reader$12, $Helpers_native_writer$15, $Helpers_native_accessor$18;

      
      
      Opal.def(self, '$alias_native', $Helpers_alias_native$8 = function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $$9, $$10, $$11, $iter = $Helpers_alias_native$8.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Helpers_alias_native$8.$$p = null;
        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if ($post_args.length > 0) {
          old = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (old == null) {
          old = new$;
        };
        
        as = $kwargs.$$smap["as"];
        if (as == null) {
          as = nil
        };
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], ($$9 = function(value){var self = $$9.$$s == null ? this : $$9.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            
            if (value == null) {
              value = nil;
            };
            self["native"][old['$[]']($range(0, -2, false))] = $$($nesting, 'Native').$convert(value);
            return value;}, $$9.$$s = self, $$9.$$arity = 1, $$9))
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], ($$10 = function($c){var self = $$10.$$s == null ? this : $$10.$$s, $iter = $$10.$$p, block = $iter || nil, $post_args, args, value = nil;
            if (self["native"] == null) self["native"] = nil;

            
            
            if ($iter) $$10.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            value = $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, $$10.$$s = self, $$10.$$arity = -1, $$10))
        } else {
          return $send(self, 'define_method', [new$], ($$11 = function($c){var self = $$11.$$s == null ? this : $$11.$$s, $iter = $$11.$$p, block = $iter || nil, $post_args, args;
            if (self["native"] == null) self["native"] = nil;

            
            
            if ($iter) $$11.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            return $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());}, $$11.$$s = self, $$11.$$arity = -1, $$11))
        };
      }, $Helpers_alias_native$8.$$arity = -2);
      
      Opal.def(self, '$native_reader', $Helpers_native_reader$12 = function $$native_reader($a) {
        var $post_args, names, $$13, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$13 = function(name){var self = $$13.$$s == null ? this : $$13.$$s, $$14;

          
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', [name], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s;
            if (self["native"] == null) self["native"] = nil;

            return self.$Native(self["native"][name])}, $$14.$$s = self, $$14.$$arity = 0, $$14));}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      }, $Helpers_native_reader$12.$$arity = -1);
      
      Opal.def(self, '$native_writer', $Helpers_native_writer$15 = function $$native_writer($a) {
        var $post_args, names, $$16, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$16 = function(name){var self = $$16.$$s == null ? this : $$16.$$s, $$17;

          
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', ["" + (name) + "="], ($$17 = function(value){var self = $$17.$$s == null ? this : $$17.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            
            if (value == null) {
              value = nil;
            };
            return self.$Native(self["native"][name] = value);}, $$17.$$s = self, $$17.$$arity = 1, $$17));}, $$16.$$s = self, $$16.$$arity = 1, $$16));
      }, $Helpers_native_writer$15.$$arity = -1);
      return (Opal.def(self, '$native_accessor', $Helpers_native_accessor$18 = function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        $send(self, 'native_reader', Opal.to_a(names));
        return $send(self, 'native_writer', Opal.to_a(names));
      }, $Helpers_native_accessor$18.$$arity = -1), nil) && 'native_accessor';
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $Wrapper_initialize$19, $Wrapper_to_n$20, $Wrapper_included$21;

      
      
      Opal.def(self, '$initialize', $Wrapper_initialize$19 = function $$initialize(native$) {
        var self = this;

        
        if ($truthy($$$('::', 'Kernel')['$native?'](native$))) {
        } else {
          $$$('::', 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      }, $Wrapper_initialize$19.$$arity = 1);
      
      Opal.def(self, '$to_n', $Wrapper_to_n$20 = function $$to_n() {
        var self = this;
        if (self["native"] == null) self["native"] = nil;

        return self["native"]
      }, $Wrapper_to_n$20.$$arity = 0);
      return (Opal.defs(self, '$included', $Wrapper_included$21 = function $$included(klass) {
        var self = this;

        return klass.$extend($$($nesting, 'Helpers'))
      }, $Wrapper_included$21.$$arity = 1), nil) && 'included';
    })($nesting[0], $nesting);
    return (Opal.defs(self, '$included', $Native_included$22 = function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$($nesting, 'Wrapper'));
    }, $Native_included$22.$$arity = 1), nil) && 'included';
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_native$ques$23, $Kernel_Native$24, $Kernel_Array$27;

    
    
    Opal.def(self, '$native?', $Kernel_native$ques$23 = function(value) {
      var self = this;

      return value == null || !value.$$class;
    }, $Kernel_native$ques$23.$$arity = 1);
    
    Opal.def(self, '$Native', $Kernel_Native$24 = function $$Native(obj) {
      var $$25, $$26, $iter = $Kernel_Native$24.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_Native$24.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$($nesting, 'Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Array')))) {
        return $send(obj, 'map', [], ($$25 = function(o){var self = $$25.$$s == null ? this : $$25.$$s;

          
          
          if (o == null) {
            o = nil;
          };
          return self.$Native(o);}, $$25.$$s = self, $$25.$$arity = 1, $$25))
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Proc')))) {
        return $send(self, 'proc', [], ($$26 = function($a){var self = $$26.$$s == null ? this : $$26.$$s, $iter = $$26.$$p, block = $iter || nil, $post_args, args;

          
          
          if ($iter) $$26.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return self.$Native($send(obj, 'call', Opal.to_a(args), block.$to_proc()));}, $$26.$$s = self, $$26.$$arity = -1, $$26))
      } else {
        return obj
      }
    }, $Kernel_Native$24.$$arity = 1);
    $alias(self, "_Array", "Array");
    return (Opal.def(self, '$Array', $Kernel_Array$27 = function $$Array(object, $a) {
      var $iter = $Kernel_Array$27.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_Array$27.$$p = null;
      
      
      if ($iter) $Kernel_Array$27.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$($nesting, 'Native'), 'Array'), 'new', [object].concat(Opal.to_a(args)), block.$to_proc()).$to_a()};
      return self.$_Array(object);
    }, $Kernel_Array$27.$$arity = -2), nil) && 'Array';
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_$eq_eq$28, $Object_has_key$ques$29, $Object_each$30, $Object_$$$31, $Object_$$$eq$32, $Object_merge$excl$33, $Object_respond_to$ques$34, $Object_respond_to_missing$ques$35, $Object_method_missing$36, $Object_nil$ques$37, $Object_is_a$ques$38, $Object_instance_of$ques$39, $Object_class$40, $Object_to_a$41, $Object_inspect$42;

    self.$$prototype["native"] = nil;
    
    self.$include($$$($$$('::', 'Native'), 'Wrapper'));
    
    Opal.def(self, '$==', $Object_$eq_eq$28 = function(other) {
      var self = this;

      return self["native"] === $$$('::', 'Native').$try_convert(other)
    }, $Object_$eq_eq$28.$$arity = 1);
    
    Opal.def(self, '$has_key?', $Object_has_key$ques$29 = function(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    }, $Object_has_key$ques$29.$$arity = 1);
    $alias(self, "key?", "has_key?");
    $alias(self, "include?", "has_key?");
    $alias(self, "member?", "has_key?");
    
    Opal.def(self, '$each', $Object_each$30 = function $$each($a) {
      var $post_args, args, $iter = $Object_each$30.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Object_each$30.$$p = null;
      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat(Opal.to_a(args)))
      };
    }, $Object_each$30.$$arity = -1);
    
    Opal.def(self, '$[]', $Object_$$$31 = function(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('::', 'Native').$call(self["native"], key)
      }
    
    }, $Object_$$$31.$$arity = 1);
    
    Opal.def(self, '$[]=', $Object_$$$eq$32 = function(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('::', 'Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    }, $Object_$$$eq$32.$$arity = 2);
    
    Opal.def(self, '$merge!', $Object_merge$excl$33 = function(other) {
      var self = this;

      
      
      other = $$$('::', 'Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    }, $Object_merge$excl$33.$$arity = 1);
    
    Opal.def(self, '$respond_to?', $Object_respond_to$ques$34 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return $$$('::', 'Kernel').$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, $Object_respond_to$ques$34.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Object_respond_to_missing$ques$35 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return Opal.hasOwnProperty.call(self["native"], name);
    }, $Object_respond_to_missing$ques$35.$$arity = -2);
    
    Opal.def(self, '$method_missing', $Object_method_missing$36 = function $$method_missing(mid, $a) {
      var $iter = $Object_method_missing$36.$$p, block = $iter || nil, $post_args, args, self = this, $writer = nil;

      if ($iter) $Object_method_missing$36.$$p = null;
      
      
      if ($iter) $Object_method_missing$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return (($writer = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)]), $send(self, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
      }
      else {
        return $send($$$('::', 'Native'), 'call', [self["native"], mid].concat(Opal.to_a(args)), block.$to_proc());
      }
    ;
    }, $Object_method_missing$36.$$arity = -2);
    
    Opal.def(self, '$nil?', $Object_nil$ques$37 = function() {
      var self = this;

      return false
    }, $Object_nil$ques$37.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Object_is_a$ques$38 = function(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    }, $Object_is_a$ques$38.$$arity = 1);
    $alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Object_instance_of$ques$39 = function(klass) {
      var self = this;

      return self.$$class === klass;
    }, $Object_instance_of$ques$39.$$arity = 1);
    
    Opal.def(self, '$class', $Object_class$40 = function() {
      var self = this;

      return self.$$class;
    }, $Object_class$40.$$arity = 0);
    
    Opal.def(self, '$to_a', $Object_to_a$41 = function $$to_a(options) {
      var $iter = $Object_to_a$41.$$p, block = $iter || nil, self = this;

      if ($iter) $Object_to_a$41.$$p = null;
      
      
      if ($iter) $Object_to_a$41.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      return $send($$$($$$('::', 'Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, $Object_to_a$41.$$arity = -1);
    return (Opal.def(self, '$inspect', $Object_inspect$42 = function $$inspect() {
      var self = this;

      return "" + "#<Native:" + (String(self["native"])) + ">"
    }, $Object_inspect$42.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), $$($nesting, 'BasicObject'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_initialize$43, $Array_each$44, $Array_$$$45, $Array_$$$eq$46, $Array_last$47, $Array_length$48, $Array_inspect$49;

    self.$$prototype.named = self.$$prototype["native"] = self.$$prototype.get = self.$$prototype.block = self.$$prototype.set = self.$$prototype.length = nil;
    
    self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
    self.$include($$($nesting, 'Enumerable'));
    
    Opal.def(self, '$initialize', $Array_initialize$43 = function $$initialize(native$, options) {
      var $iter = $Array_initialize$43.$$p, block = $iter || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($iter) $Array_initialize$43.$$p = null;
      
      
      if ($iter) $Array_initialize$43.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      $send2(self, $find_super(self, 'initialize', $Array_initialize$43, false, true), 'initialize', [native$], null);
      self.get = (function() {if ($truthy(($ret_or_1 = options['$[]']("get")))) {
        return $ret_or_1
      } else {
        return options['$[]']("access")
      }; return nil; })();
      self.named = options['$[]']("named");
      self.set = (function() {if ($truthy(($ret_or_2 = options['$[]']("set")))) {
        return $ret_or_2
      } else {
        return options['$[]']("access")
      }; return nil; })();
      self.length = (function() {if ($truthy(($ret_or_3 = options['$[]']("length")))) {
        return $ret_or_3
      } else {
        return "length"
      }; return nil; })();
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$($nesting, 'ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, $Array_initialize$43.$$arity = -2);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$[]', $Array_$$$45 = function(index) {
      var self = this, result = nil, $case = nil;

      
      result = (function() {$case = index;
      if ($$($nesting, 'String')['$===']($case) || $$($nesting, 'Symbol')['$===']($case)) {if ($truthy(self.named)) {
        return self["native"][self.named](index)
      } else {
        return self["native"][index]
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(self.get)) {
        return self["native"][self.get](index)
      } else {
        return self["native"][index]
      }}
      else { return nil }})();
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    }, $Array_$$$45.$$arity = 1);
    
    Opal.def(self, '$[]=', $Array_$$$eq$46 = function(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$($nesting, 'Native').$convert(value))
      } else {
        return self["native"][index] = $$($nesting, 'Native').$convert(value)
      }
    }, $Array_$$$eq$46.$$arity = 2);
    
    Opal.def(self, '$last', $Array_last$47 = function $$last(count) {
      var $a, self = this, index = nil, result = nil;

      
      
      if (count == null) {
        count = nil;
      };
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
          
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, $Array_last$47.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$48 = function $$length() {
      var self = this;

      return self["native"][self.length]
    }, $Array_length$48.$$arity = 0);
    $alias(self, "to_ary", "to_a");
    return (Opal.def(self, '$inspect', $Array_inspect$49 = function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    }, $Array_inspect$49.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_to_n$50;

    return (Opal.def(self, '$to_n', $Numeric_to_n$50 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Numeric_to_n$50.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_to_n$51;

    return (Opal.def(self, '$to_n', $Proc_to_n$51 = function $$to_n() {
      var self = this;

      return self
    }, $Proc_to_n$51.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_n$52;

    return (Opal.def(self, '$to_n', $String_to_n$52 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $String_to_n$52.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_to_n$53;

    return (Opal.def(self, '$to_n', $Regexp_to_n$53 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Regexp_to_n$53.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_to_n$54;

    self.$$prototype.matches = nil;
    return (Opal.def(self, '$to_n', $MatchData_to_n$54 = function $$to_n() {
      var self = this;

      return self.matches
    }, $MatchData_to_n$54.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_to_n$55;

    return (Opal.def(self, '$to_n', $Struct_to_n$55 = function $$to_n() {
      var $$56, self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], ($$56 = function(name, value){var self = $$56.$$s == null ? this : $$56.$$s;

        
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return result[name] = $$($nesting, 'Native').$try_convert(value, value);}, $$56.$$s = self, $$56.$$arity = 2, $$56));
      return result;
    }, $Struct_to_n$55.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_to_n$57;

    return (Opal.def(self, '$to_n', $Array_to_n$57 = function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$($nesting, 'Native').$try_convert(obj, obj));
      }

      return result;
    
    }, $Array_to_n$57.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean_to_n$58;

    return (Opal.def(self, '$to_n', $Boolean_to_n$58 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Boolean_to_n$58.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_to_n$59;

    return (Opal.def(self, '$to_n', $Time_to_n$59 = function $$to_n() {
      var self = this;

      return self
    }, $Time_to_n$59.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_n$60;

    return (Opal.def(self, '$to_n', $NilClass_to_n$60 = function $$to_n() {
      var self = this;

      return null;
    }, $NilClass_to_n$60.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  if ($truthy($$($nesting, 'Hash')['$method_defined?']("_initialize"))) {
  } else {
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Hash');

      var $nesting = [self].concat($parent_nesting), $Hash_initialize$61, $Hash_to_n$62;

      
      $alias(self, "_initialize", "initialize");
      
      Opal.def(self, '$initialize', $Hash_initialize$61 = function $$initialize(defaults) {
        var $iter = $Hash_initialize$61.$$p, block = $iter || nil, self = this;

        if ($iter) $Hash_initialize$61.$$p = null;
        
        
        if ($iter) $Hash_initialize$61.$$p = null;;
        ;
        
        if (defaults != null &&
             (defaults.constructor === undefined ||
               defaults.constructor === Object)) {
          var smap = self.$$smap,
              keys = self.$$keys,
              key, value;

          for (key in defaults) {
            value = defaults[key];

            if (value &&
                 (value.constructor === undefined ||
                   value.constructor === Object)) {
              smap[key] = $$($nesting, 'Hash').$new(value);
            } else if (value && value.$$is_array) {
              value = value.map(function(item) {
                if (item &&
                     (item.constructor === undefined ||
                       item.constructor === Object)) {
                  return $$($nesting, 'Hash').$new(item);
                }

                return self.$Native(item);
              });
              smap[key] = value
            } else {
              smap[key] = self.$Native(value);
            }

            keys.push(key);
          }

          return self;
        }

        return $send(self, '_initialize', [defaults], block.$to_proc());
      ;
      }, $Hash_initialize$61.$$arity = -1);
      return (Opal.def(self, '$to_n', $Hash_to_n$62 = function $$to_n() {
        var self = this;

        
        var result = {},
            keys = self.$$keys,
            smap = self.$$smap,
            key, value;

        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = smap[key];
          } else {
            key = key.key;
            value = key.value;
          }

          result[key] = $$($nesting, 'Native').$try_convert(value, value);
        }

        return result;
      
      }, $Hash_to_n$62.$$arity = 0), nil) && 'to_n';
    })($nesting[0], null, $nesting)
  };
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_native_module$63;

    return (Opal.def(self, '$native_module', $Module_native_module$63 = function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    }, $Module_native_module$63.$$arity = 0), nil) && 'native_module'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_native_alias$64, $Class_native_class$65;

    
    
    Opal.def(self, '$native_alias', $Class_native_alias$64 = function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype['$' + existing_mid];
      if (!aliased) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    }, $Class_native_alias$64.$$arity = 2);
    return (Opal.def(self, '$native_class', $Class_native_class$65 = function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    }, $Class_native_class$65.$$arity = 0), nil) && 'native_class';
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

Opal.modules["nodejs/kernel"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars, $klass = Opal.klass;

  Opal.add_stubs(['$require', '$warn', '$to_str', '$is_a?', '$first', '$shift', '$to_n', '$merge', '$empty?', '$===', '$[]', '$new', '$!=', '$raise', '$==', '$encode', '$to_s', '$attr_reader']);
  
  self.$require("native");
  Opal.exit = process.exit;
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_node_require$1, $Kernel_system$2, $Kernel_$$3;
    if (self.__child_process__ == null) self.__child_process__ = nil;

    
    Opal.const_set($nesting[0], 'NODE_REQUIRE', require);
    self.__child_process__ = require('child_process');
    var __child_process__ = self.__child_process__;
    
    Opal.def(self, '$node_require', $Kernel_node_require$1 = function $$node_require(path) {
      var self = this;

      
      self.$warn("[DEPRECATION] node_require is deprecated. Please use `require('module')` instead.");
      return $$($nesting, 'NODE_REQUIRE')(path.$to_str());
    }, $Kernel_node_require$1.$$arity = 1);
    
    Opal.def(self, '$system', $Kernel_system$2 = function $$system($a, $b) {
      var $post_args, $kwargs, argv, exception, self = this, env = nil, cmdname = nil, out = nil, status = nil, pid = nil, $ret_or_1 = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      argv = $post_args;;
      
      exception = $kwargs.$$smap["exception"];
      if (exception == null) {
        exception = false
      };
      env = $hash2([], {});
      if ($truthy(argv.$first()['$is_a?']($$($nesting, 'Hash')))) {
        env = argv.$shift()};
      env = $$($nesting, 'ENV').$merge(env).$to_n();
      cmdname = argv.$shift();
      out = (function() {if ($truthy(argv['$empty?']())) {
        return __child_process__.spawnSync(cmdname, { shell: true, stdio: 'inherit', env: env })
      } else if ($truthy($$($nesting, 'Array')['$==='](cmdname))) {
        return __child_process__.spawnSync(cmdname['$[]'](0), argv, { argv0: cmdname['$[]'](1), stdio: 'inherit', env: env })
      } else {
        return __child_process__.spawnSync(cmdname, argv, { stdio: 'inherit', env: env })
      }; return nil; })();
      status = out["status"];
      if ($truthy(status === null)) {
        status = 127};
      pid = out["pid"];
      $gvars["?"] = $$$($$($nesting, 'Process'), 'Status').$new(status, pid);
      if ($truthy((function() {if ($truthy(($ret_or_1 = exception))) {
        return status['$!='](0)
      } else {
        return $ret_or_1
      }; return nil; })())) {
        self.$raise("" + "Command failed with exit " + (status) + ": " + (cmdname))};
      return status['$=='](0);
    }, $Kernel_system$2.$$arity = -1);
    return (Opal.def(self, '$`', $Kernel_$$3 = function(cmdline) {
      var self = this;

      return $$($nesting, 'Buffer').$new(__child_process__.execSync(cmdline)).$to_s().$encode("UTF-8")
    }, $Kernel_$$3.$$arity = 1), nil) && '`';
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Process');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Status');

      var $nesting = [self].concat($parent_nesting), $Status_initialize$4, $Status_exitstatus$5, $Status_success$ques$6, $Status_inspect$7;

      self.$$prototype.status = self.$$prototype.pid = nil;
      
      
      Opal.def(self, '$initialize', $Status_initialize$4 = function $$initialize(status, pid) {
        var $a, self = this;

        return $a = [status, pid], (self.status = $a[0]), (self.pid = $a[1]), $a
      }, $Status_initialize$4.$$arity = 2);
      
      Opal.def(self, '$exitstatus', $Status_exitstatus$5 = function $$exitstatus() {
        var self = this;

        return self.status
      }, $Status_exitstatus$5.$$arity = 0);
      self.$attr_reader("pid");
      
      Opal.def(self, '$success?', $Status_success$ques$6 = function() {
        var self = this;

        return self.status['$=='](0)
      }, $Status_success$ques$6.$$arity = 0);
      return (Opal.def(self, '$inspect', $Status_inspect$7 = function $$inspect() {
        var self = this;

        return "" + "#<Process::Status: pid " + (self.pid) + " exit " + (self.status) + ">"
      }, $Status_inspect$7.$$arity = 0), nil) && 'inspect';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  Opal.const_set($nesting[0], 'ARGV', process.argv.slice(2));
  if ($$($nesting, 'ARGV').$first()['$==']("--")) {
    return $$($nesting, 'ARGV').$shift()
  } else {
    return nil
  };
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $klass = Opal.klass, $alias = Opal.alias, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = (function() {if ($truthy(($ret_or_1 = basedir))) {
          return $ret_or_1
        } else {
          return $$($nesting, 'Dir').$pwd()
        }; return nil; })();
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(Opal.regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(Opal.regexp(["[", sep_chars, "]"])), path.$split(Opal.regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = Opal.regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      $alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil, $ret_or_2 = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy((function() {if ($truthy(($ret_or_2 = last_dot_idx['$nil?']()))) {
          return $ret_or_2
        } else {
          return $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))
        }; return nil; })())) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      $alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(Opal.regexp(["(^.", $$($nesting, 'SEPARATOR'), "+|", $$($nesting, 'SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s == null ? this : $$8.$$s;

          
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](Opal.regexp(["^", path]));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s == null ? this : $$10.$$s, $ret_or_3 = nil, $ret_or_4 = nil;

          
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((function() {if ($truthy(($ret_or_3 = index['$=='](0)))) {
            return item['$empty?']()
          } else {
            return $ret_or_3
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((function() {if ($truthy(($ret_or_4 = paths.$length()['$==']($rb_plus(index, 1))))) {
            return item['$empty?']()
          } else {
            return $ret_or_4
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s == null ? this : $$11.$$s, next_item = nil, $ret_or_5 = nil, $ret_or_6 = nil;

          
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy((function() {if ($truthy(($ret_or_5 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            } else {
              return $ret_or_5
            }; return nil; })())) {
              item = item.$sub(Opal.regexp([$$($nesting, 'SEPARATOR'), "+$"]), "")};
            return (result = (function() {if ($truthy((function() {if ($truthy(($ret_or_6 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return $ret_or_6
            } else {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            }; return nil; })())) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

Opal.modules["nodejs/file"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs(['$require', '$raise', '$warn', '$const_get', '$new', '$const_defined?', '$const_set', '$size', '$respond_to?', '$path', '$join', '$call', '$exist?', '$realpath', '$!=', '$close', '$to_path', '$pwd', '$to_str', '$include?', '$delete', '$match?', '$sub', '$attr_reader']);
  
  self.$require("corelib/file");
  
  var warnings = {}, errno_code, errno_codes = [
    'EACCES',
    'EISDIR',
    'EMFILE',
    'ENOENT',
    'EPERM'
  ];

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }
  function warn(string) {
    if (warnings[string]) {
      return;
    }
    warnings[string] = true;
    self.$warn(string);
  }
  function is_utf8(bytes) {
    var i = 0;
    while (i < bytes.length) {
      if ((// ASCII
        bytes[i] === 0x09 ||
        bytes[i] === 0x0A ||
        bytes[i] === 0x0D ||
        (0x20 <= bytes[i] && bytes[i] <= 0x7E)
      )
      ) {
        i += 1;
        continue;
      }

      if ((// non-overlong 2-byte
        (0xC2 <= bytes[i] && bytes[i] <= 0xDF) &&
        (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF)
      )
      ) {
        i += 2;
        continue;
      }

      if ((// excluding overlongs
          bytes[i] === 0xE0 &&
          (0xA0 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        ) ||
        (// straight 3-byte
          ((0xE1 <= bytes[i] && bytes[i] <= 0xEC) ||
            bytes[i] === 0xEE ||
            bytes[i] === 0xEF) &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        ) ||
        (// excluding surrogates
          bytes[i] === 0xED &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x9F) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        )
      ) {
        i += 3;
        continue;
      }

      if ((// planes 1-3
          bytes[i] === 0xF0 &&
          (0x90 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        ) ||
        (// planes 4-15
          (0xF1 <= bytes[i] && bytes[i] <= 0xF3) &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        ) ||
        (// plane 16
          bytes[i] === 0xF4 &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x8F) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        )
      ) {
        i += 4;
        continue;
      }

      return false;
    }

    return true;
  }
  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (errno_codes.indexOf(error.code) >= 0) {
        var error_class = $$($nesting, 'Errno').$const_get(error.code)
        throw (error_class).$new(error.message);
      }
      throw error;
    }
  }

  for(var i = 0, ii = errno_codes.length; i < ii; i++) {
    errno_code = errno_codes[i];
    if (!$$($nesting, 'Errno')['$const_defined?'](errno_code)) {
      $$($nesting, 'Errno').$const_set(errno_code, $$($nesting, 'Class').$new($$($nesting, 'SystemCallError')))
    }
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $File_read$1, $File_write$2, $File_delete$3, $File_exist$ques$4, $File_realpath$5, $File_join$6, $File_directory$ques$7, $File_file$ques$8, $File_readable$ques$9, $File_size$10, $File_open$11, $File_stat$12, $File_mtime$13, $File_symlink$ques$14, $File_absolute_path$15, $File_initialize$16, $File_sysread$17, $File_write$18, $File_flush$19, $File_close$20, $File_mtime$21;
    if (self.__fs__ == null) self.__fs__ = nil;
    if (self.__path__ == null) self.__path__ = nil;
    if (self.__util__ == null) self.__util__ = nil;

    self.$$prototype.eof = self.$$prototype.binary_flag = self.$$prototype.path = self.$$prototype.fd = nil;
    
    self.__fs__ = require('fs');
    self.__path__ = require('path');
    self.__util__ = require('util');
    var __fs__ = self.__fs__;
    var __path__ = self.__path__;
    var __util__ = self.__util__;
    var __TextEncoder__ = typeof TextEncoder !== 'undefined' ? TextEncoder : __util__.TextEncoder;
    var __TextDecoder__ = typeof TextDecoder !== 'undefined' ? TextDecoder : __util__.TextDecoder;
    var __utf8TextDecoder__ = new __TextDecoder__('utf8');
    var __textEncoder__ = new __TextEncoder__();
    if ($truthy(__path__.sep !== $$($nesting, 'Separator'))) {
      Opal.const_set($nesting[0], 'ALT_SEPARATOR', __path__.sep)};
    Opal.defs(self, '$read', $File_read$1 = function $$read(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.readFileSync(path).toString()})
    }, $File_read$1.$$arity = 1);
    Opal.defs(self, '$write', $File_write$2 = function $$write(path, data) {
      var self = this;

      
      executeIOAction(function(){return __fs__.writeFileSync(path, data)});
      return data.$size();
    }, $File_write$2.$$arity = 2);
    Opal.defs(self, '$delete', $File_delete$3 = function(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.unlinkSync(path)})
    }, $File_delete$3.$$arity = 1);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return $alias(self, "unlink", "delete")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$exist?', $File_exist$ques$4 = function(path) {
      var self = this;

      
      if ($truthy(path['$respond_to?']("path"))) {
        path = path.$path()};
      return executeIOAction(function(){return __fs__.existsSync(path)});
    }, $File_exist$ques$4.$$arity = 1);
    Opal.defs(self, '$realpath', $File_realpath$5 = function $$realpath(pathname, dir_string, cache) {
      var $iter = $File_realpath$5.$$p, block = $iter || nil, self = this;

      if ($iter) $File_realpath$5.$$p = null;
      
      
      if ($iter) $File_realpath$5.$$p = null;;
      
      if (dir_string == null) {
        dir_string = nil;
      };
      
      if (cache == null) {
        cache = nil;
      };
      if ($truthy(dir_string)) {
        pathname = self.$join(dir_string, pathname)};
      if ((block !== nil)) {
        
        __fs__.realpath(pathname, cache, function(error, realpath){
          if (error) Opal.IOError.$new(error.message)
          else block.$call(realpath)
        })
        
      } else {
        return executeIOAction(function(){return __fs__.realpathSync(pathname, cache)})
      };
    }, $File_realpath$5.$$arity = -2);
    Opal.defs(self, '$join', $File_join$6 = function $$join($a) {
      var $post_args, paths, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      paths = $post_args;;
      return __path__.posix.join.apply(__path__, paths);
    }, $File_join$6.$$arity = -1);
    Opal.defs(self, '$directory?', $File_directory$ques$7 = function(path) {
      var self = this, result = nil, realpath = nil;

      
      if ($truthy(self['$exist?'](path))) {
      } else {
        return false
      };
      result = executeIOAction(function(){return !!__fs__.lstatSync(path).isDirectory()});
      if ($truthy(result)) {
      } else {
        
        realpath = self.$realpath(path);
        if ($truthy(realpath['$!='](path))) {
          result = executeIOAction(function(){return !!__fs__.lstatSync(realpath).isDirectory()})};
      };
      return result;
    }, $File_directory$ques$7.$$arity = 1);
    Opal.defs(self, '$file?', $File_file$ques$8 = function(path) {
      var self = this, result = nil, realpath = nil;

      
      if ($truthy(self['$exist?'](path))) {
      } else {
        return false
      };
      result = executeIOAction(function(){return !!__fs__.lstatSync(path).isFile()});
      if ($truthy(result)) {
      } else {
        
        realpath = self.$realpath(path);
        if ($truthy(realpath['$!='](path))) {
          result = executeIOAction(function(){return !!__fs__.lstatSync(realpath).isFile()})};
      };
      return result;
    }, $File_file$ques$8.$$arity = 1);
    Opal.defs(self, '$readable?', $File_readable$ques$9 = function(path) {
      var self = this;

      
      if ($truthy(self['$exist?'](path))) {
      } else {
        return false
      };
      return "" + "\n" + "        try {\n" + "          __fs__.accessSync(path, __fs__.R_OK);\n" + "          return true;\n" + "        } catch (error) {\n" + "          return false;\n" + "        }\n" + "      ";
    }, $File_readable$ques$9.$$arity = 1);
    Opal.defs(self, '$size', $File_size$10 = function $$size(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.lstatSync(path).size});
    }, $File_size$10.$$arity = 1);
    Opal.defs(self, '$open', $File_open$11 = function $$open(path, mode) {
      var $iter = $File_open$11.$$p, $yield = $iter || nil, self = this, file = nil;

      if ($iter) $File_open$11.$$p = null;
      
      
      if (mode == null) {
        mode = "r";
      };
      file = self.$new(path, mode);
      if (($yield !== nil)) {
        
        return (function() { try {
        return Opal.yield1($yield, file);
        } finally {
          file.$close()
        }; })();
      } else {
        return file
      };
    }, $File_open$11.$$arity = -2);
    Opal.defs(self, '$stat', $File_stat$12 = function $$stat(path) {
      var self = this;

      
      if ($truthy(path['$respond_to?']("path"))) {
        path = path.$path()};
      return $$$($$($nesting, 'File'), 'Stat').$new(path);
    }, $File_stat$12.$$arity = 1);
    Opal.defs(self, '$mtime', $File_mtime$13 = function $$mtime(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(path).mtime})
    }, $File_mtime$13.$$arity = 1);
    Opal.defs(self, '$symlink?', $File_symlink$ques$14 = function(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.lstatSync(path).isSymbolicLink()})
    }, $File_symlink$ques$14.$$arity = 1);
    Opal.defs(self, '$absolute_path', $File_absolute_path$15 = function $$absolute_path(path, basedir) {
      var self = this, $ret_or_1 = nil;

      
      
      if (basedir == null) {
        basedir = nil;
      };
      path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
        return path.$to_path()
      } else {
        return path
      }; return nil; })();
      basedir = (function() {if ($truthy(($ret_or_1 = basedir))) {
        return $ret_or_1
      } else {
        return $$($nesting, 'Dir').$pwd()
      }; return nil; })();
      return __path__.normalize(__path__.resolve(basedir.$to_str(), path.$to_str())).split(__path__.sep).join(__path__.posix.sep);
    }, $File_absolute_path$15.$$arity = -2);
    
    Opal.def(self, '$initialize', $File_initialize$16 = function $$initialize(path, flags) {
      var $iter = $File_initialize$16.$$p, $yield = $iter || nil, self = this, encoding_option_rx = nil, fd = nil;

      if ($iter) $File_initialize$16.$$p = null;
      
      
      if (flags == null) {
        flags = "r";
      };
      self.binary_flag = flags['$include?']("b");
      flags = flags.$delete("b");
      encoding_option_rx = /:(.*)/;
      if ($truthy(encoding_option_rx['$match?'](flags))) {
        
        handle_unsupported_feature("Encoding option (:encoding) is unsupported by Node.js openSync method and will be removed.");
        flags = flags.$sub(encoding_option_rx, "");};
      self.path = path;
      fd = executeIOAction(function(){return __fs__.openSync(path, flags)});
      return $send2(self, $find_super(self, 'initialize', $File_initialize$16, false, true), 'initialize', [fd, flags], null);
    }, $File_initialize$16.$$arity = -2);
    self.$attr_reader("path");
    
    Opal.def(self, '$sysread', $File_sysread$17 = function $$sysread(bytes) {
      var self = this, res = nil;

      if ($truthy(self.eof)) {
        return self.$raise($$($nesting, 'EOFError'), "end of file reached")
      } else {
        
        if ($truthy(self.binary_flag)) {
          
          
          var buf = executeIOAction(function(){return __fs__.readFileSync(self.path)})
          var content
          if (is_utf8(buf)) {
            content = buf.toString('utf8')
          } else {
            // coerce to utf8
            content = __utf8TextDecoder__.decode(__textEncoder__.encode(buf.toString('binary')))
          }
        ;
          res = content;
        } else {
          res = executeIOAction(function(){return __fs__.readFileSync(self.path).toString('utf8')})
        };
        self.eof = true;
        self.lineno = res.$size();
        return res;
      }
    }, $File_sysread$17.$$arity = 1);
    
    Opal.def(self, '$write', $File_write$18 = function $$write(string) {
      var self = this;

      return executeIOAction(function(){return __fs__.writeSync(self.fd, string)})
    }, $File_write$18.$$arity = 1);
    
    Opal.def(self, '$flush', $File_flush$19 = function $$flush() {
      var self = this;

      return executeIOAction(function(){return __fs__.fsyncSync(self.fd)})
    }, $File_flush$19.$$arity = 0);
    
    Opal.def(self, '$close', $File_close$20 = function $$close() {
      var $iter = $File_close$20.$$p, $yield = $iter || nil, self = this;

      if ($iter) $File_close$20.$$p = null;
      
      executeIOAction(function(){return __fs__.closeSync(self.fd)});
      return $send2(self, $find_super(self, 'close', $File_close$20, false, true), 'close', [], $iter);
    }, $File_close$20.$$arity = 0);
    return (Opal.def(self, '$mtime', $File_mtime$21 = function $$mtime() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).mtime})
    }, $File_mtime$21.$$arity = 0), nil) && 'mtime';
  })($nesting[0], $$($nesting, 'IO'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Stat');

    var $nesting = [self].concat($parent_nesting), $Stat_initialize$22, $Stat_file$ques$23, $Stat_mtime$24;
    if (self.__fs__ == null) self.__fs__ = nil;

    self.$$prototype.path = nil;
    
    self.__fs__ = require('fs');
    var __fs__ = self.__fs__;
    
    Opal.def(self, '$initialize', $Stat_initialize$22 = function $$initialize(path) {
      var self = this;

      return (self.path = path)
    }, $Stat_initialize$22.$$arity = 1);
    
    Opal.def(self, '$file?', $Stat_file$ques$23 = function() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).isFile()})
    }, $Stat_file$ques$23.$$arity = 0);
    return (Opal.def(self, '$mtime', $Stat_mtime$24 = function $$mtime() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).mtime})
    }, $Stat_mtime$24.$$arity = 0), nil) && 'mtime';
  })($$($nesting, 'File'), null, $nesting);
};

Opal.modules["nodejs/dir"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $alias = Opal.alias;

  Opal.add_stubs(['$respond_to?', '$flat_map', '$to_path', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);
    if (self.__glob__ == null) self.__glob__ = nil;
    if (self.__fs__ == null) self.__fs__ = nil;
    if (self.__path__ == null) self.__path__ = nil;
    if (self.__os__ == null) self.__os__ = nil;

    
    self.__glob__ = require('glob');
    self.__fs__ = require('fs');
    self.__path__ = require('path');
    self.__os__ = require('os');
    var __glob__ = self.__glob__;
    var __fs__ = self.__fs__;
    var __path__ = self.__path__;
    var __os__ = self.__os__;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$$1, $pwd$2, $home$3, $chdir$4, $mkdir$5, $entries$6, $glob$7;

      
      
      Opal.def(self, '$[]', $$$1 = function(glob) {
        var self = this;

        return __glob__.sync(glob)
      }, $$$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return process.cwd().split(__path__.sep).join(__path__.posix.sep);
      }, $pwd$2.$$arity = 0);
      
      Opal.def(self, '$home', $home$3 = function $$home() {
        var self = this;

        return __os__.homedir();
      }, $home$3.$$arity = 0);
      
      Opal.def(self, '$chdir', $chdir$4 = function $$chdir(path) {
        var self = this;

        return process.chdir(path)
      }, $chdir$4.$$arity = 1);
      
      Opal.def(self, '$mkdir', $mkdir$5 = function $$mkdir(path) {
        var self = this;

        return __fs__.mkdirSync(path)
      }, $mkdir$5.$$arity = 1);
      
      Opal.def(self, '$entries', $entries$6 = function $$entries(dirname) {
        var self = this;

        
        var result = [];
        var entries = __fs__.readdirSync(dirname);
        for (var i = 0, ii = entries.length; i < ii; i++) {
          result.push(entries[i]);
        }
        return result;
      
      }, $entries$6.$$arity = 1);
      
      Opal.def(self, '$glob', $glob$7 = function $$glob(pattern) {
        var $$8, self = this;

        
        if ($truthy(pattern['$respond_to?']("each"))) {
        } else {
          pattern = [pattern]
        };
        return $send(pattern, 'flat_map', [], ($$8 = function(subpattern){var self = $$8.$$s == null ? this : $$8.$$s;

          
          
          if (subpattern == null) {
            subpattern = nil;
          };
          if ($truthy(subpattern['$respond_to?']("to_path"))) {
            subpattern = subpattern.$to_path()};
          subpattern = $$($nesting, 'Opal')['$coerce_to!'](subpattern, $$($nesting, 'String'), "to_str");
          return __glob__.sync(subpattern);;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
      }, $glob$7.$$arity = 1);
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], null, $nesting)
};

Opal.modules["nodejs/io"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$5, $$6, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $alias = Opal.alias, $lambda = Opal.lambda, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$attr_reader', '$initialize_before_node_io', '$write', '$read', '$write_proc=', '$-', '$read_proc=', '$tty=']);
  
  
  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (error.code === 'EACCES' ||
          error.code === 'EISDIR' ||
          error.code === 'EMFILE' ||
          error.code === 'ENOENT' ||
          error.code === 'EPERM') {
        throw Opal.IOError.$new(error.message)
      }
      throw error;
    }
  }
;
  var __fs__ = require('fs');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_initialize$1, $IO_write$2, $IO_read$3, $IO_binread$4;

    
    self.__fs__ = __fs__;
    self.$attr_reader("lineno");
    $alias(self, "initialize_before_node_io", "initialize");
    
    Opal.def(self, '$initialize', $IO_initialize$1 = function $$initialize(fd, flags) {
      var self = this;

      
      
      if (flags == null) {
        flags = "r";
      };
      self.lineno = 0;
      return self.$initialize_before_node_io(fd, flags);
    }, $IO_initialize$1.$$arity = -2);
    Opal.defs(self, '$write', $IO_write$2 = function $$write(path, data) {
      var self = this;

      return $$($nesting, 'File').$write(path, data)
    }, $IO_write$2.$$arity = 2);
    Opal.defs(self, '$read', $IO_read$3 = function $$read(path) {
      var self = this;

      return $$($nesting, 'File').$read(path)
    }, $IO_read$3.$$arity = 1);
    return (Opal.defs(self, '$binread', $IO_binread$4 = function $$binread(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.readFileSync(path).toString('binary')})
    }, $IO_binread$4.$$arity = 1), nil) && 'binread';
  })($nesting[0], null, $nesting);
  
  $writer = [$lambda(($$5 = function(string){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    if (string == null) {
      string = nil;
    };
    return process.stdout.write(string);;}, $$5.$$s = self, $$5.$$arity = 1, $$5))];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [$lambda(($$6 = function(string){var self = $$6.$$s == null ? this : $$6.$$s;

    
    
    if (string == null) {
      string = nil;
    };
    return process.stderr.write(string);;}, $$6.$$s = self, $$6.$$arity = 1, $$6))];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [function(_count) {
  // Ignore count, return as much as we can get
  var buf = Buffer.alloc(65536), count;
  try {
    count = __fs__.readSync(this.fd, buf, 0, 65536, null);
  }
  catch (e) { // Windows systems may raise EOF
    return nil;
  }
  if (count == 0) return nil;
  return buf.toString('utf8', 0, count);
}];
  $send($$($nesting, 'STDIN'), 'read_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDIN'), 'tty=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDOUT'), 'tty=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDERR'), 'tty=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

Opal.modules["nodejs/argf"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $gvars = Opal.gvars, $truthy = Opal.truthy, $send = Opal.send, $alias = Opal.alias, $writer = nil;

  Opal.add_stubs(['$new', '$include', '$filename', '$==', '$open', '$argv', '$shift', '$close', '$file', '$closed?', '$enum_for', '$gets', '$nil?', '$+', '$loop', '$read', '$-', '$length', '$>', '$to_a', '$each', '$attr_accessor', '$rewind', '$!', '$fileno', '$eof?', '$lineno=']);
  
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $inspect$1, $argv$2, $file$3, $filename$4, $close$5, $closed$ques$6, $each$7, $gets$8, $read$9, $readlines$11, $rewind$12, $fileno$13, $eof$ques$14;

    
    self.$include($$($nesting, 'Enumerable'));
    
    Opal.def(self, '$inspect', $inspect$1 = function $$inspect() {
      var self = this;

      return "ARGF"
    }, $inspect$1.$$arity = 0);
    
    Opal.def(self, '$argv', $argv$2 = function $$argv() {
      var self = this;

      return $$($nesting, 'ARGV')
    }, $argv$2.$$arity = 0);
    
    Opal.def(self, '$file', $file$3 = function $$file() {
      var self = this, fn = nil, $ret_or_1 = nil;
      if (self.file == null) self.file = nil;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      fn = self.$filename();
      if (fn['$==']("-")) {
        return $gvars.stdin
      } else {
        return (self.file = (function() {if ($truthy(($ret_or_1 = self.file))) {
          return $ret_or_1
        } else {
          return $$($nesting, 'File').$open(fn, "r")
        }; return nil; })())
      };
    }, $file$3.$$arity = 0);
    
    Opal.def(self, '$filename', $filename$4 = function $$filename() {
      var self = this, $ret_or_2 = nil;
      if (self.filename == null) self.filename = nil;
      if (self.last_filename == null) self.last_filename = nil;

      
      if ($truthy(self.filename)) {
        return self.filename};
      if (self.$argv()['$=='](["-"])) {
        return "-"
      } else if (self.$argv()['$==']([])) {
        if ($truthy(($ret_or_2 = self.last_filename))) {
          return $ret_or_2
        } else {
          return "-"
        }
      } else {
        
        self.file = nil;
        return (self.filename = (self.last_filename = self.$argv().$shift()));
      };
    }, $filename$4.$$arity = 0);
    
    Opal.def(self, '$close', $close$5 = function $$close() {
      var self = this;

      
      self.$file().$close();
      self.filename = nil;
      return self;
    }, $close$5.$$arity = 0);
    
    Opal.def(self, '$closed?', $closed$ques$6 = function() {
      var self = this;

      return self.$file()['$closed?']()
    }, $closed$ques$6.$$arity = 0);
    
    Opal.def(self, '$each', $each$7 = function $$each($a) {
      var $iter = $each$7.$$p, block = $iter || nil, $post_args, args, $b, self = this, l = nil;

      if ($iter) $each$7.$$p = null;
      
      
      if ($iter) $each$7.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each")
      };
      while ($truthy((l = $send(self, 'gets', Opal.to_a(args))))) {
        Opal.yield1(block, l)
      };
    }, $each$7.$$arity = -1);
    
    Opal.def(self, '$gets', $gets$8 = function $$gets($a) {
      var $post_args, args, self = this, s = nil;
      if (self.lineno == null) self.lineno = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      s = $send(self.$file(), 'gets', Opal.to_a(args));
      if ($truthy(s['$nil?']())) {
        
        self.$close();
        s = $send(self.$file(), 'gets', Opal.to_a(args));};
      if ($truthy(s)) {
        self.lineno = $rb_plus(self.lineno, 1)};
      return s;
    }, $gets$8.$$arity = -1);
    
    Opal.def(self, '$read', $read$9 = function $$read(len) {
      var $$10, self = this, buf = nil;

      
      
      if (len == null) {
        len = nil;
      };
      buf = "";
      return (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s, r = nil, $ret_or_3 = nil, $ret_or_4 = nil;
        if (self.filename == null) self.filename = nil;

        
        r = self.$file().$read(len);
        if ($truthy(r)) {
          
          buf = $rb_plus(buf, r);
          len = $rb_minus(len, r.$length());};
        self.$file().$close();
        if ($truthy((function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = len))) {
          return $rb_gt(len, 0)
        } else {
          return $ret_or_4
        }; return nil; })()))) {
          return self.filename
        } else {
          return $ret_or_3
        }; return nil; })())) {
          
          Opal.brk(nil, $brk)
        } else {
          return nil
        };}, $$10.$$s = self, $$10.$$brk = $brk, $$10.$$arity = 0, $$10))
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
    }, $read$9.$$arity = -1);
    
    Opal.def(self, '$readlines', $readlines$11 = function $$readlines($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'each', Opal.to_a(args)).$to_a();
    }, $readlines$11.$$arity = -1);
    self.$attr_accessor("lineno");
    
    Opal.def(self, '$rewind', $rewind$12 = function $$rewind() {
      var self = this, f = nil;

      
      self.lineno = 1;
      f = self.$file();
      
      try {
        f.$rewind()
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
          try {
            nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return 0;
    }, $rewind$12.$$arity = 0);
    
    Opal.def(self, '$fileno', $fileno$13 = function $$fileno() {
      var self = this, $ret_or_5 = nil;
      if (self.filename == null) self.filename = nil;
      if (self.last_filename == null) self.last_filename = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_5 = self.filename['$!']()))) {
        return self.last_filename
      } else {
        return $ret_or_5
      }; return nil; })())) {
        return 0};
      return self.$file().$fileno();
    }, $fileno$13.$$arity = 0);
    
    Opal.def(self, '$eof?', $eof$ques$14 = function() {
      var self = this;

      return self.$file()['$eof?']()
    }, $eof$ques$14.$$arity = 0);
    $alias(self, "to_io", "file");
    $alias(self, "to_i", "fileno");
    $alias(self, "skip", "close");
    $alias(self, "path", "filename");
    $alias(self, "each_line", "each");
    return $alias(self, "eof", "eof?");
  })(Opal.get_singleton_class($$($nesting, 'ARGF')), $nesting);
  
  $writer = [1];
  $send($$($nesting, 'ARGF'), 'lineno=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

Opal.modules["nodejs/open-uri"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'OpenURI');

    var $nesting = [self].concat($parent_nesting), $OpenURI_request$1, $OpenURI_data$2;
    if (self.__xmlhttprequest__ == null) self.__xmlhttprequest__ = nil;

    
    self.__xmlhttprequest__ = require('unxhr');
    var __XMLHttpRequest__ = self.__xmlhttprequest__.XMLHttpRequest;
    Opal.defs(self, '$request', $OpenURI_request$1 = function $$request(uri) {
      var self = this;

      
      var xhr = new __XMLHttpRequest__();
      xhr.open('GET', uri, false);
      xhr.responseType = 'arraybuffer';
      xhr.send();
      return xhr;
    
    }, $OpenURI_request$1.$$arity = 1);
    return (Opal.defs(self, '$data', $OpenURI_data$2 = function $$data(req) {
      var self = this;

      
      var arrayBuffer = req.response;
      var byteArray = new Uint8Array(arrayBuffer);
      var result = []
      for (var i = 0; i < byteArray.byteLength; i++) {
        result.push(byteArray[i]);
      }
      return result;
    
    }, $OpenURI_data$2.$$arity = 1), nil) && 'data';
  })($nesting[0], $nesting)
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$>', '$<', '$===', '$raise', '$class', '$<=>', '$equal?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function() {$case = rhs;
    if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {return class_name = rhs.$inspect();}
    else {return class_name = rhs.$$class;}})()
      self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if ($falsy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true};
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        return false
      };
      return normalize(cmp) == 0;;
    }, $Comparable_$eq_eq$1.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$2 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, $Comparable_$gt$2.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$3 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, $Comparable_$gt_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$4 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, $Comparable_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$5 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, $Comparable_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$6 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$6.$$arity = 2);
    return (Opal.def(self, '$clamp', $Comparable_clamp$7 = function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) {
        max = nil;
      };
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          self.$raise($$($nesting, 'ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, $Comparable_clamp$7.$$arity = -2), nil) && 'clamp';
  })($nesting[0], $nesting)
};

Opal.modules["pathname"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $alias = Opal.alias, $module = Opal.module;

  Opal.add_stubs(['$require', '$include', '$quote', '$===', '$to_s', '$path', '$respond_to?', '$to_path', '$is_a?', '$nil?', '$raise', '$class', '$==', '$new', '$pwd', '$attr_reader', '$!', '$relative?', '$chop_basename', '$basename', '$=~', '$source', '$[]', '$rindex', '$sub', '$absolute?', '$expand_path', '$plus', '$unshift', '$length', '$!=', '$empty?', '$first', '$shift', '$+', '$join', '$dirname', '$pop', '$reverse_each', '$directory?', '$extname', '$<=>', '$nonzero?', '$proc', '$casecmp', '$cleanpath', '$inspect', '$include?', '$fill', '$map', '$entries']);
  
  self.$require("corelib/comparable");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $Pathname_initialize$1, $Pathname_pwd$2, $Pathname_$eq_eq$3, $Pathname_absolute$ques$4, $Pathname_relative$ques$5, $Pathname_chop_basename$6, $Pathname_root$ques$7, $Pathname_parent$8, $Pathname_sub$9, $Pathname_cleanpath$10, $Pathname_to_path$11, $Pathname_hash$12, $Pathname_expand_path$13, $Pathname_$plus$14, $Pathname_plus$15, $Pathname_join$16, $Pathname_split$18, $Pathname_dirname$19, $Pathname_basename$20, $Pathname_directory$ques$21, $Pathname_extname$22, $Pathname_$lt_eq_gt$23, $Pathname$24, $Pathname$25, $Pathname_relative_path_from$26, $Pathname_entries$27;

    self.$$prototype.path = nil;
    
    self.$include($$($nesting, 'Comparable'));
    Opal.const_set($nesting[0], 'SEPARATOR_PAT', Opal.regexp([$$($nesting, 'Regexp').$quote($$$($$($nesting, 'File'), 'SEPARATOR'))]));
    
    Opal.def(self, '$initialize', $Pathname_initialize$1 = function $$initialize(path) {
      var self = this;

      
      if ($truthy($$($nesting, 'Pathname')['$==='](path))) {
        self.path = path.$path().$to_s()
      } else if ($truthy(path['$respond_to?']("to_path"))) {
        self.path = path.$to_path()
      } else if ($truthy(path['$is_a?']($$($nesting, 'String')))) {
        self.path = path
      } else if ($truthy(path['$nil?']())) {
        self.$raise($$($nesting, 'TypeError'), "no implicit conversion of nil into String")
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (path.$class()) + " into String")
      };
      if (self.path['$==']("\u0000")) {
        return self.$raise($$($nesting, 'ArgumentError'))
      } else {
        return nil
      };
    }, $Pathname_initialize$1.$$arity = 1);
    Opal.defs(self, '$pwd', $Pathname_pwd$2 = function $$pwd() {
      var self = this;

      return self.$new($$($nesting, 'Dir').$pwd())
    }, $Pathname_pwd$2.$$arity = 0);
    self.$attr_reader("path");
    
    Opal.def(self, '$==', $Pathname_$eq_eq$3 = function(other) {
      var self = this;

      return other.$path()['$=='](self.path)
    }, $Pathname_$eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$absolute?', $Pathname_absolute$ques$4 = function() {
      var self = this;

      return self['$relative?']()['$!']()
    }, $Pathname_absolute$ques$4.$$arity = 0);
    
    Opal.def(self, '$relative?', $Pathname_relative$ques$5 = function() {
      var $a, $b, $c, self = this, path = nil, r = nil;

      
      path = self.path;
      while ($truthy((r = self.$chop_basename(path)))) {
        $c = r, $b = Opal.to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c
      };
      return path['$==']("");
    }, $Pathname_relative$ques$5.$$arity = 0);
    
    Opal.def(self, '$chop_basename', $Pathname_chop_basename$6 = function $$chop_basename(path) {
      var self = this, base = nil;

      
      base = $$($nesting, 'File').$basename(path);
      if ($truthy($$($nesting, 'Regexp').$new("" + "^" + ($$$($$($nesting, 'Pathname'), 'SEPARATOR_PAT').$source()) + "?$")['$=~'](base))) {
        return nil
      } else {
        return [path['$[]'](0, path.$rindex(base)), base]
      };
    }, $Pathname_chop_basename$6.$$arity = 1);
    
    Opal.def(self, '$root?', $Pathname_root$ques$7 = function() {
      var self = this;

      return self.path['$==']("/")
    }, $Pathname_root$ques$7.$$arity = 0);
    
    Opal.def(self, '$parent', $Pathname_parent$8 = function $$parent() {
      var self = this, new_path = nil;

      
      new_path = self.path.$sub(/\/([^\/]+\/?$)/, "");
      if (new_path['$==']("")) {
        new_path = (function() {if ($truthy(self['$absolute?']())) {
          return "/"
        } else {
          return "."
        }; return nil; })()};
      return $$($nesting, 'Pathname').$new(new_path);
    }, $Pathname_parent$8.$$arity = 0);
    
    Opal.def(self, '$sub', $Pathname_sub$9 = function $$sub($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $$($nesting, 'Pathname').$new($send(self.path, 'sub', Opal.to_a(args)));
    }, $Pathname_sub$9.$$arity = -1);
    
    Opal.def(self, '$cleanpath', $Pathname_cleanpath$10 = function $$cleanpath() {
      var self = this;

      return Opal.normalize(self.path)
    }, $Pathname_cleanpath$10.$$arity = 0);
    
    Opal.def(self, '$to_path', $Pathname_to_path$11 = function $$to_path() {
      var self = this;

      return self.path
    }, $Pathname_to_path$11.$$arity = 0);
    
    Opal.def(self, '$hash', $Pathname_hash$12 = function $$hash() {
      var self = this;

      return self.path
    }, $Pathname_hash$12.$$arity = 0);
    
    Opal.def(self, '$expand_path', $Pathname_expand_path$13 = function $$expand_path() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$expand_path(self.path))
    }, $Pathname_expand_path$13.$$arity = 0);
    
    Opal.def(self, '$+', $Pathname_$plus$14 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Pathname')['$==='](other))) {
      } else {
        other = $$($nesting, 'Pathname').$new(other)
      };
      return $$($nesting, 'Pathname').$new(self.$plus(self.path, other.$to_s()));
    }, $Pathname_$plus$14.$$arity = 1);
    
    Opal.def(self, '$plus', $Pathname_plus$15 = function $$plus(path1, path2) {
      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, $ret_or_1 = nil, r1 = nil, basename1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, suffix2 = nil;

      
      prefix2 = path2;
      index_list2 = [];
      basename_list2 = [];
      while ($truthy((r2 = self.$chop_basename(prefix2)))) {
        
        $c = r2, $b = Opal.to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;
        index_list2.$unshift(prefix2.$length());
        basename_list2.$unshift(basename2);
      };
      if ($truthy(prefix2['$!='](""))) {
        return path2};
      prefix1 = path1;
      while ($truthy(true)) {
        
        while ($truthy((function() {if ($truthy(($ret_or_1 = basename_list2['$empty?']()['$!']()))) {
          return basename_list2.$first()['$=='](".")
        } else {
          return $ret_or_1
        }; return nil; })())) {
          
          index_list2.$shift();
          basename_list2.$shift();
        };
        if ($truthy((r1 = self.$chop_basename(prefix1)))) {
        } else {
          break;
        };
        $c = r1, $b = Opal.to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;
        if (basename1['$=='](".")) {
          continue;};
        if ($truthy((function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = basename1['$==']("..")))) {
          return $ret_or_3
        } else {
          return basename_list2['$empty?']()
        }; return nil; })()))) {
          return $ret_or_2
        } else {
          return basename_list2.$first()['$!=']("..")
        }; return nil; })())) {
          
          prefix1 = $rb_plus(prefix1, basename1);
          break;;};
        index_list2.$shift();
        basename_list2.$shift();
      };
      r1 = self.$chop_basename(prefix1);
      if ($truthy((function() {if ($truthy(($ret_or_4 = r1['$!']()))) {
        return Opal.regexp([$$($nesting, 'SEPARATOR_PAT')])['$=~']($$($nesting, 'File').$basename(prefix1))
      } else {
        return $ret_or_4
      }; return nil; })())) {
        while ($truthy((function() {if ($truthy(($ret_or_5 = basename_list2['$empty?']()['$!']()))) {
          return basename_list2.$first()['$==']("..")
        } else {
          return $ret_or_5
        }; return nil; })())) {
          
          index_list2.$shift();
          basename_list2.$shift();
        }};
      if ($truthy(basename_list2['$empty?']()['$!']())) {
        
        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));
        if ($truthy(r1)) {
          return $$($nesting, 'File').$join(prefix1, suffix2)
        } else {
          return $rb_plus(prefix1, suffix2)
        };
      } else if ($truthy(r1)) {
        return prefix1
      } else {
        return $$($nesting, 'File').$dirname(prefix1)
      };
    }, $Pathname_plus$15.$$arity = 2);
    
    Opal.def(self, '$join', $Pathname_join$16 = function $$join($a) {try {

      var $post_args, args, $$17, self = this, result = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$empty?']())) {
        return self};
      result = args.$pop();
      if ($truthy($$($nesting, 'Pathname')['$==='](result))) {
      } else {
        result = $$($nesting, 'Pathname').$new(result)
      };
      if ($truthy(result['$absolute?']())) {
        return result};
      $send(args, 'reverse_each', [], ($$17 = function(arg){var self = $$17.$$s == null ? this : $$17.$$s;

        
        
        if (arg == null) {
          arg = nil;
        };
        if ($truthy($$($nesting, 'Pathname')['$==='](arg))) {
        } else {
          arg = $$($nesting, 'Pathname').$new(arg)
        };
        result = $rb_plus(arg, result);
        if ($truthy(result['$absolute?']())) {
          Opal.ret(result)
        } else {
          return nil
        };}, $$17.$$s = self, $$17.$$arity = 1, $$17));
      return $rb_plus(self, result);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Pathname_join$16.$$arity = -1);
    
    Opal.def(self, '$split', $Pathname_split$18 = function $$split() {
      var self = this;

      return [self.$dirname(), self.$basename()]
    }, $Pathname_split$18.$$arity = 0);
    
    Opal.def(self, '$dirname', $Pathname_dirname$19 = function $$dirname() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$dirname(self.path))
    }, $Pathname_dirname$19.$$arity = 0);
    
    Opal.def(self, '$basename', $Pathname_basename$20 = function $$basename() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$basename(self.path))
    }, $Pathname_basename$20.$$arity = 0);
    
    Opal.def(self, '$directory?', $Pathname_directory$ques$21 = function() {
      var self = this;

      return $$($nesting, 'File')['$directory?'](self.path)
    }, $Pathname_directory$ques$21.$$arity = 0);
    
    Opal.def(self, '$extname', $Pathname_extname$22 = function $$extname() {
      var self = this;

      return $$($nesting, 'File').$extname(self.path)
    }, $Pathname_extname$22.$$arity = 0);
    
    Opal.def(self, '$<=>', $Pathname_$lt_eq_gt$23 = function(other) {
      var self = this;

      return self.$path()['$<=>'](other.$path())
    }, $Pathname_$lt_eq_gt$23.$$arity = 1);
    $alias(self, "eql?", "==");
    $alias(self, "===", "==");
    $alias(self, "to_str", "to_path");
    $alias(self, "to_s", "to_path");
    Opal.const_set($nesting[0], 'SAME_PATHS', (function() {if ($truthy($$$($$($nesting, 'File'), 'FNM_SYSCASE')['$nonzero?']())) {
      return $send(self, 'proc', [], ($Pathname$24 = function(a, b){var self = $Pathname$24.$$s == null ? this : $Pathname$24.$$s;

        
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a.$casecmp(b)['$=='](0);}, $Pathname$24.$$s = self, $Pathname$24.$$arity = 2, $Pathname$24))
    } else {
      return $send(self, 'proc', [], ($Pathname$25 = function(a, b){var self = $Pathname$25.$$s == null ? this : $Pathname$25.$$s;

        
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$=='](b);}, $Pathname$25.$$s = self, $Pathname$25.$$arity = 2, $Pathname$25))
    }; return nil; })());
    
    Opal.def(self, '$relative_path_from', $Pathname_relative_path_from$26 = function $$relative_path_from(base_directory) {
      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, $ret_or_6 = nil, $ret_or_7 = nil, relpath_names = nil;

      
      dest_directory = self.$cleanpath().$to_s();
      base_directory = base_directory.$cleanpath().$to_s();
      dest_prefix = dest_directory;
      dest_names = [];
      while ($truthy((r = self.$chop_basename(dest_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          dest_names.$unshift(basename)};
      };
      base_prefix = base_directory;
      base_names = [];
      while ($truthy((r = self.$chop_basename(base_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          base_names.$unshift(basename)};
      };
      if ($truthy($$($nesting, 'SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "different prefix: " + (dest_prefix.$inspect()) + " and " + (base_directory.$inspect()))
      };
      while ($truthy((function() {if ($truthy(($ret_or_6 = (function() {if ($truthy(($ret_or_7 = dest_names['$empty?']()['$!']()))) {
        return base_names['$empty?']()['$!']()
      } else {
        return $ret_or_7
      }; return nil; })()))) {
        return $$($nesting, 'SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first())
      } else {
        return $ret_or_6
      }; return nil; })())) {
        
        dest_names.$shift();
        base_names.$shift();
      };
      if ($truthy(base_names['$include?'](".."))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "base_directory has ..: " + (base_directory.$inspect()))};
      base_names.$fill("..");
      relpath_names = $rb_plus(base_names, dest_names);
      if ($truthy(relpath_names['$empty?']())) {
        return $$($nesting, 'Pathname').$new(".")
      } else {
        return $$($nesting, 'Pathname').$new($send($$($nesting, 'File'), 'join', Opal.to_a(relpath_names)))
      };
    }, $Pathname_relative_path_from$26.$$arity = 1);
    return (Opal.def(self, '$entries', $Pathname_entries$27 = function $$entries() {
      var $$28, self = this;

      return $send($$($nesting, 'Dir').$entries(self.path), 'map', [], ($$28 = function(f){var self = $$28.$$s == null ? this : $$28.$$s;

        
        
        if (f == null) {
          f = nil;
        };
        return self.$class().$new(f);}, $$28.$$s = self, $$28.$$arity = 1, $$28))
    }, $Pathname_entries$27.$$arity = 0), nil) && 'entries';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Pathname$29;

    return (Opal.def(self, '$Pathname', $Kernel_Pathname$29 = function $$Pathname(path) {
      var self = this;

      return $$($nesting, 'Pathname').$new(path)
    }, $Kernel_Pathname$29.$$arity = 1), nil) && 'Pathname'
  })($nesting[0], $nesting);
};

Opal.modules["nodejs/pathname"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass;

  Opal.add_stubs(['$require', '$include', '$to_str', '$!', '$absolute?']);
  
  self.$require("pathname");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $Pathname_absolute$ques$1, $Pathname_relative$ques$2, $Pathname_to_path$3;
    if (self.__path__ == null) self.__path__ = nil;

    self.$$prototype.path = nil;
    
    self.$include($$($nesting, 'Comparable'));
    self.__path__ = require('path');
    var __path__ = self.__path__;
    
    Opal.def(self, '$absolute?', $Pathname_absolute$ques$1 = function() {
      var self = this;

      return __path__.isAbsolute(self.path.$to_str())
    }, $Pathname_absolute$ques$1.$$arity = 0);
    
    Opal.def(self, '$relative?', $Pathname_relative$ques$2 = function() {
      var self = this;

      return self['$absolute?']()['$!']()
    }, $Pathname_relative$ques$2.$$arity = 0);
    return (Opal.def(self, '$to_path', $Pathname_to_path$3 = function $$to_path() {
      var self = this;

      return self.path
    }, $Pathname_to_path$3.$$arity = 0), nil) && 'to_path';
  })($nesting[0], null, $nesting);
};

Opal.modules["nodejs/env"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $alias = Opal.alias, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$new', '$to_s', '$key?', '$[]', '$raise', '$to_h', '$keys', '$merge']);
  
  Opal.const_set($nesting[0], 'ENV', $$($nesting, 'Object').$new());
  return (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $$$1, $$$eq$2, $key$ques$3, $empty$ques$4, $keys$5, $delete$6, $fetch$7, $to_s$8, $to_h$9, $merge$11;

    
    
    Opal.def(self, '$[]', $$$1 = function(name) {
      var self = this;

      return process.env[name] || nil
    }, $$$1.$$arity = 1);
    
    Opal.def(self, '$[]=', $$$eq$2 = function(name, value) {
      var self = this;

      return process.env[name.$to_s()] = value.$to_s()
    }, $$$eq$2.$$arity = 2);
    
    Opal.def(self, '$key?', $key$ques$3 = function(name) {
      var self = this;

      return process.env.hasOwnProperty(name)
    }, $key$ques$3.$$arity = 1);
    $alias(self, "has_key?", "key?");
    $alias(self, "include?", "key?");
    $alias(self, "member?", "key?");
    
    Opal.def(self, '$empty?', $empty$ques$4 = function() {
      var self = this;

      return Object.keys(process.env).length === 0;
    }, $empty$ques$4.$$arity = 0);
    
    Opal.def(self, '$keys', $keys$5 = function $$keys() {
      var self = this;

      return Object.keys(process.env);
    }, $keys$5.$$arity = 0);
    
    Opal.def(self, '$delete', $delete$6 = function(name) {
      var self = this;

      
      var value = process.env[name] || nil;
      delete process.env[name];
      return value;
    
    }, $delete$6.$$arity = 1);
    
    Opal.def(self, '$fetch', $fetch$7 = function $$fetch(key, default_value) {
      var $iter = $fetch$7.$$p, block = $iter || nil, self = this;

      if ($iter) $fetch$7.$$p = null;
      
      
      if ($iter) $fetch$7.$$p = null;;
      ;
      if ($truthy(self['$key?'](key))) {
        return self['$[]'](key)};
      if ((block !== nil)) {
        return Opal.yield1(block, key)};
      if ($truthy(typeof(default_value) === 'undefined')) {
      } else {
        return default_value
      };
      return self.$raise($$($nesting, 'KeyError'), "key not found");
    }, $fetch$7.$$arity = -2);
    
    Opal.def(self, '$to_s', $to_s$8 = function $$to_s() {
      var self = this;

      return "ENV"
    }, $to_s$8.$$arity = 0);
    $alias(self, "inspect", "to_s");
    
    Opal.def(self, '$to_h', $to_h$9 = function $$to_h() {
      var $$10, self = this;

      return $send(self.$keys(), 'to_h', [], ($$10 = function(k){var self = $$10.$$s == null ? this : $$10.$$s;

        
        
        if (k == null) {
          k = nil;
        };
        return [k, self['$[]'](k)];}, $$10.$$s = self, $$10.$$arity = 1, $$10))
    }, $to_h$9.$$arity = 0);
    $alias(self, "to_hash", "to_h");
    return (Opal.def(self, '$merge', $merge$11 = function $$merge(keys) {
      var self = this;

      return self.$to_h().$merge(keys)
    }, $merge$11.$$arity = 1), nil) && 'merge';
  })(Opal.get_singleton_class($$($nesting, 'ENV')), $nesting);
};

Opal.modules["nodejs"] = function(Opal) {/* Generated by Opal 1.3.2 */
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$require']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'NodeJS');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $nesting);
  self.$require("nodejs/kernel");
  self.$require("nodejs/file");
  self.$require("nodejs/dir");
  self.$require("nodejs/io");
  self.$require("nodejs/argf");
  self.$require("nodejs/open-uri");
  self.$require("nodejs/pathname");
  return self.$require("nodejs/env");
};
