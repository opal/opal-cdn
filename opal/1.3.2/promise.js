Opal.modules["promise"] = function(Opal) {/* Generated by Opal 1.3.2 */
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super;

  Opal.add_stubs(['$resolve', '$new', '$reject', '$attr_reader', '$===', '$value', '$key?', '$keys', '$!=', '$==', '$<<', '$>>', '$exception?', '$[]', '$resolved?', '$rejected?', '$!', '$error', '$include?', '$action', '$realized?', '$raise', '$^', '$call', '$resolve!', '$exception!', '$any?', '$each', '$reject!', '$there_can_be_only_one!', '$then', '$to_proc', '$fail', '$always', '$trace', '$class', '$object_id', '$+', '$inspect', '$rescue', '$act?', '$nil?', '$prev', '$push', '$concat', '$it', '$proc', '$reverse', '$pop', '$<=', '$length', '$shift', '$-', '$wait', '$map', '$reduce', '$try', '$tap', '$all?', '$find']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $Promise_value$1, $Promise_error$2, $Promise_when$3, $Promise_initialize$4, $Promise_value$5, $Promise_act$ques$6, $Promise_action$7, $Promise_exception$ques$8, $Promise_realized$ques$9, $Promise_resolved$ques$10, $Promise_rejected$ques$11, $Promise_$$12, $Promise_$lt$lt$13, $Promise_$gt$gt$14, $Promise_resolve$15, $Promise_resolve$excl$16, $Promise_reject$18, $Promise_reject$excl$19, $Promise_exception$excl$21, $Promise_then$22, $Promise_then$excl$23, $Promise_fail$24, $Promise_fail$excl$25, $Promise_always$26, $Promise_always$excl$27, $Promise_trace$28, $Promise_trace$excl$29, $Promise_there_can_be_only_one$excl$30, $Promise_inspect$31, $Promise_to_v2$32;

    self.$$prototype.value = self.$$prototype.action = self.$$prototype.exception = self.$$prototype.realized = self.$$prototype.next = self.$$prototype.delayed = self.$$prototype.error = self.$$prototype.prev = nil;
    
    Opal.defs(self, '$value', $Promise_value$1 = function $$value(value) {
      var self = this;

      return self.$new().$resolve(value)
    }, $Promise_value$1.$$arity = 1);
    Opal.defs(self, '$error', $Promise_error$2 = function $$error(value) {
      var self = this;

      return self.$new().$reject(value)
    }, $Promise_error$2.$$arity = 1);
    Opal.defs(self, '$when', $Promise_when$3 = function $$when($a) {
      var $post_args, promises, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      promises = $post_args;;
      return $$($nesting, 'When').$new(promises);
    }, $Promise_when$3.$$arity = -1);
    self.$attr_reader("error", "prev", "next");
    
    Opal.def(self, '$initialize', $Promise_initialize$4 = function $$initialize(action) {
      var self = this;

      
      
      if (action == null) {
        action = $hash2([], {});
      };
      self.action = action;
      self.realized = false;
      self.exception = false;
      self.value = nil;
      self.error = nil;
      self.delayed = false;
      self.prev = nil;
      return (self.next = []);
    }, $Promise_initialize$4.$$arity = -1);
    
    Opal.def(self, '$value', $Promise_value$5 = function $$value() {
      var self = this;

      if ($truthy($$($nesting, 'Promise')['$==='](self.value))) {
        return self.value.$value()
      } else {
        return self.value
      }
    }, $Promise_value$5.$$arity = 0);
    
    Opal.def(self, '$act?', $Promise_act$ques$6 = function() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.action['$key?']("success")))) {
        return $ret_or_1
      } else {
        return self.action['$key?']("always")
      }
    }, $Promise_act$ques$6.$$arity = 0);
    
    Opal.def(self, '$action', $Promise_action$7 = function $$action() {
      var self = this;

      return self.action.$keys()
    }, $Promise_action$7.$$arity = 0);
    
    Opal.def(self, '$exception?', $Promise_exception$ques$8 = function() {
      var self = this;

      return self.exception
    }, $Promise_exception$ques$8.$$arity = 0);
    
    Opal.def(self, '$realized?', $Promise_realized$ques$9 = function() {
      var self = this;

      return self.realized['$!='](false)
    }, $Promise_realized$ques$9.$$arity = 0);
    
    Opal.def(self, '$resolved?', $Promise_resolved$ques$10 = function() {
      var self = this;

      return self.realized['$==']("resolve")
    }, $Promise_resolved$ques$10.$$arity = 0);
    
    Opal.def(self, '$rejected?', $Promise_rejected$ques$11 = function() {
      var self = this;

      return self.realized['$==']("reject")
    }, $Promise_rejected$ques$11.$$arity = 0);
    
    Opal.def(self, '$^', $Promise_$$12 = function(promise) {
      var self = this;

      
      promise['$<<'](self);
      self['$>>'](promise);
      return promise;
    }, $Promise_$$12.$$arity = 1);
    
    Opal.def(self, '$<<', $Promise_$lt$lt$13 = function(promise) {
      var self = this;

      
      self.prev = promise;
      return self;
    }, $Promise_$lt$lt$13.$$arity = 1);
    
    Opal.def(self, '$>>', $Promise_$gt$gt$14 = function(promise) {
      var self = this, $ret_or_2 = nil;

      
      self.next['$<<'](promise);
      if ($truthy(self['$exception?']())) {
        promise.$reject(self.delayed['$[]'](0))
      } else if ($truthy(self['$resolved?']())) {
        promise.$resolve((function() {if ($truthy(self.delayed)) {
          return self.delayed['$[]'](0)
        } else {
          return self.$value()
        }; return nil; })())
      } else if ($truthy(self['$rejected?']())) {
        if ($truthy((function() {if ($truthy(($ret_or_2 = self.action['$key?']("failure")['$!']()))) {
          return $ret_or_2
        } else {
          return $$($nesting, 'Promise')['$===']((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.error
          }; return nil; })())
        }; return nil; })())) {
          promise.$reject((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.$error()
          }; return nil; })())
        } else if ($truthy(promise.$action()['$include?']("always"))) {
          promise.$reject((function() {if ($truthy(self.delayed)) {
            return self.delayed['$[]'](0)
          } else {
            return self.$error()
          }; return nil; })())}};
      return self;
    }, $Promise_$gt$gt$14.$$arity = 1);
    
    Opal.def(self, '$resolve', $Promise_resolve$15 = function $$resolve(value) {
      var self = this, block = nil, $ret_or_3 = nil, e = nil;

      
      
      if (value == null) {
        value = nil;
      };
      if ($truthy(self['$realized?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "the promise has already been realized")};
      if ($truthy($$($nesting, 'Promise')['$==='](value))) {
        return value['$<<'](self.prev)['$^'](self)};
      
      try {
        
        block = (function() {if ($truthy(($ret_or_3 = self.action['$[]']("success")))) {
          return $ret_or_3
        } else {
          return self.action['$[]']("always")
        }; return nil; })();
        if ($truthy(block)) {
          value = block.$call(value)};
        self['$resolve!'](value);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return self;
    }, $Promise_resolve$15.$$arity = -1);
    
    Opal.def(self, '$resolve!', $Promise_resolve$excl$16 = function(value) {
      var $$17, self = this;

      
      self.realized = "resolve";
      self.value = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], ($$17 = function(p){var self = $$17.$$s == null ? this : $$17.$$s;

          
          
          if (p == null) {
            p = nil;
          };
          return p.$resolve(value);}, $$17.$$s = self, $$17.$$arity = 1, $$17))
      } else {
        return (self.delayed = [value])
      };
    }, $Promise_resolve$excl$16.$$arity = 1);
    
    Opal.def(self, '$reject', $Promise_reject$18 = function $$reject(value) {
      var self = this, block = nil, $ret_or_4 = nil, e = nil;

      
      
      if (value == null) {
        value = nil;
      };
      if ($truthy(self['$realized?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "the promise has already been realized")};
      if ($truthy($$($nesting, 'Promise')['$==='](value))) {
        return value['$<<'](self.prev)['$^'](self)};
      
      try {
        
        block = (function() {if ($truthy(($ret_or_4 = self.action['$[]']("failure")))) {
          return $ret_or_4
        } else {
          return self.action['$[]']("always")
        }; return nil; })();
        if ($truthy(block)) {
          value = block.$call(value)};
        if ($truthy(self.action['$key?']("always"))) {
          self['$resolve!'](value)
        } else {
          self['$reject!'](value)
        };
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return self;
    }, $Promise_reject$18.$$arity = -1);
    
    Opal.def(self, '$reject!', $Promise_reject$excl$19 = function(value) {
      var $$20, self = this;

      
      self.realized = "reject";
      self.error = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], ($$20 = function(p){var self = $$20.$$s == null ? this : $$20.$$s;

          
          
          if (p == null) {
            p = nil;
          };
          return p.$reject(value);}, $$20.$$s = self, $$20.$$arity = 1, $$20))
      } else {
        return (self.delayed = [value])
      };
    }, $Promise_reject$excl$19.$$arity = 1);
    
    Opal.def(self, '$exception!', $Promise_exception$excl$21 = function(error) {
      var self = this;

      
      self.exception = true;
      return self['$reject!'](error);
    }, $Promise_exception$excl$21.$$arity = 1);
    
    Opal.def(self, '$then', $Promise_then$22 = function $$then() {
      var $iter = $Promise_then$22.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_then$22.$$p = null;
      
      
      if ($iter) $Promise_then$22.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["success"], {"success": block})));
    }, $Promise_then$22.$$arity = 0);
    
    Opal.def(self, '$then!', $Promise_then$excl$23 = function() {
      var $iter = $Promise_then$excl$23.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_then$excl$23.$$p = null;
      
      
      if ($iter) $Promise_then$excl$23.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'then', [], block.$to_proc());
    }, $Promise_then$excl$23.$$arity = 0);
    $alias(self, "do", "then");
    $alias(self, "do!", "then!");
    
    Opal.def(self, '$fail', $Promise_fail$24 = function $$fail() {
      var $iter = $Promise_fail$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_fail$24.$$p = null;
      
      
      if ($iter) $Promise_fail$24.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["failure"], {"failure": block})));
    }, $Promise_fail$24.$$arity = 0);
    
    Opal.def(self, '$fail!', $Promise_fail$excl$25 = function() {
      var $iter = $Promise_fail$excl$25.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_fail$excl$25.$$p = null;
      
      
      if ($iter) $Promise_fail$excl$25.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'fail', [], block.$to_proc());
    }, $Promise_fail$excl$25.$$arity = 0);
    $alias(self, "rescue", "fail");
    $alias(self, "catch", "fail");
    $alias(self, "rescue!", "fail!");
    $alias(self, "catch!", "fail!");
    
    Opal.def(self, '$always', $Promise_always$26 = function $$always() {
      var $iter = $Promise_always$26.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_always$26.$$p = null;
      
      
      if ($iter) $Promise_always$26.$$p = null;;
      return self['$^']($$($nesting, 'Promise').$new($hash2(["always"], {"always": block})));
    }, $Promise_always$26.$$arity = 0);
    
    Opal.def(self, '$always!', $Promise_always$excl$27 = function() {
      var $iter = $Promise_always$excl$27.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_always$excl$27.$$p = null;
      
      
      if ($iter) $Promise_always$excl$27.$$p = null;;
      self['$there_can_be_only_one!']();
      return $send(self, 'always', [], block.$to_proc());
    }, $Promise_always$excl$27.$$arity = 0);
    $alias(self, "finally", "always");
    $alias(self, "ensure", "always");
    $alias(self, "finally!", "always!");
    $alias(self, "ensure!", "always!");
    
    Opal.def(self, '$trace', $Promise_trace$28 = function $$trace(depth) {
      var $iter = $Promise_trace$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Promise_trace$28.$$p = null;
      
      
      if ($iter) $Promise_trace$28.$$p = null;;
      
      if (depth == null) {
        depth = nil;
      };
      return self['$^']($$($nesting, 'Trace').$new(depth, block));
    }, $Promise_trace$28.$$arity = -1);
    
    Opal.def(self, '$trace!', $Promise_trace$excl$29 = function($a) {
      var $iter = $Promise_trace$excl$29.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Promise_trace$excl$29.$$p = null;
      
      
      if ($iter) $Promise_trace$excl$29.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      self['$there_can_be_only_one!']();
      return $send(self, 'trace', Opal.to_a(args), block.$to_proc());
    }, $Promise_trace$excl$29.$$arity = -1);
    
    Opal.def(self, '$there_can_be_only_one!', $Promise_there_can_be_only_one$excl$30 = function() {
      var self = this;

      if ($truthy(self.next['$any?']())) {
        return self.$raise($$($nesting, 'ArgumentError'), "a promise has already been chained")
      } else {
        return nil
      }
    }, $Promise_there_can_be_only_one$excl$30.$$arity = 0);
    
    Opal.def(self, '$inspect', $Promise_inspect$31 = function $$inspect() {
      var self = this, result = nil, $ret_or_5 = nil;

      
      result = "" + "#<" + (self.$class()) + "(" + (self.$object_id()) + ")";
      if ($truthy(self.next['$any?']())) {
        result = $rb_plus(result, "" + " >> " + (self.next.$inspect()))};
      result = $rb_plus(result, (function() {if ($truthy(self['$realized?']())) {
        return "" + ": " + ((function() {if ($truthy(($ret_or_5 = self.value))) {
          return $ret_or_5
        } else {
          return self.error
        }; return nil; })().$inspect()) + ">"
      } else {
        return ">"
      }; return nil; })());
      return result;
    }, $Promise_inspect$31.$$arity = 0);
    $alias(self, "to_v1", "itself");
    
    Opal.def(self, '$to_v2', $Promise_to_v2$32 = function $$to_v2() {
      var $$33, $$34, self = this, v2 = nil;

      
      v2 = $$($nesting, 'PromiseV2').$new();
      $send($send(self, 'then', [], ($$33 = function(i){var self = $$33.$$s == null ? this : $$33.$$s;

        
        
        if (i == null) {
          i = nil;
        };
        return v2.$resolve(i);}, $$33.$$s = self, $$33.$$arity = 1, $$33)), 'rescue', [], ($$34 = function(i){var self = $$34.$$s == null ? this : $$34.$$s;

        
        
        if (i == null) {
          i = nil;
        };
        return v2.$reject(i);}, $$34.$$s = self, $$34.$$arity = 1, $$34));
      return v2;
    }, $Promise_to_v2$32.$$arity = 0);
    $alias(self, "to_n", "to_v2");
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Trace');

      var $nesting = [self].concat($parent_nesting), $Trace_it$35, $Trace_initialize$36;

      
      Opal.defs(self, '$it', $Trace_it$35 = function $$it(promise) {
        var self = this, current = nil, $ret_or_6 = nil, prev = nil;

        
        current = [];
        if ($truthy((function() {if ($truthy(($ret_or_6 = promise['$act?']()))) {
          return $ret_or_6
        } else {
          return promise.$prev()['$nil?']()
        }; return nil; })())) {
          current.$push(promise.$value())};
        prev = promise.$prev();
        if ($truthy(prev)) {
          return current.$concat(self.$it(prev))
        } else {
          return current
        };
      }, $Trace_it$35.$$arity = 1);
      return (Opal.def(self, '$initialize', $Trace_initialize$36 = function $$initialize(depth, block) {
        var $$37, $iter = $Trace_initialize$36.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Trace_initialize$36.$$p = null;
        
        self.depth = depth;
        return $send2(self, $find_super(self, 'initialize', $Trace_initialize$36, false, true), 'initialize', [$hash2(["success"], {"success": $send(self, 'proc', [], ($$37 = function(){var self = $$37.$$s == null ? this : $$37.$$s, trace = nil, $ret_or_7 = nil;

          
          trace = $$($nesting, 'Trace').$it(self).$reverse();
          trace.$pop();
          if ($truthy((function() {if ($truthy(($ret_or_7 = depth))) {
            return $rb_le(depth, trace.$length())
          } else {
            return $ret_or_7
          }; return nil; })())) {
            trace.$shift($rb_minus(trace.$length(), depth))};
          return $send(block, 'call', Opal.to_a(trace));}, $$37.$$s = self, $$37.$$arity = 0, $$37))})], null);
      }, $Trace_initialize$36.$$arity = 2), nil) && 'initialize';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'When');

      var $nesting = [self].concat($parent_nesting), $When_initialize$38, $When_each$40, $When_collect$42, $When_inject$44, $When_wait$46, $When_$gt$gt$48, $When_try$50;

      self.$$prototype.wait = nil;
      
      
      Opal.def(self, '$initialize', $When_initialize$38 = function $$initialize(promises) {
        var $$39, $iter = $When_initialize$38.$$p, $yield = $iter || nil, self = this;

        if ($iter) $When_initialize$38.$$p = null;
        
        
        if (promises == null) {
          promises = [];
        };
        $send2(self, $find_super(self, 'initialize', $When_initialize$38, false, true), 'initialize', [], null);
        self.wait = [];
        return $send(promises, 'each', [], ($$39 = function(promise){var self = $$39.$$s == null ? this : $$39.$$s;

          
          
          if (promise == null) {
            promise = nil;
          };
          return self.$wait(promise);}, $$39.$$s = self, $$39.$$arity = 1, $$39));
      }, $When_initialize$38.$$arity = -1);
      
      Opal.def(self, '$each', $When_each$40 = function $$each() {
        var $iter = $When_each$40.$$p, block = $iter || nil, $$41, self = this;

        if ($iter) $When_each$40.$$p = null;
        
        
        if ($iter) $When_each$40.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], ($$41 = function(values){var self = $$41.$$s == null ? this : $$41.$$s;

          
          
          if (values == null) {
            values = nil;
          };
          return $send(values, 'each', [], block.$to_proc());}, $$41.$$s = self, $$41.$$arity = 1, $$41));
      }, $When_each$40.$$arity = 0);
      
      Opal.def(self, '$collect', $When_collect$42 = function $$collect() {
        var $iter = $When_collect$42.$$p, block = $iter || nil, $$43, self = this;

        if ($iter) $When_collect$42.$$p = null;
        
        
        if ($iter) $When_collect$42.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], ($$43 = function(values){var self = $$43.$$s == null ? this : $$43.$$s;

          
          
          if (values == null) {
            values = nil;
          };
          return $$($nesting, 'When').$new($send(values, 'map', [], block.$to_proc()));}, $$43.$$s = self, $$43.$$arity = 1, $$43));
      }, $When_collect$42.$$arity = 0);
      
      Opal.def(self, '$inject', $When_inject$44 = function $$inject($a) {
        var $iter = $When_inject$44.$$p, block = $iter || nil, $post_args, args, $$45, self = this;

        if ($iter) $When_inject$44.$$p = null;
        
        
        if ($iter) $When_inject$44.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        return $send(self, 'then', [], ($$45 = function(values){var self = $$45.$$s == null ? this : $$45.$$s;

          
          
          if (values == null) {
            values = nil;
          };
          return $send(values, 'reduce', Opal.to_a(args), block.$to_proc());}, $$45.$$s = self, $$45.$$arity = 1, $$45));
      }, $When_inject$44.$$arity = -1);
      $alias(self, "map", "collect");
      $alias(self, "reduce", "inject");
      
      Opal.def(self, '$wait', $When_wait$46 = function $$wait(promise) {
        var $$47, self = this;

        
        if ($truthy($$($nesting, 'Promise')['$==='](promise))) {
        } else {
          promise = $$($nesting, 'Promise').$value(promise)
        };
        if ($truthy(promise['$act?']())) {
          promise = promise.$then()};
        self.wait['$<<'](promise);
        $send(promise, 'always', [], ($$47 = function(){var self = $$47.$$s == null ? this : $$47.$$s;
          if (self.next == null) self.next = nil;

          if ($truthy(self.next['$any?']())) {
            return self.$try()
          } else {
            return nil
          }}, $$47.$$s = self, $$47.$$arity = 0, $$47));
        return self;
      }, $When_wait$46.$$arity = 1);
      $alias(self, "and", "wait");
      
      Opal.def(self, '$>>', $When_$gt$gt$48 = function($a) {
        var $post_args, $rest_arg, $$49, $iter = $When_$gt$gt$48.$$p, $yield = $iter || nil, self = this;

        if ($iter) $When_$gt$gt$48.$$p = null;
        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        $rest_arg = $post_args;;
        return $send($send2(self, $find_super(self, '>>', $When_$gt$gt$48, false, true), '>>', Opal.to_a($rest_arg), $iter), 'tap', [], ($$49 = function(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$try()}, $$49.$$s = self, $$49.$$arity = 0, $$49));
      }, $When_$gt$gt$48.$$arity = -1);
      return (Opal.def(self, '$try', $When_try$50 = function() {
        var self = this, promise = nil;

        if ($truthy($send(self.wait, 'all?', [], "realized?".$to_proc()))) {
          
          promise = $send(self.wait, 'find', [], "rejected?".$to_proc());
          if ($truthy(promise)) {
            return self.$reject(promise.$error())
          } else {
            return self.$resolve($send(self.wait, 'map', [], "value".$to_proc()))
          };
        } else {
          return nil
        }
      }, $When_try$50.$$arity = 0), nil) && 'try';
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'PromiseV1', $$($nesting, 'Promise'));
};
