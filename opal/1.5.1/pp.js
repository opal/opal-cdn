Opal.modules["thread"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $hash2 = Opal.hash2, $Opal = Opal.Opal, $alias = Opal.alias, $return_ivar = Opal.return_ivar, $const_set = Opal.const_set, $assign_ivar_val = Opal.assign_ivar_val;

  Opal.add_stubs('allocate,core_initialize!,current,raise,[],coerce_key_name,[]=,key?,keys,private,coerce_to!,clear,empty?,size,shift,push,each,to_proc,pop,=~,last_match,to_i,inspect,attr_reader,path,locked?,lock,unlock');
  
  $klass($nesting[0], $$('StandardError'), 'ThreadError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Thread');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.fiber_locals = $proto.thread_locals = nil;
    
    $defs(self, '$current', function $$current() {
      var self = this;
      if (self.current == null) self.current = nil;

      
      if (!$truthy(self.current)) {
        
        self.current = self.$allocate();
        self.current['$core_initialize!']();
      };
      return self.current;
    }, 0);
    $defs(self, '$list', function $$list() {
      var self = this;

      return [self.$current()]
    }, 0);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments);
      
      args = $post_args;;
      return self.$raise($$('NotImplementedError'), "Thread creation not available");
    }, -1);
    
    $def(self, '$[]', function $Thread_$$$1(key) {
      var self = this;

      return self.fiber_locals['$[]'](self.$coerce_key_name(key))
    }, 1);
    
    $def(self, '$[]=', function $Thread_$$$eq$2(key, value) {
      var $a, self = this;

      return ($a = [self.$coerce_key_name(key), value], $send(self.fiber_locals, '[]=', $a), $a[$a.length - 1])
    }, 2);
    
    $def(self, '$key?', function $Thread_key$ques$3(key) {
      var self = this;

      return self.fiber_locals['$key?'](self.$coerce_key_name(key))
    }, 1);
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      return self.fiber_locals.$keys()
    }, 0);
    
    $def(self, '$thread_variable_get', function $$thread_variable_get(key) {
      var self = this;

      return self.thread_locals['$[]'](self.$coerce_key_name(key))
    }, 1);
    
    $def(self, '$thread_variable_set', function $$thread_variable_set(key, value) {
      var $a, self = this;

      return ($a = [self.$coerce_key_name(key), value], $send(self.thread_locals, '[]=', $a), $a[$a.length - 1])
    }, 2);
    
    $def(self, '$thread_variable?', function $Thread_thread_variable$ques$4(key) {
      var self = this;

      return self.thread_locals['$key?'](self.$coerce_key_name(key))
    }, 1);
    
    $def(self, '$thread_variables', function $$thread_variables() {
      var self = this;

      return self.thread_locals.$keys()
    }, 0);
    self.$private();
    
    $def(self, '$core_initialize!', function $Thread_core_initialize$excl$5() {
      var self = this;

      
      self.thread_locals = $hash2([], {});
      return (self.fiber_locals = $hash2([], {}));
    }, 0);
    
    $def(self, '$coerce_key_name', function $$coerce_key_name(key) {
      
      return $Opal['$coerce_to!'](key, $$('String'), "to_s")
    }, 1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Queue');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.storage = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        return self.$clear()
      }, 0);
      
      $def(self, '$clear', function $$clear() {
        var self = this;

        return (self.storage = [])
      }, 0);
      
      $def(self, '$empty?', function $Queue_empty$ques$6() {
        var self = this;

        return self.storage['$empty?']()
      }, 0);
      
      $def(self, '$size', function $$size() {
        var self = this;

        return self.storage.$size()
      }, 0);
      
      $def(self, '$pop', function $$pop(non_block) {
        var self = this;

        
        
        if (non_block == null) non_block = false;;
        if ($truthy(self['$empty?']())) {
          
          if ($truthy(non_block)) {
            self.$raise($$('ThreadError'), "Queue empty")
          };
          self.$raise($$('ThreadError'), "Deadlock");
        };
        return self.storage.$shift();
      }, -1);
      
      $def(self, '$push', function $$push(value) {
        var self = this;

        return self.storage.$push(value)
      }, 1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        delete $$each.$$p;
        
        ;
        return $send(self.storage, 'each', [], block.$to_proc());
      }, 0);
      $alias(self, "<<", "push");
      $alias(self, "deq", "pop");
      $alias(self, "enq", "push");
      $alias(self, "length", "size");
      return $alias(self, "shift", "pop");
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Backtrace');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Location');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.label = $proto.str = nil;
        
        
        $def(self, '$initialize', function $$initialize(str) {
          var self = this, $ret_or_1 = nil;

          
          self.str = str;
          str['$=~'](/^(.*?):(\d+):(\d+):in `(.*?)'$/);
          self.path = $$('Regexp').$last_match(1);
          self.label = $$('Regexp').$last_match(4);
          self.lineno = $$('Regexp').$last_match(2).$to_i();
          self.label['$=~'](/(\w+)$/);
          return (self.base_label = ($truthy(($ret_or_1 = $$('Regexp').$last_match(1))) ? ($ret_or_1) : (self.label)));
        }, 1);
        
        $def(self, '$to_s', $return_ivar("str"), 0);
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return self.str.$inspect()
        }, 0);
        self.$attr_reader("base_label", "label", "lineno", "path");
        return $alias(self, "absolute_path", "path");
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting);
  })($nesting[0], null, $nesting);
  $const_set($nesting[0], 'Queue', $$$($$('Thread'), 'Queue'));
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Mutex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.locked = nil;
    
    
    $def(self, '$initialize', $assign_ivar_val("locked", false), 0);
    
    $def(self, '$lock', function $$lock() {
      var self = this;

      
      if ($truthy(self.locked)) {
        self.$raise($$('ThreadError'), "Deadlock")
      };
      self.locked = true;
      return self;
    }, 0);
    
    $def(self, '$locked?', $return_ivar("locked"), 0);
    
    $def(self, '$owned?', $return_ivar("locked"), 0);
    
    $def(self, '$try_lock', function $$try_lock() {
      var self = this;

      if ($truthy(self['$locked?']())) {
        return false
      } else {
        
        self.$lock();
        return true;
      }
    }, 0);
    
    $def(self, '$unlock', function $$unlock() {
      var self = this;

      
      if (!$truthy(self.locked)) {
        self.$raise($$('ThreadError'), "Mutex not locked")
      };
      self.locked = false;
      return self;
    }, 0);
    return $def(self, '$synchronize', function $$synchronize() {
      var $yield = $$synchronize.$$p || nil, self = this;

      delete $$synchronize.$$p;
      
      self.$lock();
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        self.$unlock()
      }; })();;
    }, 0);
  })($nesting[0], null, $nesting);
};

Opal.modules["stringio"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $alias = Opal.alias;

  Opal.add_stubs('new,call,close,attr_accessor,check_readable,==,length,===,>=,raise,>,+,-,seek,check_writable,String,[],eof?,write,read,tell');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.position = $proto.string = nil;
    
    $defs(self, '$open', function $$open(string, mode) {
      var block = $$open.$$p || nil, self = this, io = nil, res = nil;

      delete $$open.$$p;
      
      ;
      
      if (string == null) string = "";;
      
      if (mode == null) mode = nil;;
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, -1);
    self.$attr_accessor("string");
    
    $def(self, '$initialize', function $$initialize(string, mode) {
      var $yield = $$initialize.$$p || nil, self = this;

      delete $$initialize.$$p;
      
      
      if (string == null) string = "";;
      
      if (mode == null) mode = "rw";;
      self.string = string;
      self.position = 0;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [nil, mode], null);
    }, -1);
    
    $def(self, '$eof?', function $StringIO_eof$ques$1() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, 0);
    
    $def(self, '$seek', function $$seek(pos, whence) {
      var self = this, $ret_or_1 = nil;

      
      
      if (whence == null) whence = $$$($$('IO'), 'SEEK_SET');;
      self.read_buffer = "";
      if ($eqeqeq($$$($$('IO'), 'SEEK_SET'), ($ret_or_1 = whence))) {
        
        if (!$truthy($rb_ge(pos, 0))) {
          self.$raise($$$($$('Errno'), 'EINVAL'))
        };
        self.position = pos;
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_CUR'), $ret_or_1)) {
        if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
          self.position = self.string.$length()
        } else {
          self.position = $rb_plus(self.position, pos)
        }
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_END'), $ret_or_1)) {
        if ($truthy($rb_gt(pos, self.string.$length()))) {
          self.position = 0
        } else {
          self.position = $rb_minus(self.position, pos)
        }
      } else {
        nil
      };
      return 0;
    }, -2);
    
    $def(self, '$tell', $return_ivar("position"), 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      self.read_buffer = "";
      string = self.$String(string);
      if ($eqeq(self.string.$length(), self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, 1);
    
    $def(self, '$read', function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      
      if (length == null) length = nil;;
      
      if (outbuf == null) outbuf = nil;;
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil
      };
      string = ($truthy(length) ? (((str = self.string['$[]'](self.position, length)), (self.position = $rb_plus(self.position, length)), ($truthy($rb_gt(self.position, self.string.$length())) ? ((self.position = self.string.$length())) : nil), str)) : (((str = self.string['$[]'](Opal.Range.$new(self.position, -1, false))), (self.position = self.string.$length()), str)));
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, -1);
    
    $def(self, '$sysread', function $$sysread(length) {
      var self = this;

      
      self.$check_readable();
      return self.$read(length);
    }, 1);
    $alias(self, "eof", "eof?");
    $alias(self, "pos", "tell");
    $alias(self, "pos=", "seek");
    return $alias(self, "readpartial", "read");
  })($nesting[0], $$('IO'), $nesting)
};

Opal.modules["prettyprint"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var $nesting = [], nil = Opal.nil, $klass = Opal.klass, $send = Opal.send, $rb_times = Opal.rb_times, $defs = Opal.defs, $truthy = Opal.truthy, $def = Opal.def, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $assign_ivar_val = Opal.assign_ivar_val, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val;

  Opal.add_stubs('dup,lambda,*,new,to_proc,flush,attr_reader,last,<,+,deq,empty?,breakables,shift,output,-,width,!,===,first,length,<<,add,break_outmost_groups,group,breakable,break?,call,text,group_sub,nest,depth,push,enq,pop,delete,each,clear,indent,current_group,newline,genspace,group_queue,[],downto,slice!,break,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'PrettyPrint');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.group_stack = $proto.maxwidth = $proto.output_width = $proto.buffer_width = $proto.group_queue = $proto.buffer = $proto.output = $proto.newline = $proto.genspace = $proto.indent = nil;
    
    $defs($$('PrettyPrint'), '$format', function $$format(output, maxwidth, newline, genspace) {
      var $yield = $$format.$$p || nil, self = this, q = nil;

      delete $$format.$$p;
      
      
      if (output == null) output = "".$dup();;
      
      if (maxwidth == null) maxwidth = 79;;
      
      if (newline == null) newline = "\n";;
      
      if (genspace == null) genspace = $send(self, 'lambda', [], function $$1(n){
        
        
        if (n == null) n = nil;;
        return $rb_times(" ", n);}, 1);;
      q = $send($$('PrettyPrint'), 'new', [output, maxwidth, newline], genspace.$to_proc());
      Opal.yield1($yield, q);
      q.$flush();
      return output;
    }, -1);
    $defs($$('PrettyPrint'), '$singleline_format', function $$singleline_format(output, maxwidth, newline, genspace) {
      var $yield = $$singleline_format.$$p || nil, q = nil;

      delete $$singleline_format.$$p;
      
      
      if (output == null) output = "".$dup();;
      
      if (maxwidth == null) maxwidth = nil;;
      
      if (newline == null) newline = nil;;
      
      if (genspace == null) genspace = nil;;
      q = $$('SingleLine').$new(output);
      Opal.yield1($yield, q);
      return output;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(output, maxwidth, newline) {
      var genspace = $$initialize.$$p || nil, self = this, $ret_or_1 = nil, root_group = nil;

      delete $$initialize.$$p;
      
      ;
      
      if (output == null) output = "".$dup();;
      
      if (maxwidth == null) maxwidth = 79;;
      
      if (newline == null) newline = "\n";;
      self.output = output;
      self.maxwidth = maxwidth;
      self.newline = newline;
      self.genspace = ($truthy(($ret_or_1 = genspace)) ? ($ret_or_1) : ($send(self, 'lambda', [], function $$2(n){
        
        
        if (n == null) n = nil;;
        return $rb_times(" ", n);}, 1)));
      self.output_width = 0;
      self.buffer_width = 0;
      self.buffer = [];
      root_group = $$('Group').$new(0);
      self.group_stack = [root_group];
      self.group_queue = $$('GroupQueue').$new(root_group);
      return (self.indent = 0);
    }, -1);
    self.$attr_reader("output");
    self.$attr_reader("maxwidth");
    self.$attr_reader("newline");
    self.$attr_reader("genspace");
    self.$attr_reader("indent");
    self.$attr_reader("group_queue");
    
    $def(self, '$current_group', function $$current_group() {
      var self = this;

      return self.group_stack.$last()
    }, 0);
    
    $def(self, '$break_outmost_groups', function $$break_outmost_groups() {
      var $a, $b, self = this, group = nil, data = nil, $ret_or_1 = nil, text = nil;

      while ($truthy($rb_lt(self.maxwidth, $rb_plus(self.output_width, self.buffer_width)))) {
        
        if (!$truthy((group = self.group_queue.$deq()))) {
          return nil
        };
        while (!($truthy(group.$breakables()['$empty?']()))) {
          
          data = self.buffer.$shift();
          self.output_width = data.$output(self.output, self.output_width);
          self.buffer_width = $rb_minus(self.buffer_width, data.$width());
        };
        while ($truthy(($truthy(($ret_or_1 = self.buffer['$empty?']()['$!']())) ? ($$('Text')['$==='](self.buffer.$first())) : ($ret_or_1)))) {
          
          text = self.buffer.$shift();
          self.output_width = text.$output(self.output, self.output_width);
          self.buffer_width = $rb_minus(self.buffer_width, text.$width());
        };
      }
    }, 0);
    
    $def(self, '$text', function $$text(obj, width) {
      var self = this, text = nil;

      
      
      if (width == null) width = obj.$length();;
      if ($truthy(self.buffer['$empty?']())) {
        
        self.output['$<<'](obj);
        return (self.output_width = $rb_plus(self.output_width, width));
      } else {
        
        text = self.buffer.$last();
        if (!$eqeqeq($$('Text'), text)) {
          
          text = $$('Text').$new();
          self.buffer['$<<'](text);
        };
        text.$add(obj, width);
        self.buffer_width = $rb_plus(self.buffer_width, width);
        return self.$break_outmost_groups();
      };
    }, -2);
    
    $def(self, '$fill_breakable', function $$fill_breakable(sep, width) {
      var self = this;

      
      
      if (sep == null) sep = " ";;
      
      if (width == null) width = sep.$length();;
      return $send(self, 'group', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        return self.$breakable(sep, width)}, {$$arity: 0, $$s: self});
    }, -1);
    
    $def(self, '$breakable', function $$breakable(sep, width) {
      var self = this, group = nil;

      
      
      if (sep == null) sep = " ";;
      
      if (width == null) width = sep.$length();;
      group = self.group_stack.$last();
      if ($truthy(group['$break?']())) {
        
        self.$flush();
        self.output['$<<'](self.newline);
        self.output['$<<'](self.genspace.$call(self.indent));
        self.output_width = self.indent;
        return (self.buffer_width = 0);
      } else {
        
        self.buffer['$<<']($$('Breakable').$new(sep, width, self));
        self.buffer_width = $rb_plus(self.buffer_width, width);
        return self.$break_outmost_groups();
      };
    }, -1);
    
    $def(self, '$group', function $$group(indent, open_obj, close_obj, open_width, close_width) {
      var $yield = $$group.$$p || nil, self = this;

      delete $$group.$$p;
      
      
      if (indent == null) indent = 0;;
      
      if (open_obj == null) open_obj = "";;
      
      if (close_obj == null) close_obj = "";;
      
      if (open_width == null) open_width = open_obj.$length();;
      
      if (close_width == null) close_width = close_obj.$length();;
      self.$text(open_obj, open_width);
      $send(self, 'group_sub', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

        return $send(self, 'nest', [indent], function $$5(){
          return Opal.yieldX($yield, []);}, 0)}, {$$arity: 0, $$s: self});
      return self.$text(close_obj, close_width);
    }, -1);
    
    $def(self, '$group_sub', function $$group_sub() {
      var $yield = $$group_sub.$$p || nil, self = this, group = nil;

      delete $$group_sub.$$p;
      
      group = $$('Group').$new($rb_plus(self.group_stack.$last().$depth(), 1));
      self.group_stack.$push(group);
      self.group_queue.$enq(group);
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        (self.group_stack.$pop(), ($truthy(group.$breakables()['$empty?']()) ? (self.group_queue.$delete(group)) : nil))
      }; })();;
    }, 0);
    
    $def(self, '$nest', function $$nest(indent) {
      var $yield = $$nest.$$p || nil, self = this;

      delete $$nest.$$p;
      
      self.indent = $rb_plus(self.indent, indent);
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        (self.indent = $rb_minus(self.indent, indent))
      }; })();;
    }, 1);
    
    $def(self, '$flush', function $$flush() {
      var self = this;

      
      $send(self.buffer, 'each', [], function $$6(data){var self = $$6.$$s == null ? this : $$6.$$s;
        if (self.output == null) self.output = nil;
        if (self.output_width == null) self.output_width = nil;

        
        
        if (data == null) data = nil;;
        return (self.output_width = data.$output(self.output, self.output_width));}, {$$arity: 1, $$s: self});
      self.buffer.$clear();
      return (self.buffer_width = 0);
    }, 0);
    (function($base, $super) {
      var self = $klass($base, $super, 'Text');

      var $proto = self.$$prototype;

      $proto.objs = $proto.width = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.objs = [];
        return (self.width = 0);
      }, 0);
      self.$attr_reader("width");
      
      $def(self, '$output', function $$output(out, output_width) {
        var self = this;

        
        $send(self.objs, 'each', [], function $$7(obj){
          
          
          if (obj == null) obj = nil;;
          return out['$<<'](obj);}, 1);
        return $rb_plus(output_width, self.width);
      }, 2);
      return $def(self, '$add', function $$add(obj, width) {
        var self = this;

        
        self.objs['$<<'](obj);
        return (self.width = $rb_plus(self.width, width));
      }, 2);
    })($nesting[0], null);
    (function($base, $super) {
      var self = $klass($base, $super, 'Breakable');

      var $proto = self.$$prototype;

      $proto.group = $proto.pp = $proto.indent = $proto.obj = $proto.width = nil;
      
      
      $def(self, '$initialize', function $$initialize(sep, width, q) {
        var self = this;

        
        self.obj = sep;
        self.width = width;
        self.pp = q;
        self.indent = q.$indent();
        self.group = q.$current_group();
        return self.group.$breakables().$push(self);
      }, 3);
      self.$attr_reader("obj");
      self.$attr_reader("width");
      self.$attr_reader("indent");
      return $def(self, '$output', function $$output(out, output_width) {
        var self = this;

        
        self.group.$breakables().$shift();
        if ($truthy(self.group['$break?']())) {
          
          out['$<<'](self.pp.$newline());
          out['$<<'](self.pp.$genspace().$call(self.indent));
          return self.indent;
        } else {
          
          if ($truthy(self.group.$breakables()['$empty?']())) {
            self.pp.$group_queue().$delete(self.group)
          };
          out['$<<'](self.obj);
          return $rb_plus(output_width, self.width);
        };
      }, 2);
    })($nesting[0], null);
    (function($base, $super) {
      var self = $klass($base, $super, 'Group');

      
      
      
      $def(self, '$initialize', function $$initialize(depth) {
        var self = this;

        
        self.depth = depth;
        self.breakables = [];
        return (self["break"] = false);
      }, 1);
      self.$attr_reader("depth");
      self.$attr_reader("breakables");
      
      $def(self, '$break', $assign_ivar_val("break", true), 0);
      
      $def(self, '$break?', $return_ivar("break"), 0);
      return $def(self, '$first?', function $Group_first$ques$8() {
        var $a, self = this;

        if ($truthy((($a = self['first'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
          return false
        } else {
          
          self.first = false;
          return true;
        }
      }, 0);
    })($nesting[0], null);
    (function($base, $super) {
      var self = $klass($base, $super, 'GroupQueue');

      var $proto = self.$$prototype;

      $proto.queue = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, groups, self = this;

        
        
        $post_args = Opal.slice.call(arguments);
        
        groups = $post_args;;
        self.queue = [];
        return $send(groups, 'each', [], function $$9(g){var self = $$9.$$s == null ? this : $$9.$$s;

          
          
          if (g == null) g = nil;;
          return self.$enq(g);}, {$$arity: 1, $$s: self});
      }, -1);
      
      $def(self, '$enq', function $$enq(group) {
        var $a, self = this, depth = nil;

        
        depth = group.$depth();
        while (!($truthy($rb_lt(depth, self.queue.$length())))) {
          self.queue['$<<']([])
        };
        return self.queue['$[]'](depth)['$<<'](group);
      }, 1);
      
      $def(self, '$deq', function $$deq() {try {

        var self = this;

        
        $send(self.queue, 'each', [], function $$10(gs){
          
          
          if (gs == null) gs = nil;;
          $send($rb_minus(gs.$length(), 1), 'downto', [0], function $$11(i){var group = nil;

            
            
            if (i == null) i = nil;;
            if ($truthy(gs['$[]'](i).$breakables()['$empty?']())) {
              return nil
            } else {
              
              group = gs['$slice!'](i, 1).$first();
              group.$break();
              Opal.ret(group);
            };}, 1);
          $send(gs, 'each', [], function $$12(group){
            
            
            if (group == null) group = nil;;
            return group.$break();}, 1);
          return gs.$clear();}, 1);
        return nil;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, 0);
      return $def(self, '$delete', function $GroupQueue_delete$13(group) {
        var self = this;

        return self.queue['$[]'](group.$depth()).$delete(group)
      }, 1);
    })($nesting[0], null);
    return (function($base, $super) {
      var self = $klass($base, $super, 'SingleLine');

      var $proto = self.$$prototype;

      $proto.output = $proto.first = nil;
      
      
      $def(self, '$initialize', function $$initialize(output, maxwidth, newline) {
        var self = this;

        
        
        if (maxwidth == null) maxwidth = nil;;
        
        if (newline == null) newline = nil;;
        self.output = output;
        return (self.first = [true]);
      }, -2);
      
      $def(self, '$text', function $$text(obj, width) {
        var self = this;

        
        
        if (width == null) width = nil;;
        return self.output['$<<'](obj);
      }, -2);
      
      $def(self, '$breakable', function $$breakable(sep, width) {
        var self = this;

        
        
        if (sep == null) sep = " ";;
        
        if (width == null) width = nil;;
        return self.output['$<<'](sep);
      }, -1);
      
      $def(self, '$nest', function $$nest(indent) {
        var $yield = $$nest.$$p || nil;

        delete $$nest.$$p;
        return Opal.yieldX($yield, []);
      }, 1);
      
      $def(self, '$group', function $$group(indent, open_obj, close_obj, open_width, close_width) {
        var $yield = $$group.$$p || nil, self = this;

        delete $$group.$$p;
        
        
        if (indent == null) indent = nil;;
        
        if (open_obj == null) open_obj = "";;
        
        if (close_obj == null) close_obj = "";;
        
        if (open_width == null) open_width = nil;;
        
        if (close_width == null) close_width = nil;;
        self.first.$push(true);
        self.output['$<<'](open_obj);
        Opal.yieldX($yield, []);
        self.output['$<<'](close_obj);
        return self.first.$pop();
      }, -1);
      
      $def(self, '$flush', $return_val(nil), 0);
      return $def(self, '$first?', function $SingleLine_first$ques$14() {
        var self = this, result = nil;

        
        result = self.first['$[]'](-1);
        self.first['$[]='](-1, false);
        return result;
      }, 0);
    })($nesting[0], null);
  })($nesting[0], null, $nesting)
};

Opal.modules["pp"] = function(Opal) {/* Generated by Opal 1.5.1 */
  var self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, $klass = Opal.klass, $gvars = Opal.gvars, $send = Opal.send, $defs = Opal.defs, $to_a = Opal.to_a, $module = Opal.module, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $def = Opal.def, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $eqeqeq = Opal.eqeqeq, $neqeq = Opal.neqeq, $not = Opal.not, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le;

  Opal.add_stubs('require,new,guard_inspect_key,pp,flush,<<,bind_call,instance_method,to_proc,attr_accessor,==,[],current,[]=,compare_by_identity,include?,delete,text,is_a?,__getobj__,check_inspect_key,group,pretty_print_cycle,push_inspect_key,pretty_print,sharing_detection,pop_inspect_key,+,name,class,chomp,breakable,lambda,comma_breakable,__send__,call,object_address_group,seplist,pretty_print_instance_variables,===,to_s,instance_eval,include,!=,owner,inspect,respond_to?,!,pp_object,sort,instance_variables,raise,singleline_pp,dup,empty?,pp_hash,each,keys,sprintf,mcall,begin,exclude_end?,end,lines,>,size,named_captures,regexp,object_group,class_eval,string,<=,first,module_function');
  
  self.$require("thread");
  self.$require("stringio");
  self.$require("prettyprint");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'PP');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs($$('PP'), '$pp', function $$pp(obj, out, width) {
      var q = nil;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      if (out == null) out = $gvars.stdout;;
      
      if (width == null) width = 79;;
      q = $$('PP').$new(out, width);
      $send(q, 'guard_inspect_key', [], function $$1(){
        return q.$pp(obj)}, 0);
      q.$flush();
      return out['$<<']("\n");
    }, -2);
    $defs($$('PP'), '$singleline_pp', function $$singleline_pp(obj, out) {
      var q = nil;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      if (out == null) out = $gvars.stdout;;
      q = $$('SingleLine').$new(out);
      $send(q, 'guard_inspect_key', [], function $$2(){
        return q.$pp(obj)}, 0);
      q.$flush();
      return out;
    }, -2);
    $defs($$('PP'), '$mcall', function $$mcall(obj, mod, meth, $a) {
      var block = $$mcall.$$p || nil, $post_args, args;

      delete $$mcall.$$p;
      
      ;
      
      $post_args = Opal.slice.call(arguments, 3);
      
      args = $post_args;;
      return $send(mod.$instance_method(meth), 'bind_call', [obj].concat($to_a(args)), block.$to_proc());
    }, -4);
    self.sharing_detection = false;
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("sharing_detection")
    })(Opal.get_singleton_class(self), $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'PPMethods');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$guard_inspect_key', function $$guard_inspect_key() {
        var $a, $yield = $$guard_inspect_key.$$p || nil, save = nil;

        delete $$guard_inspect_key.$$p;
        
        if ($eqeq($$('Thread').$current()['$[]']("__recursive_key__"), nil)) {
          $$('Thread').$current()['$[]=']("__recursive_key__", $hash2([], {}).$compare_by_identity())
        };
        if ($eqeq($$('Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect"), nil)) {
          $$('Thread').$current()['$[]']("__recursive_key__")['$[]=']("inspect", $hash2([], {}).$compare_by_identity())
        };
        save = $$('Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect");
        
        return (function() { try {
        
        $$('Thread').$current()['$[]']("__recursive_key__")['$[]=']("inspect", $hash2([], {}).$compare_by_identity());
        return Opal.yieldX($yield, []);;
        } finally {
          ($a = ["inspect", save], $send($$('Thread').$current()['$[]']("__recursive_key__"), '[]=', $a), $a[$a.length - 1])
        }; })();;
      }, 0);
      
      $def(self, '$check_inspect_key', function $$check_inspect_key(id) {
        var $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Thread').$current()['$[]']("__recursive_key__"))) ? ($$('Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect")) : ($ret_or_2))))) {
          return $$('Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect")['$include?'](id)
        } else {
          return $ret_or_1
        }
      }, 1);
      
      $def(self, '$push_inspect_key', function $$push_inspect_key(id) {
        var $a;

        return ($a = [id, true], $send($$('Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect"), '[]=', $a), $a[$a.length - 1])
      }, 1);
      
      $def(self, '$pop_inspect_key', function $$pop_inspect_key(id) {
        
        return $$('Thread').$current()['$[]']("__recursive_key__")['$[]']("inspect").$delete(id)
      }, 1);
      
      $def(self, '$pp', function $$pp(obj) {try {

        var $a, self = this;

        
        ;
        
        if (obj === null) {
          self.$text("null")
          Opal.ret(nil)
        }
        else if (obj === undefined) {
          self.$text("undefined")
          Opal.ret(nil)
        }
        else if (obj.$$class === undefined) {
          self.$text(Object.prototype.toString.apply(obj))
          Opal.ret(nil)
        }
      ;
        if (($truthy((($a = $$$('::', 'Delegator', 'skip_raise')) ? 'constant' : nil)) && ($truthy(obj['$is_a?']($$$('Delegator')))))) {
          obj = obj.$__getobj__()
        };
        if ($truthy(self.$check_inspect_key(obj))) {
          
          $send(self, 'group', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

            return obj.$pretty_print_cycle(self)}, {$$arity: 0, $$s: self});
          return nil;
        };
        
        return (function() { try {
        
        self.$push_inspect_key(obj);
        return $send(self, 'group', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          return obj.$pretty_print(self)}, {$$arity: 0, $$s: self});
        } finally {
          ($truthy($$('PP').$sharing_detection()) ? (nil) : (self.$pop_inspect_key(obj)))
        }; })();;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, -1);
      
      $def(self, '$object_group', function $$object_group(obj) {
        var block = $$object_group.$$p || nil, self = this;

        delete $$object_group.$$p;
        
        ;
        return $send(self, 'group', [1, $rb_plus("#<", obj.$class().$name()), ">"], block.$to_proc());
      }, 1);
      
      $def(self, '$object_address_group', function $$object_address_group(obj) {
        var block = $$object_address_group.$$p || nil, self = this, str = nil;

        delete $$object_address_group.$$p;
        
        ;
        str = $$('Kernel').$instance_method("to_s").$bind_call(obj);
        str = str.$chomp(">");
        return $send(self, 'group', [1, str, ">"], block.$to_proc());
      }, 1);
      
      $def(self, '$comma_breakable', function $$comma_breakable() {
        var self = this;

        
        self.$text(",");
        return self.$breakable();
      }, 0);
      
      $def(self, '$seplist', function $$seplist(list, sep, iter_method) {
        var $yield = $$seplist.$$p || nil, self = this, $ret_or_1 = nil, first = nil;

        delete $$seplist.$$p;
        
        
        if (sep == null) sep = nil;;
        
        if (iter_method == null) iter_method = "each";;
        sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : ($send(self, 'lambda', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

          return self.$comma_breakable()}, {$$arity: 0, $$s: self})));
        first = true;
        return $send(list, '__send__', [iter_method], function $$6($a){var $post_args, v;

          
          
          $post_args = Opal.slice.call(arguments);
          
          v = $post_args;;
          if ($truthy(first)) {
            first = false
          } else {
            sep.$call()
          };
          return Opal.yieldX($yield, $to_a(v));;}, -1);
      }, -2);
      
      $def(self, '$pp_object', function $$pp_object(obj) {
        var self = this;

        return $send(self, 'object_address_group', [obj], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

          return $send(self, 'seplist', [obj.$pretty_print_instance_variables(), $send(self, 'lambda', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

            return self.$text(",")}, {$$arity: 0, $$s: self})], function $$9(v){var self = $$9.$$s == null ? this : $$9.$$s;

            
            
            if (v == null) v = nil;;
            self.$breakable();
            if ($eqeqeq($$('Symbol'), v)) {
              v = v.$to_s()
            };
            self.$text(v);
            self.$text("=");
            return $send(self, 'group', [1], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

              
              self.$breakable("");
              return self.$pp(obj.$instance_eval(v));}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self})}, {$$arity: 0, $$s: self})
      }, 1);
      return $def(self, '$pp_hash', function $$pp_hash(obj) {
        var self = this;

        return $send(self, 'group', [1, "{", "}"], function $$11(){var self = $$11.$$s == null ? this : $$11.$$s;

          return $send(self, 'seplist', [obj, nil, "each_pair"], function $$12(k, v){var self = $$12.$$s == null ? this : $$12.$$s;

            
            
            if (k == null) k = nil;;
            
            if (v == null) v = nil;;
            return $send(self, 'group', [], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

              
              self.$pp(k);
              self.$text("=>");
              return $send(self, 'group', [1], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

                
                self.$breakable("");
                return self.$pp(v);}, {$$arity: 0, $$s: self});}, {$$arity: 0, $$s: self});}, {$$arity: 2, $$s: self})}, {$$arity: 0, $$s: self})
      }, 1);
    })($nesting[0], $nesting);
    self.$include($$('PPMethods'));
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SingleLine');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return self.$include($$('PPMethods'))
    })($nesting[0], $$$($$('PrettyPrint'), 'SingleLine'), $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'ObjectMixin');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$pretty_print', function $$pretty_print(q) {
        var self = this, umethod_method = nil, inspect_method = nil;

        
        umethod_method = $$('Object').$instance_method("method");
        
        try {
          inspect_method = umethod_method.$bind_call(self, "inspect")
        } catch ($err) {
          if (Opal.rescue($err, [$$('NameError')])) {
            try {
              nil
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };;
        if (($truthy(inspect_method) && ($neqeq(inspect_method.$owner(), $$('Kernel'))))) {
          return q.$text(self.$inspect())
        } else if (($not(inspect_method) && ($truthy(self['$respond_to?']("inspect"))))) {
          return q.$text(self.$inspect())
        } else {
          return q.$pp_object(self)
        };
      }, 1);
      
      $def(self, '$pretty_print_cycle', function $$pretty_print_cycle(q) {
        var self = this;

        return $send(q, 'object_address_group', [self], function $$15(){
          
          q.$breakable();
          return q.$text("...");}, 0)
      }, 1);
      
      $def(self, '$pretty_print_instance_variables', function $$pretty_print_instance_variables() {
        var self = this;

        return self.$instance_variables().$sort()
      }, 0);
      return $def(self, '$pretty_print_inspect', function $$pretty_print_inspect() {
        var self = this;

        
        if ($eqeq($$('Object').$instance_method("method").$bind_call(self, "pretty_print").$owner(), $$$($$('PP'), 'ObjectMixin'))) {
          self.$raise("pretty_print is not overridden for " + (self.$class()))
        };
        return $$('PP').$singleline_pp(self, "".$dup());
      }, 0);
    })($nesting[0], $nesting);
  })($nesting[0], $$('PrettyPrint'), $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    
    
    $def(self, '$pretty_print', function $$pretty_print(q) {
      var self = this;

      return $send(q, 'group', [1, "[", "]"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

        return $send(q, 'seplist', [self], function $$17(v){
          
          
          if (v == null) v = nil;;
          return q.$pp(v);}, 1)}, {$$arity: 0, $$s: self})
    }, 1);
    return $def(self, '$pretty_print_cycle', function $$pretty_print_cycle(q) {
      var self = this;

      return q.$text(($truthy(self['$empty?']()) ? ("[]") : ("[...]")))
    }, 1);
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    
    
    $def(self, '$pretty_print', function $$pretty_print(q) {
      var self = this;

      return q.$pp_hash(self)
    }, 1);
    return $def(self, '$pretty_print_cycle', function $$pretty_print_cycle(q) {
      var self = this;

      return q.$text(($truthy(self['$empty?']()) ? ("{}") : ("{...}")))
    }, 1);
  })($nesting[0], null);
  (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$pretty_print', function $$pretty_print(q) {
      var h = nil;

      
      h = $hash2([], {});
      $send($$('ENV').$keys().$sort(), 'each', [], function $$18(k){var $a;

        
        
        if (k == null) k = nil;;
        return ($a = [k, $$('ENV')['$[]'](k)], $send(h, '[]=', $a), $a[$a.length - 1]);}, 1);
      return q.$pp_hash(h);
    }, 1)
  })(Opal.get_singleton_class($$('ENV')), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$pretty_print', function $$pretty_print(q) {
      var self = this;

      return $send(q, 'group', [1, self.$sprintf("#<struct %s", $$('PP').$mcall(self, $$('Kernel'), "class").$name()), ">"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

        return $send(q, 'seplist', [$$('PP').$mcall(self, $$('Struct'), "members"), $send(self, 'lambda', [], function $$20(){
          return q.$text(",")}, 0)], function $$21(member){var self = $$21.$$s == null ? this : $$21.$$s;

          
          
          if (member == null) member = nil;;
          q.$breakable();
          q.$text(member.$to_s());
          q.$text("=");
          return $send(q, 'group', [1], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

            
            q.$breakable("");
            return q.$pp(self['$[]'](member));}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self})}, {$$arity: 0, $$s: self})
    }, 1);
    return $def(self, '$pretty_print_cycle', function $$pretty_print_cycle(q) {
      var self = this;

      return q.$text(self.$sprintf("#<struct %s:...>", $$('PP').$mcall(self, $$('Kernel'), "class").$name()))
    }, 1);
  })($nesting[0], null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Range');

    
    return $def(self, '$pretty_print', function $$pretty_print(q) {
      var self = this;

      
      q.$pp(self.$begin());
      q.$breakable("");
      q.$text(($truthy(self['$exclude_end?']()) ? ("...") : ("..")));
      q.$breakable("");
      if ($truthy(self.$end())) {
        return q.$pp(self.$end())
      } else {
        return nil
      };
    }, 1)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$pretty_print', function $$pretty_print(q) {
      var self = this, lines = nil;

      
      lines = self.$lines();
      if ($truthy($rb_gt(lines.$size(), 1))) {
        return $send(q, 'group', [0, "", ""], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return $send(q, 'seplist', [lines, $send(self, 'lambda', [], function $$24(){
            
            q.$text(" +");
            return q.$breakable();}, 0)], function $$25(v){
            
            
            if (v == null) v = nil;;
            return q.$pp(v);}, 1)}, {$$arity: 0, $$s: self})
      } else {
        return q.$text(self.$inspect())
      };
    }, 1)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    
    return $def(self, '$pretty_print', function $$pretty_print(q) {
      var self = this, nc = nil;

      
      nc = [];
      $send(self.$regexp().$named_captures(), 'each', [], function $$26(name, indexes){
        
        
        if (name == null) name = nil;;
        
        if (indexes == null) indexes = nil;;
        return $send(indexes, 'each', [], function $$27(i){var $a;

          
          
          if (i == null) i = nil;;
          return ($a = [i, name], $send(nc, '[]=', $a), $a[$a.length - 1]);}, 1);}, 2);
      return $send(q, 'object_group', [self], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

        
        q.$breakable();
        return $send(q, 'seplist', [Opal.Range.$new(0,self.$size(), true), $send(self, 'lambda', [], function $$29(){
          return q.$breakable()}, 0)], function $$30(i){var self = $$30.$$s == null ? this : $$30.$$s;

          
          
          if (i == null) i = nil;;
          if ($eqeq(i, 0)) {
            return q.$pp(self['$[]'](i))
          } else {
            
            if ($truthy(nc['$[]'](i))) {
              q.$text(nc['$[]'](i))
            } else {
              q.$pp(i)
            };
            q.$text(":");
            return q.$pp(self['$[]'](i));
          };}, {$$arity: 1, $$s: self});}, {$$arity: 0, $$s: self});
    }, 1)
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return self.$include($$$($$('PP'), 'ObjectMixin'))
  })($nesting[0], $$('BasicObject'), $nesting);
  $send([$$('Numeric'), $$('Symbol'), $$('FalseClass'), $$('TrueClass'), $$('NilClass'), $$('Module')], 'each', [], function $$31(c){var self = $$31.$$s == null ? this : $$31.$$s;

    
    
    if (c == null) c = nil;;
    return $send(c, 'class_eval', [], function $$32(){var self = $$32.$$s == null ? this : $$32.$$s;

      return $def(self, '$pretty_print_cycle', function $$pretty_print_cycle(q) {
        var self = this;

        return q.$text(self.$inspect())
      }, 1)}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
  $send([$$('Numeric'), $$('FalseClass'), $$('TrueClass'), $$('Module')], 'each', [], function $$33(c){var self = $$33.$$s == null ? this : $$33.$$s;

    
    
    if (c == null) c = nil;;
    return $send(c, 'class_eval', [], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

      return $def(self, '$pretty_print', function $$pretty_print(q) {
        var self = this;

        return q.$text(self.$inspect())
      }, 1)}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$pretty_inspect', function $$pretty_inspect() {
      var self = this;

      return $$('PP').$pp(self, $$('StringIO').$new()).$string()
    }, 0);
    
    $def(self, '$pp', function $$pp($a) {
      var $post_args, objs;

      
      
      $post_args = Opal.slice.call(arguments);
      
      objs = $post_args;;
      $send(objs, 'each', [], function $$35(obj){
        
        
        if (obj == null) obj = nil;;
        return $$('PP').$pp(obj);}, 1);
      if ($truthy($rb_le(objs.$size(), 1))) {
        return objs.$first()
      } else {
        return objs
      };
    }, -1);
    return self.$module_function("pp");
  })($nesting[0], $nesting);
};
