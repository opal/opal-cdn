Opal.modules.promise=function(Opal){var $klass=Opal.klass,$defs=Opal.defs,$slice=Opal.slice,$def=Opal.def,$eqeqeq=Opal.eqeqeq,$truthy=Opal.truthy,$return_ivar=Opal.return_ivar,$not=Opal.not,$send=Opal.send,$to_a=Opal.to_a,$rb_plus=Opal.rb_plus,$alias=Opal.alias,$send2=Opal.send2,$find_super=Opal.find_super,$rb_le=Opal.rb_le,$rb_minus=Opal.rb_minus,$const_set=Opal.const_set,$nesting=[],$$=Opal.$r($nesting),nil=Opal.nil;return Opal.add_stubs("resolve,new,reject,attr_reader,===,value,key?,keys,!=,==,<<,>>,exception?,[],resolved?,rejected?,!,error,include?,action,realized?,raise,^,call,resolve!,exception!,any?,each,reject!,there_can_be_only_one!,then,to_proc,fail,always,trace,class,object_id,+,inspect,rescue,to_v2,fail!,then!,always!,itself,nil?,prev,act?,push,concat,it,proc,reverse,pop,<=,length,shift,-,wait,map,reduce,try,tap,all?,find,collect,inject"),function($base,$super,$parent_nesting){var self=$klass($base,null,"Promise"),$nesting=[self].concat($parent_nesting),$$=Opal.$r($nesting),$proto=self.$$prototype;$proto.value=$proto.action=$proto.realized=$proto.next=$proto.delayed=$proto.error=$proto.prev=nil,$defs(self,"$value",(function(value){return this.$new().$resolve(value)})),$defs(self,"$error",(function(value){return this.$new().$reject(value)})),$defs(self,"$when",(function($a){var promises;return promises=$slice(arguments),$$("When").$new(promises)}),-1),self.$attr_reader("error","prev","next"),$def(self,"$initialize",(function(action){return null==action&&(action=new Map),this.action=action,this.realized=!1,this.exception=!1,this.value=nil,this.error=nil,this.delayed=!1,this.prev=nil,this.next=[]}),-1),$def(self,"$value",(function(){return $eqeqeq($$("Promise"),this.value)?this.value.$value():this.value})),$def(self,"$act?",(function(){var $ret_or_1;return $truthy($ret_or_1=this.action["$key?"]("success"))?$ret_or_1:this.action["$key?"]("always")})),$def(self,"$action",(function(){return this.action.$keys()})),$def(self,"$exception?",$return_ivar("exception")),$def(self,"$realized?",(function(){return this.realized["$!="](!1)})),$def(self,"$resolved?",(function(){return this.realized["$=="]("resolve")})),$def(self,"$rejected?",(function(){return this.realized["$=="]("reject")})),$def(self,"$^",(function(promise){return promise["$<<"](this),this["$>>"](promise),promise})),$def(self,"$<<",(function(promise){return this.prev=promise,this})),$def(self,"$>>",(function(promise){return this.next["$<<"](promise),$truthy(this["$exception?"]())?promise.$reject(this.delayed["$[]"](0)):$truthy(this["$resolved?"]())?promise.$resolve($truthy(this.delayed)?this.delayed["$[]"](0):this.$value()):$truthy(this["$rejected?"]())&&($not(this.action["$key?"]("failure"))||$eqeqeq($$("Promise"),$truthy(this.delayed)?this.delayed["$[]"](0):this.error)||$truthy(promise.$action()["$include?"]("always")))&&promise.$reject($truthy(this.delayed)?this.delayed["$[]"](0):this.$error()),this})),$def(self,"$resolve",(function(value){var block=nil,$ret_or_1=nil,e=nil;if(null==value&&(value=nil),$truthy(this["$realized?"]())&&this.$raise($$("ArgumentError"),"the promise has already been realized"),$eqeqeq($$("Promise"),value))return value["$<<"](this.prev)["$^"](this);try{block=$truthy($ret_or_1=this.action["$[]"]("success"))?$ret_or_1:this.action["$[]"]("always"),$truthy(block)&&(value=block.$call(value)),this["$resolve!"](value)}catch($err){if(!Opal.rescue($err,[$$("Exception")]))throw $err;e=$err;try{this["$exception!"](e)}finally{Opal.pop_exception($err)}}return this}),-1),$def(self,"$resolve!",(function(value){return this.realized="resolve",this.value=value,$truthy(this.next["$any?"]())?$send(this.next,"each",[],(function(p){return null==p&&(p=nil),p.$resolve(value)})):this.delayed=[value]})),$def(self,"$reject",(function(value){var block=nil,$ret_or_1=nil,e=nil;if(null==value&&(value=nil),$truthy(this["$realized?"]())&&this.$raise($$("ArgumentError"),"the promise has already been realized"),$eqeqeq($$("Promise"),value))return value["$<<"](this.prev)["$^"](this);try{block=$truthy($ret_or_1=this.action["$[]"]("failure"))?$ret_or_1:this.action["$[]"]("always"),$truthy(block)&&(value=block.$call(value)),$truthy(this.action["$key?"]("always"))?this["$resolve!"](value):this["$reject!"](value)}catch($err){if(!Opal.rescue($err,[$$("Exception")]))throw $err;e=$err;try{this["$exception!"](e)}finally{Opal.pop_exception($err)}}return this}),-1),$def(self,"$reject!",(function(value){return this.realized="reject",this.error=value,$truthy(this.next["$any?"]())?$send(this.next,"each",[],(function(p){return null==p&&(p=nil),p.$reject(value)})):this.delayed=[value]})),$def(self,"$exception!",(function(error){return this.exception=!0,this["$reject!"](error)})),$def(self,"$then",(function $$then(){var block=$$then.$$p||nil;return $$then.$$p=null,this["$^"]($$("Promise").$new(new Map([["success",block]])))})),$def(self,"$then!",(function $Promise_then$excl$13(){var block=$Promise_then$excl$13.$$p||nil;return $Promise_then$excl$13.$$p=null,this["$there_can_be_only_one!"](),$send(this,"then",[],block.$to_proc())})),$def(self,"$fail",(function $$fail(){var block=$$fail.$$p||nil;return $$fail.$$p=null,this["$^"]($$("Promise").$new(new Map([["failure",block]])))})),$def(self,"$fail!",(function $Promise_fail$excl$14(){var block=$Promise_fail$excl$14.$$p||nil;return $Promise_fail$excl$14.$$p=null,this["$there_can_be_only_one!"](),$send(this,"fail",[],block.$to_proc())})),$def(self,"$always",(function $$always(){var block=$$always.$$p||nil;return $$always.$$p=null,this["$^"]($$("Promise").$new(new Map([["always",block]])))})),$def(self,"$always!",(function $Promise_always$excl$15(){var block=$Promise_always$excl$15.$$p||nil;return $Promise_always$excl$15.$$p=null,this["$there_can_be_only_one!"](),$send(this,"always",[],block.$to_proc())})),$def(self,"$trace",(function $$trace(depth){var block=$$trace.$$p||nil;return $$trace.$$p=null,null==depth&&(depth=nil),this["$^"]($$("Trace").$new(depth,block))}),-1),$def(self,"$trace!",(function $Promise_trace$excl$16($a){var args,block=$Promise_trace$excl$16.$$p||nil,self=this;return $Promise_trace$excl$16.$$p=null,args=$slice(arguments),self["$there_can_be_only_one!"](),$send(self,"trace",$to_a(args),block.$to_proc())}),-1),$def(self,"$there_can_be_only_one!",(function(){return $truthy(this.next["$any?"]())?this.$raise($$("ArgumentError"),"a promise has already been chained"):nil})),$def(self,"$inspect",(function(){var result=nil,$ret_or_1=nil;return result="#<"+this.$class()+"("+this.$object_id()+")",$truthy(this.next["$any?"]())&&(result=$rb_plus(result," >> "+this.next.$inspect())),result=$rb_plus(result,$truthy(this["$realized?"]())?": "+($truthy($ret_or_1=this.value)?$ret_or_1:this.error).$inspect()+">":">")})),$def(self,"$to_v2",(function(){var v2=nil;return v2=$$("PromiseV2").$new(),$send($send(this,"then",[],(function(i){return null==i&&(i=nil),v2.$resolve(i)})),"rescue",[],(function(i){return null==i&&(i=nil),v2.$reject(i)})),v2})),$alias(self,"await","to_v2"),$alias(self,"catch","fail"),$alias(self,"catch!","fail!"),$alias(self,"do","then"),$alias(self,"do!","then!"),$alias(self,"ensure","always"),$alias(self,"ensure!","always!"),$alias(self,"finally","always"),$alias(self,"finally!","always!"),$alias(self,"rescue","fail"),$alias(self,"rescue!","fail!"),$alias(self,"to_n","to_v2"),$alias(self,"to_v1","itself"),function($base,$super,$parent_nesting){var self=$klass($base,$super,"Trace"),$nesting=[self].concat($parent_nesting),$$=Opal.$r($nesting);$defs(self,"$it",(function(promise){var prev,current=nil;return current=[],($truthy(promise["$act?"]())||$truthy(promise.$prev()["$nil?"]()))&&current.$push(promise.$value()),prev=promise.$prev(),$truthy(prev)?current.$concat(this.$it(prev)):current})),$def(self,"$initialize",(function $$initialize(depth,block){return $$initialize.$$p=null,this.depth=depth,$send2(this,$find_super(this,"initialize",$$initialize,!1,!0),"initialize",[new Map([["success",$send(this,"proc",[],(function $$20(){var self=null==$$20.$$s?this:$$20.$$s,trace=nil;return(trace=$$("Trace").$it(self).$reverse()).$pop(),$truthy(depth)&&$truthy($rb_le(depth,trace.$length()))&&trace.$shift($rb_minus(trace.$length(),depth)),$send(block,"call",$to_a(trace))}),{$$s:this})]])],null)}))}($nesting[0],self,$nesting),function($base,$super,$parent_nesting){var self=$klass($base,$super,"When"),$nesting=[self].concat($parent_nesting),$$=Opal.$r($nesting);self.$$prototype.wait=nil,$def(self,"$initialize",(function $$initialize(promises){return $$initialize.$$p=null,null==promises&&(promises=[]),$send2(this,$find_super(this,"initialize",$$initialize,!1,!0),"initialize",[],null),this.wait=[],$send(promises,"each",[],(function $$21(promise){return null==promise&&(promise=nil),(null==$$21.$$s?this:$$21.$$s).$wait(promise)}),{$$s:this})}),-1),$def(self,"$each",(function $$each(){var block=$$each.$$p||nil;return $$each.$$p=null,$truthy(block)||this.$raise($$("ArgumentError"),"no block given"),$send(this,"then",[],(function(values){return null==values&&(values=nil),$send(values,"each",[],block.$to_proc())}))})),$def(self,"$collect",(function $$collect(){var block=$$collect.$$p||nil;return $$collect.$$p=null,$truthy(block)||this.$raise($$("ArgumentError"),"no block given"),$send(this,"then",[],(function(values){return null==values&&(values=nil),$$("When").$new($send(values,"map",[],block.$to_proc()))}))})),$def(self,"$inject",(function $$inject($a){var $post_args,args,block=$$inject.$$p||nil,self=this;return $$inject.$$p=null,$post_args=$slice(arguments),args=$post_args,$send(self,"then",[],(function(values){return null==values&&(values=nil),$send(values,"reduce",$to_a(args),block.$to_proc())}))}),-1),$def(self,"$wait",(function(promise){return $eqeqeq($$("Promise"),promise)||(promise=$$("Promise").$value(promise)),$truthy(promise["$act?"]())&&(promise=promise.$then()),this.wait["$<<"](promise),$send(promise,"always",[],(function $$25(){var self=null==$$25.$$s?this:$$25.$$s;return null==self.next&&(self.next=nil),$truthy(self.next["$any?"]())?self.$try():nil}),{$$s:this}),this})),$def(self,"$>>",(function $When_$gt$gt$26($a){var $fwd_rest,$yield=$When_$gt$gt$26.$$p||nil,self=this;return $When_$gt$gt$26.$$p=null,$fwd_rest=$slice(arguments),$send($send2(self,$find_super(self,">>",$When_$gt$gt$26,!1,!0),">>",$to_a($fwd_rest),$yield),"tap",[],(function $$27(){return(null==$$27.$$s?this:$$27.$$s).$try()}),{$$s:self})}),-1),$def(self,"$try",(function(){var promise=nil;return $truthy($send(this.wait,"all?",[],"realized?".$to_proc()))?(promise=$send(this.wait,"find",[],"rejected?".$to_proc()),$truthy(promise)?this.$reject(promise.$error()):this.$resolve($send(this.wait,"map",[],"value".$to_proc()))):nil})),$alias(self,"map","collect"),$alias(self,"reduce","inject"),$alias(self,"and","wait")}($nesting[0],self,$nesting)}($nesting[0],0,$nesting),$const_set($nesting[0],"PromiseV1",$$("Promise"))};
