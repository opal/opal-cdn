Opal.modules["corelib/marshal/read_buffer"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $module = Opal.module, $klass = Opal.klass, $neqeq = Opal.neqeq, $Kernel = Opal.Kernel, $def = Opal.def, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $rb_times = Opal.rb_times, $send = Opal.send, $to_a = Opal.to_a, $Class = Opal.Class, $Module = Opal.Module, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_s,read_byte,!=,raise,length,read_char,read_fixnum,read_float,read_bignum,read_string,read_symbol,read_cached_symbol,read_array,read_hash,read_hashdef,read_regexp,read_struct,read_class,read_module,read_object,read_cached_object,read_extended_object,read_primitive_with_ivars,read_user_class,read_user_defined,read_user_marshal,>=,[],+,==,/,to_f,<<,*,each,ord,**,to_i,symbols_cache,read,[]=,default=,new,safe_const_get,values_at,members,class,allocate,instance_variable_set,object_cache,extend,is_a?,any?,<,_load,marshal_load,const_get');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Marshal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ReadBuffer');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.buffer = $proto.index = $proto.object_cache = nil;
      
      
      function stringToBytes(string) {
        var i,
            singleByte,
            l = string.length,
            result = [];

        for (i = 0; i < l; i++) {
          singleByte = string.charCodeAt(i);
          result.push(singleByte);
        }
        return result;
      }
    ;
      self.$attr_reader("version", "buffer", "index", "object_cache", "symbols_cache");
      
      $def(self, '$initialize', function $$initialize(input) {
        var self = this, major = nil, minor = nil;

        
        self.buffer = stringToBytes(input.$to_s());
        self.index = 0;
        major = self.$read_byte();
        minor = self.$read_byte();
        if (($neqeq(major, $$('MAJOR_VERSION')) || ($neqeq(minor, $$('MINOR_VERSION'))))) {
          $Kernel.$raise($$$('TypeError'), "incompatible marshal file format (can't be read)")
        };
        self.version = "" + (major) + "." + (minor);
        self.object_cache = [];
        self.symbols_cache = [];
        return (self.ivars = []);
      });
      
      $def(self, '$length', function $$length() {
        var self = this;

        return self.buffer.$length()
      });
      
      $def(self, '$read', function $$read($kwargs) {
        var cache, self = this, code = nil;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        cache = $kwargs.$$smap["cache"];if (cache == null) cache = true;
        code = self.$read_char();
        
        switch (code) {
          case "0":
            return nil
          case "T":
            return true
          case "F":
            return false
          case "i":
            return self.$read_fixnum()
          case "f":
            return self.$read_float()
          case "l":
            return self.$read_bignum()
          case "\"":
            return self.$read_string()
          case ":":
            return self.$read_symbol()
          case ";":
            return self.$read_cached_symbol()
          case "[":
            return self.$read_array()
          case "{":
            return self.$read_hash()
          case "}":
            return self.$read_hashdef()
          case "/":
            return self.$read_regexp()
          case "S":
            return self.$read_struct()
          case "c":
            return self.$read_class()
          case "m":
            return self.$read_module()
          case "o":
            return self.$read_object()
          case "@":
            return self.$read_cached_object()
          case "e":
            return self.$read_extended_object()
          case "I":
            return self.$read_primitive_with_ivars()
          case "C":
            return self.$read_user_class()
          case "u":
            return self.$read_user_defined()
          case "U":
            return self.$read_user_marshal()
          case "M":
            return $Kernel.$raise($$$('NotImplementedError'), "ModuleOld type cannot be demarshaled yet")
          case "d":
            return $Kernel.$raise($$$('NotImplementedError'), "Data type cannot be demarshaled")
          default:
            return $Kernel.$raise($$$('ArgumentError'), "dump format error")
        };
      }, -1);
      
      $def(self, '$read_byte', function $$read_byte() {
        var self = this, result = nil;

        
        if ($truthy($rb_ge(self.index, self.$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "marshal data too short")
        };
        result = self.buffer['$[]'](self.index);
        self.index = $rb_plus(self.index, 1);
        return result;
      });
      
      $def(self, '$read_char', function $$read_char() {
        var self = this;

        return String.fromCharCode(self.$read_byte())
      });
      
      $def(self, '$read_fixnum', function $$read_fixnum() {
        var self = this;

        
        var x, i, c = (self.$read_byte() ^ 128) - 128;
        if (c === 0) {
          return 0;
        }

        if (c > 0) {
          if (4 < c && c < 128) {
            return c - 5;
          }
          x = 0;
          for (i = 0; i < c; i++) {
            x |= (self.$read_byte() << (8*i));
          }
        } else {
          if (-129 < c && c < -4) {
            return c + 5;
          }

          c = -c;
          x = -1;

          for (i = 0; i < c; i++) {
            x &= ~(0xff << (8*i));
            x |= (self.$read_byte() << (8*i));
          }
        }

        return x;
      
      });
      
      $def(self, '$read_float', function $$read_float() {
        var self = this, s = nil, result = nil;

        
        s = self.$read_string($hash2(["cache"], {"cache": false}));
        result = ($eqeq(s, "nan") ? ($rb_divide(0.0, 0)) : ($eqeq(s, "inf") ? ($rb_divide(1.0, 0)) : ($eqeq(s, "-inf") ? ($rb_divide(-1.0, 0)) : (s.$to_f()))));
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_bignum', function $$read_bignum() {
        var self = this, sign = nil, size = nil, result = nil;

        
        sign = ($eqeq(self.$read_char(), "-") ? (-1) : (1));
        size = $rb_times(self.$read_fixnum(), 2);
        result = 0;
        $send(Opal.Range.$new(0,size, true), 'each', [], function $$1(exp){var self = $$1.$$s == null ? this : $$1.$$s;

          
          if (exp == null) exp = nil;
          return (result = $rb_plus(result, $rb_times(self.$read_char().$ord(), (2)['$**']($rb_times(exp, 8)))));}, {$$s: self});
        result = $rb_times(result.$to_i(), sign);
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_string', function $$read_string($kwargs) {
        var cache, self = this, length = nil;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        cache = $kwargs.$$smap["cache"];if (cache == null) cache = true;
        length = self.$read_fixnum();
        
        var i, result = '';

        for (i = 0; i < length; i++) {
          result += self.$read_char();
        }

        if (cache) {
          self.object_cache.push(result);
        }

        return result;
      ;
      }, -1);
      
      $def(self, '$read_symbol', function $$read_symbol() {
        var self = this, length = nil;

        
        length = self.$read_fixnum();
        
        var i, result = '';

        for (i = 0; i < length; i++) {
          result += self.$read_char();
        }

        self.symbols_cache.push(result);

        return result;
      ;
      });
      
      $def(self, '$read_cached_symbol', function $$read_cached_symbol() {
        var self = this;

        return self.$symbols_cache()['$[]'](self.$read_fixnum())
      });
      
      $def(self, '$read_array', function $$read_array() {
        var self = this, result = nil, length = nil;

        
        result = [];
        self.object_cache['$<<'](result);
        length = self.$read_fixnum();
        
        if (length > 0) {
          while (result.length < length) {
            result.push(self.$read());
          }
        }

        return result;
      ;
      });
      
      $def(self, '$read_hash', function $$read_hash($kwargs) {
        var cache, $a, self = this, result = nil, length = nil;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        cache = $kwargs.$$smap["cache"];if (cache == null) cache = true;
        result = $hash2([], {});
        if ($truthy(cache)) {
          self.object_cache['$<<'](result)
        };
        length = self.$read_fixnum();
        
        if (length > 0) {
          var key, value, i;
          for (i = 0; i < length; i++) {
            key = self.$read();
            value = self.$read();
            ($a = [key, value], $send(result, '[]=', $a), $a[$a.length - 1]);
          }
        }
        return result;
      ;
      }, -1);
      
      $def(self, '$read_hashdef', function $$read_hashdef() {
        var self = this, hash = nil, default_value = nil;

        
        hash = self.$read_hash();
        default_value = self.$read();
        hash['$default='](default_value);
        return hash;
      });
      
      $def(self, '$read_regexp', function $$read_regexp() {
        var self = this, string = nil, options = nil, result = nil;

        
        string = self.$read_string($hash2(["cache"], {"cache": false}));
        options = self.$read_byte();
        result = $$$('Regexp').$new(string, options);
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_struct', function $$read_struct() {
        var self = this, klass_name = nil, klass = nil, attributes = nil, args = nil, result = nil;

        
        klass_name = self.$read($hash2(["cache"], {"cache": false}));
        klass = self.$safe_const_get(klass_name);
        attributes = self.$read_hash($hash2(["cache"], {"cache": false}));
        args = $send(attributes, 'values_at', $to_a(klass.$members()));
        result = $send(klass, 'new', $to_a(args));
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_class', function $$read_class() {
        var self = this, klass_name = nil, result = nil;

        
        klass_name = self.$read_string($hash2(["cache"], {"cache": false}));
        result = self.$safe_const_get(klass_name);
        if (!$eqeq(result.$class(), $Class)) {
          $Kernel.$raise($$$('ArgumentError'), "" + (klass_name) + " does not refer to a Class")
        };
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_module', function $$read_module() {
        var self = this, mod_name = nil, result = nil;

        
        mod_name = self.$read_string($hash2(["cache"], {"cache": false}));
        result = self.$safe_const_get(mod_name);
        if (!$eqeq(result.$class(), $Module)) {
          $Kernel.$raise($$$('ArgumentError'), "" + (mod_name) + " does not refer to a Module")
        };
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_object', function $$read_object() {
        var self = this, klass_name = nil, klass = nil, object = nil, ivars = nil;

        
        klass_name = self.$read($hash2(["cache"], {"cache": false}));
        klass = self.$safe_const_get(klass_name);
        object = klass.$allocate();
        self.object_cache['$<<'](object);
        ivars = self.$read_hash($hash2(["cache"], {"cache": false}));
        $send(ivars, 'each', [], function $$2(name, value){
          
          if (name == null) name = nil;
          if (value == null) value = nil;
          if ($eqeq(name['$[]'](0), "@")) {
            return object.$instance_variable_set(name, value)
          } else {
            return object[name] = value;
          };});
        return object;
      });
      
      $def(self, '$read_cached_object', function $$read_cached_object() {
        var self = this;

        return self.$object_cache()['$[]'](self.$read_fixnum())
      });
      
      $def(self, '$read_extended_object', function $$read_extended_object() {
        var self = this, mod = nil, object = nil;

        
        mod = self.$safe_const_get(self.$read());
        object = self.$read();
        object.$extend(mod);
        return object;
      });
      
      $def(self, '$read_primitive_with_ivars', function $$read_primitive_with_ivars() {
        var self = this, object = nil, primitive_ivars = nil;

        
        object = self.$read();
        primitive_ivars = self.$read_hash($hash2(["cache"], {"cache": false}));
        if (($truthy(primitive_ivars['$any?']()) && ($truthy(object['$is_a?']($$('String')))))) {
          object = new String(object)
        };
        $send(primitive_ivars, 'each', [], function $$3(name, value){
          
          if (name == null) name = nil;
          if (value == null) value = nil;
          if ($neqeq(name, "E")) {
            return object.$instance_variable_set(name, value)
          } else {
            return nil
          };});
        return object;
      });
      
      $def(self, '$read_user_class', function $$read_user_class() {
        var self = this, klass_name = nil, klass = nil, value = nil, result = nil;

        
        klass_name = self.$read($hash2(["cache"], {"cache": false}));
        klass = self.$safe_const_get(klass_name);
        value = self.$read($hash2(["cache"], {"cache": false}));
        result = ($truthy($rb_lt(klass, $$('Hash'))) ? (klass['$[]'](value)) : (klass.$new(value)));
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_user_defined', function $$read_user_defined() {
        var self = this, klass_name = nil, klass = nil, data = nil, result = nil;

        
        klass_name = self.$read($hash2(["cache"], {"cache": false}));
        klass = self.$safe_const_get(klass_name);
        data = self.$read_string($hash2(["cache"], {"cache": false}));
        result = klass.$_load(data);
        self.object_cache['$<<'](result);
        return result;
      });
      
      $def(self, '$read_user_marshal', function $$read_user_marshal() {
        var self = this, klass_name = nil, klass = nil, result = nil, data = nil;

        
        klass_name = self.$read($hash2(["cache"], {"cache": false}));
        klass = self.$safe_const_get(klass_name);
        result = klass.$allocate();
        self.object_cache['$<<'](result);
        data = self.$read($hash2(["cache"], {"cache": false}));
        result.$marshal_load(data);
        return result;
      });
      return $def(self, '$safe_const_get', function $$safe_const_get(const_name) {
        
        try {
          return $Object.$const_get(const_name)
        } catch ($err) {
          if (Opal.rescue($err, [$$$('NameError')])) {
            try {
              return $Kernel.$raise($$$('ArgumentError'), "undefined class/module " + (const_name))
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
      });
    })(self, null, $nesting)
  })('::', $nesting)
};

Opal.modules["corelib/marshal/write_buffer"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $send = Opal.send, $module = Opal.module, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $Class = Opal.Class, $BasicObject = Opal.BasicObject, $rb_gt = Opal.rb_gt, $rb_divide = Opal.rb_divide, $not = Opal.not, $rb_minus = Opal.rb_minus, $Object = Opal.Object, $rb_plus = Opal.rb_plus, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('append,<,>=,write_fixnum,write_bignum,save_link,write_float,write_ivars_prefix,write_extends,write_user_class,write_string,write_array,write_ivars_suffix,default_proc,raise,default,write_hash,write,write_regexp,class,name,write_module,singleton_class?,write_class,write_object,append_symbol,exclude_end?,begin,end,length,each_pair,attr_reader,new,[]=,version,index,object_id,write_object_link,respond_to?,write_usr_marshal,write_userdef,===,__marshal__,call,bind,instance_method,>,-@,<<,&,floor,/,size,each,to_s,options,equal?,!,empty?,instance_variables,instance_variable_get,reject,ancestors,singleton_class,is_a?,-,marshal_dump,+,_dump');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      
      return buffer.$append("0")
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      if ($truthy(self == true)) {
        return buffer.$append("T")
      } else {
        return buffer.$append("F")
      }
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Integer');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      if (($rb_ge(self, -1073741824) && ($rb_lt(self, 1073741824)))) {
        
        buffer.$append("i");
        return buffer.$write_fixnum(self);
      } else {
        
        buffer.$append("l");
        return buffer.$write_bignum(self);
      }
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Float');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      buffer.$save_link(self);
      buffer.$append("f");
      return buffer.$write_float(self);
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      buffer.$save_link(self);
      buffer.$write_ivars_prefix(self);
      buffer.$write_extends(self);
      buffer.$write_user_class($$$('String'), self);
      buffer.$append("\"");
      return buffer.$write_string(self);
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      buffer.$save_link(self);
      buffer.$write_ivars_prefix(self);
      buffer.$write_extends(self);
      buffer.$write_user_class($$$('Array'), self);
      buffer.$append("[");
      buffer.$write_array(self);
      return buffer.$write_ivars_suffix(self);
    })
  })('::', null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      if ($truthy(self.$default_proc())) {
        $Kernel.$raise($$$('TypeError'), "can't dump hash with default proc")
      };
      buffer.$save_link(self);
      buffer.$write_ivars_prefix(self);
      buffer.$write_extends(self);
      buffer.$write_user_class($$('Hash'), self);
      if ($truthy(self.$default())) {
        
        buffer.$append("}");
        buffer.$write_hash(self);
        buffer.$write(self.$default());
      } else {
        
        buffer.$append("{");
        buffer.$write_hash(self);
      };
      return buffer.$write_ivars_suffix(self);
    })
  })('::', null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Regexp');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      buffer.$save_link(self);
      buffer.$write_ivars_prefix(self);
      buffer.$write_extends(self);
      buffer.$write_user_class($$$('Regexp'), self);
      buffer.$append("/");
      buffer.$write_regexp(self);
      return buffer.$write_ivars_suffix(self);
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      return $Kernel.$raise($$$('TypeError'), "no _dump_data is defined for class " + (self.$class()))
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      return $Kernel.$raise($$$('TypeError'), "no _dump_data is defined for class " + (self.$class()))
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      return $Kernel.$raise($$$('TypeError'), "no _dump_data is defined for class " + (self.$class()))
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      if (!$truthy(self.$name())) {
        $Kernel.$raise($$$('TypeError'), "can't dump anonymous module")
      };
      buffer.$save_link(self);
      buffer.$append("m");
      return buffer.$write_module(self);
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Class');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      if (!$truthy(self.$name())) {
        $Kernel.$raise($$$('TypeError'), "can't dump anonymous class")
      };
      if ($truthy(self['$singleton_class?']())) {
        $Kernel.$raise($$$('TypeError'), "singleton class can't be dumped")
      };
      buffer.$save_link(self);
      buffer.$append("c");
      return buffer.$write_class(self);
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      buffer.$save_link(self);
      buffer.$write_extends(self);
      buffer.$append("o");
      return buffer.$write_object(self);
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Range');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      buffer.$save_link(self);
      buffer.$write_extends(self);
      buffer.$append("o");
      buffer.$append_symbol(self.$class().$name());
      buffer.$write_fixnum(3);
      buffer.$append_symbol("excl");
      buffer.$write(self['$exclude_end?']());
      buffer.$append_symbol("begin");
      buffer.$write(self.$begin());
      buffer.$append_symbol("end");
      return buffer.$write(self.$end());
    })
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Struct');

    
    return $def(self, '$__marshal__', function $$__marshal__(buffer) {
      var self = this;

      
      buffer.$save_link(self);
      buffer.$write_ivars_prefix(self);
      buffer.$write_extends(self);
      buffer.$append("S");
      buffer.$append_symbol(self.$class().$name());
      buffer.$write_fixnum(self.$length());
      $send(self, 'each_pair', [], function $$1(attr_name, value){
        
        if (attr_name == null) attr_name = nil;
        if (value == null) value = nil;
        buffer.$append_symbol(attr_name);
        return buffer.$write(value);});
      return buffer.$write_ivars_suffix(self);
    })
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Marshal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'WriteBuffer');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.object = $proto.cache = $proto.buffer = nil;
      
      self.$attr_reader("buffer");
      
      function binaryString(s) {
        s = new String(s);
        s.encoding = $$$($$('Encoding'), 'BINARY');
        return s;
      }
    ;
      
      $def(self, '$initialize', function $$initialize(object) {
        var self = this;

        
        self.object = object;
        self.buffer = "";
        self.cache = [];
        self["extends"] = $send($$$('Hash'), 'new', [], function $$2(h, k){var $a;

          
          if (h == null) h = nil;
          if (k == null) k = nil;
          return ($a = [k, []], $send(h, '[]=', $a), $a[$a.length - 1]);});
        return self.$append(self.$version());
      });
      
      $def(self, '$write', function $$write(object) {
        var self = this, idx = nil, $ret_or_1 = nil;

        
        if (object == null) object = self.object;
        if ($truthy((idx = self.cache.$index(object.$object_id())))) {
          self.$write_object_link(idx)
        } else if ($truthy(object['$respond_to?']("marshal_dump"))) {
          self.$write_usr_marshal(object)
        } else if ($truthy(object['$respond_to?']("_dump"))) {
          self.$write_userdef(object)
        } else if (($eqeqeq(nil, ($ret_or_1 = object)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Proc'), $ret_or_1) || (($eqeqeq($$$('Method'), $ret_or_1) || (($eqeqeq($$$('MatchData'), $ret_or_1) || (($eqeqeq($$$('Range'), $ret_or_1) || (($eqeqeq($$$('Struct'), $ret_or_1) || (($eqeqeq($$$('Array'), $ret_or_1) || (($eqeqeq($Class, $ret_or_1) || (($eqeqeq($Module, $ret_or_1) || (($eqeqeq($$$('Hash'), $ret_or_1) || ($eqeqeq($$$('Regexp'), $ret_or_1)))))))))))))))))))))))))) {
          object.$__marshal__(self)
        } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
          $$$('Integer').$instance_method("__marshal__").$bind(object).$call(self)
        } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
          $$$('Float').$instance_method("__marshal__").$bind(object).$call(self)
        } else if ($eqeqeq($$$('String'), $ret_or_1)) {
          $$$('String').$instance_method("__marshal__").$bind(object).$call(self)
        } else {
          $BasicObject.$instance_method("__marshal__").$bind(object).$call(self)
        };
        return binaryString(self.buffer);
      }, -1);
      
      $def(self, '$write_fixnum', function $$write_fixnum(n) {
        var self = this;

        
        var s;

        if (n == 0) {
          s = String.fromCharCode(n);
        } else if (n > 0 && n < 123) {
          s = String.fromCharCode(n + 5);
        } else if (n < 0 && n > -124) {
          s = String.fromCharCode(256 + n - 5);
        } else {
          s = "";
          var cnt = 0;
          for (var i = 0; i < 4; i++) {
            var b = n & 255;
            s += String.fromCharCode(b);
            n >>= 8
            cnt += 1;
            if (n === 0 || n === -1) {
              break;
            }
          }
          var l_byte;
          if (n < 0) {
            l_byte = 256 - cnt;
          } else {
            l_byte = cnt;
          }
          s = String.fromCharCode(l_byte) + s;
        }
        self.$append(s)
      
      });
      
      $def(self, '$write_bignum', function $$write_bignum(n) {
        var self = this, sign = nil, num = nil, arr = nil;

        
        sign = ($truthy($rb_gt(n, 0)) ? ("+") : ("-"));
        self.$append(sign);
        num = ($truthy($rb_gt(n, 0)) ? (n) : (n['$-@']()));
        arr = [];
        while ($truthy($rb_gt(num, 0))) {
        
          arr['$<<'](num['$&'](65535));
          num = $rb_divide(num, 65536).$floor();
        };
        self.$write_fixnum(arr.$size());
        return $send(arr, 'each', [], function $$3(x){var self = $$3.$$s == null ? this : $$3.$$s;

          
          if (x == null) x = nil;
          self.$append(String.fromCharCode(x & 0xff));
          return self.$append(String.fromCharCode($rb_divide(x, 256).$floor()));}, {$$s: self});
      });
      
      $def(self, '$write_string', function $$write_string(s) {
        var self = this;

        
        self.$write_fixnum(s.$length());
        return self.$append(s);
      });
      
      $def(self, '$append_symbol', function $$append_symbol(sym) {
        var self = this;

        
        self.$append(":");
        self.$write_fixnum(sym.$length());
        return self.$append(sym);
      });
      
      $def(self, '$write_array', function $$write_array(a) {
        var self = this;

        
        self.$write_fixnum(a.$length());
        return $send(a, 'each', [], function $$4(item){var self = $$4.$$s == null ? this : $$4.$$s;

          
          if (item == null) item = nil;
          return self.$write(item);}, {$$s: self});
      });
      
      $def(self, '$write_hash', function $$write_hash(h) {
        var self = this;

        
        self.$write_fixnum(h.$length());
        return $send(h, 'each', [], function $$5(key, value){var self = $$5.$$s == null ? this : $$5.$$s;

          
          if (key == null) key = nil;
          if (value == null) value = nil;
          self.$write(key);
          return self.$write(value);}, {$$s: self});
      });
      
      $def(self, '$write_object', function $$write_object(obj) {
        var self = this;

        
        self.$append_symbol(obj.$class().$name());
        return self.$write_ivars_suffix(obj, true);
      });
      
      $def(self, '$write_class', function $$write_class(klass) {
        var self = this;

        return self.$write_string(klass.$name())
      });
      
      $def(self, '$write_module', function $$write_module(mod) {
        var self = this;

        return self.$write_string(mod.$name())
      });
      
      $def(self, '$write_regexp', function $$write_regexp(regexp) {
        var self = this;

        
        self.$write_string(regexp.$to_s());
        return self.$append(String.fromCharCode(regexp.$options()));
      });
      
      $def(self, '$write_float', function $$write_float(f) {
        var self = this;

        if ($truthy(f['$equal?']($$$($$$('Float'), 'INFINITY')))) {
          return self.$write_string("inf")
        } else if ($truthy(f['$equal?']($$$($$$('Float'), 'INFINITY')['$-@']()))) {
          return self.$write_string("-inf")
        } else if ($truthy(f['$equal?']($$$($$$('Float'), 'NAN')))) {
          return self.$write_string("nan")
        } else {
          return self.$write_string(f.$to_s())
        }
      });
      
      $def(self, '$write_ivars_suffix', function $$write_ivars_suffix(object, force) {
        var self = this;

        
        if (force == null) force = false;
        if (($truthy(object.$instance_variables()['$empty?']()) && ($not(force)))) {
          return nil
        };
        self.$write_fixnum(object.$instance_variables().$length());
        return $send(object.$instance_variables(), 'each', [], function $$6(ivar_name){var self = $$6.$$s == null ? this : $$6.$$s;

          
          if (ivar_name == null) ivar_name = nil;
          self.$append_symbol(ivar_name);
          return self.$write(object.$instance_variable_get(ivar_name));}, {$$s: self});
      }, -2);
      
      $def(self, '$write_extends', function $$write_extends(object) {
        var self = this, singleton_mods = nil, class_mods = nil, own_mods = nil;

        
        singleton_mods = $send(object.$singleton_class().$ancestors(), 'reject', [], function $$7(mod){
          
          if (mod == null) mod = nil;
          return mod['$is_a?']($$('Class'));});
        class_mods = $send(object.$class().$ancestors(), 'reject', [], function $$8(mod){
          
          if (mod == null) mod = nil;
          return mod['$is_a?']($$('Class'));});
        own_mods = $rb_minus(singleton_mods, class_mods);
        if ($truthy(own_mods['$empty?']())) {
          return nil
        } else {
          return $send(own_mods, 'each', [], function $$9(mod){var self = $$9.$$s == null ? this : $$9.$$s;

            
            if (mod == null) mod = nil;
            self.$append("e");
            return self.$append_symbol(mod.$name());}, {$$s: self})
        };
      });
      
      $def(self, '$write_user_class', function $$write_user_class(klass, object) {
        var self = this;

        if ($truthy(object.$class()['$equal?'](klass))) {
          return nil
        } else {
          
          self.$append("C");
          return self.$append_symbol(object.$class().$name());
        }
      });
      
      $def(self, '$write_object_link', function $$write_object_link(idx) {
        var self = this;

        
        self.$append("@");
        return self.$write_fixnum(idx);
      });
      
      $def(self, '$save_link', function $$save_link(object) {
        var self = this;

        return self.cache['$<<'](object.$object_id())
      });
      
      $def(self, '$write_usr_marshal', function $$write_usr_marshal(object) {
        var self = this, value = nil, klass = nil, namespace = nil;

        
        value = object.$marshal_dump();
        klass = object.$class();
        self.$append("U");
        namespace = klass.$$base_module;
        if ($truthy(namespace['$equal?']($Object))) {
          self.$append_symbol(klass.$$name)
        } else {
          self.$append_symbol($rb_plus($rb_plus(namespace.$name(), "::"), klass.$$name))
        };
        return self.$write(value);
      });
      
      $def(self, '$write_userdef', function $$write_userdef(object) {
        var self = this, value = nil;

        
        value = object.$_dump(0);
        if (!$truthy(value['$is_a?']($$$('String')))) {
          $Kernel.$raise($$$('TypeError'), "_dump() must return string")
        };
        self.$write_ivars_prefix(value);
        self.$append("u");
        self.$append_symbol(object.$class().$name());
        return self.$write_string(value);
      });
      
      $def(self, '$write_ivars_prefix', function $$write_ivars_prefix(object) {
        var self = this;

        if ($truthy(object.$instance_variables()['$empty?']())) {
          return nil
        } else {
          return self.$append("I")
        }
      });
      
      $def(self, '$append', function $$append(s) {
        var self = this;

        return self.buffer += s
      });
      return $def(self, '$version', function $$version() {
        
        return String.fromCharCode($$('MAJOR_VERSION'), $$('MINOR_VERSION'))
      });
    })(self, null, $nesting)
  })('::', $nesting);
};

Opal.modules["corelib/marshal"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $module = Opal.module, $const_set = Opal.const_set, $def = Opal.def, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,write,new,read,load');
  
  self.$require("corelib/marshal/read_buffer");
  self.$require("corelib/marshal/write_buffer");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Marshal');

    var $nesting = [self].concat($parent_nesting);

    
    $const_set($nesting[0], 'MAJOR_VERSION', 4);
    $const_set($nesting[0], 'MINOR_VERSION', 8);
    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$dump', function $$dump(object) {
        var self = this;

        return $$$(self, 'WriteBuffer').$new(object).$write()
      });
      
      $def(self, '$load', function $$load(marshaled) {
        var self = this;

        return $$$(self, 'ReadBuffer').$new(marshaled).$read()
      });
      return $alias(self, "restore", "load");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $nesting);
};

Opal.modules["base64"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $module = Opal.module, $defs = Opal.defs, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('raise,delete');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var encode, decode;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    encode = function (input) {
      var str = String(input);
      /* eslint-disable */
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars, output = '';
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3/4);
        if (charCode > 0xFF) {
          self.$raise($$('ArgumentError'), "invalid character (failed: The string to be encoded contains characters outside of the Latin1 range.)");
        }
        block = block << 8 | charCode;
      }
      return output;
      /* eslint-enable */
    };

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    decode = function (input) {
      var str = String(input).replace(/=+$/, '');
      if (str.length % 4 == 1) {
        self.$raise($$('ArgumentError'), "invalid base64 (failed: The string to be decoded is not correctly encoded.)");
      }
      /* eslint-disable */
      for (
        // initialize result and counters
        var bc = 0, bs, buffer, idx = 0, output = '';
        // get next character
        buffer = str.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
          // and if not first of each 4 characters,
          // convert the first 8 bits to one ascii character
          bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
      /* eslint-enable */
    };
  ;
    $defs(self, '$decode64', function $$decode64(string) {
      
      return decode(string.replace(/\r?\n/g, ''));
    });
    $defs(self, '$encode64', function $$encode64(string) {
      
      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    });
    $defs(self, '$strict_decode64', function $$strict_decode64(string) {
      
      return decode(string);
    });
    $defs(self, '$strict_encode64', function $$strict_encode64(string) {
      
      return encode(string);
    });
    $defs(self, '$urlsafe_decode64', function $$urlsafe_decode64(string) {
      
      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    });
    return $defs(self, '$urlsafe_encode64', function $$urlsafe_encode64(string, $kwargs) {
      var padding, str = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      padding = $kwargs.$$smap["padding"];if (padding == null) padding = true;
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if (!$truthy(padding)) {
        str = str.$delete("=")
      };
      return str;
    }, -2);
  })($nesting[0], $nesting)
};

Opal.modules["corelib/pack_unpack/format_string_parser"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $module = Opal.module, $Kernel = Opal.Kernel, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise');
  return (function($base) {
    var self = $module($base, 'PackUnpack');

    
    
    var directives = [
      // Integer
      'C',
      'S',
      'L',
      'Q',
      'J',

      'c',
      's',
      'l',
      'q',
      'j',

      'n',
      'N',
      'v',
      'V',

      'U',
      'w',

      // Float
      'D',
      'd',
      'F',
      'f',
      'E',
      'e',
      'G',
      'g',

      // String
      'A',
      'a',
      'Z',
      'B',
      'b',
      'H',
      'h',
      'u',
      'M',
      'm',

      'P',
      'p',

      // Misc
      '@',
      'X',
      'x'
    ];

    var modifiers = [
      '!', // ignored
      '_', // ignored
      '>', // big endian
      '<'  // little endian
    ];

    self.eachDirectiveAndCount = function(format, callback) {
      var currentDirective,
          currentCount,
          currentModifiers,
          countSpecified;

      function reset() {
        currentDirective = null;
        currentCount = 0;
        currentModifiers = [];
        countSpecified = false;
      }

      reset();

      function yieldAndReset() {
        if (currentDirective == null) {
          reset();
          return;
        }

        var directiveSupportsModifiers = /[sSiIlLqQjJ]/.test(currentDirective);

        if (!directiveSupportsModifiers && currentModifiers.length > 0) {
          $Kernel.$raise($$$('ArgumentError'), "'" + (currentModifiers[0]) + "' allowed only after types sSiIlLqQjJ")
        }

        if (currentModifiers.indexOf('<') !== -1 && currentModifiers.indexOf('>') !== -1) {
          $Kernel.$raise($$$('RangeError'), "Can't use both '<' and '>'")
        }

        if (!countSpecified) {
          currentCount = 1;
        }

        if (currentModifiers.indexOf('>') !== -1) {
          currentDirective = currentDirective + '>';
        }

        callback(currentDirective, currentCount);

        reset();
      }

      for (var i = 0; i < format.length; i++) {
        var currentChar = format[i];

        if (directives.indexOf(currentChar) !== -1) {
          // Directive char always resets current state
          yieldAndReset();
          currentDirective = currentChar;
        } else if (currentDirective) {
          if (/\d/.test(currentChar)) {
            // Count can be represented as a sequence of digits
            currentCount = currentCount * 10 + parseInt(currentChar, 10);
            countSpecified = true;
          } else if (currentChar === '*' && countSpecified === false) {
            // Count can be represented by a star character
            currentCount = Infinity;
            countSpecified = true;
          } else if (modifiers.indexOf(currentChar) !== -1 && countSpecified === false) {
            // Directives can be specified only after directive and before count
            currentModifiers.push(currentChar);
          } else {
            yieldAndReset();
          }
        }
      }

      yieldAndReset();
    }
  
  })('::')
};

Opal.modules["corelib/string/unpack"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $Opal = Opal.Opal, $rb_gt = Opal.rb_gt, $def = Opal.def, $hash2 = Opal.hash2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,flatten,decode64,raise,<,delete,gsub,coerce_to!,>,length,inspect,[],unpack');
  
  self.$require("base64");
  self.$require("corelib/pack_unpack/format_string_parser");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), expected = nil, given = nil;

    
    
    // Format Parser
    var eachDirectiveAndCount = Opal.PackUnpack.eachDirectiveAndCount;

    function flattenArray(callback) {
      return function(data) {
        var array = callback(data);
        return (array).$flatten();
      }
    }

    function mapChunksToWords(callback) {
      return function(data) {
        var chunks = callback(data);

        return chunks.map(function(chunk) {
          return chunk.reverse().reduce(function(result, singleByte) {
            return result * 256 + singleByte;
          }, 0);
        });
      }
    }

    function chunkBy(chunkSize, callback) {
      return function(data) {
        var array = callback(data),
            chunks = [],
            chunksCount = (array.length / chunkSize);

        for (var i = 0; i < chunksCount; i++) {
          var chunk = array.splice(0, chunkSize);
          if (chunk.length === chunkSize) {
            chunks.push(chunk);
          }
        }

        return chunks;
      }
    }

    function toNByteSigned(bytesCount, callback) {
      return function(data) {
        var unsignedBits = callback(data),
            bitsCount = bytesCount * 8,
            limit = Math.pow(2, bitsCount);

        return unsignedBits.map(function(n) {
          if (n >= limit / 2) {
            n -= limit;
          }

          return n;
        });
      }
    }

    function bytesToAsciiChars(callback) {
      return function(data) {
        var bytes = callback(data);

        return bytes.map(function(singleByte) {
          return String.fromCharCode(singleByte);
        });
      }
    }

    function joinChars(callback) {
      return function(data) {
        var chars = callback(data);
        return chars.join('');
      }
    }

    function wrapIntoArray(callback) {
      return function(data) {
        var object = callback(data);
        return [object];
      }
    }

    function filterTrailingChars(chars) {
      var charCodesToFilter = chars.map(function(s) { return s.charCodeAt(0); });

      return function(callback) {
        return function(data) {
          var charCodes = callback(data);

          while (charCodesToFilter.indexOf(charCodes[charCodes.length - 1]) !== -1) {
            charCodes = charCodes.slice(0, charCodes.length - 1);
          }

          return charCodes;
        }
      }
    }

    var filterTrailingZerosAndSpaces = filterTrailingChars(["\u0000", " "]);

    function invertChunks(callback) {
      return function(data) {
        var chunks = callback(data);

        return chunks.map(function(chunk) {
          return chunk.reverse();
        });
      }
    }

    function uudecode(callback) {
      return function(data) {
        var bytes = callback(data);

        var stop = false;
        var i = 0, length = 0;

        var result = [];

        do {
          if (i < bytes.length) {
            var n = bytes[i] - 32 & 0x3F;

            ++i;

            if (bytes[i] === 10) {
              continue;
            }

            if (n > 45) {
              return '';
            }

            length += n;

            while (n > 0) {
              var c1 = bytes[i];
              var c2 = bytes[i + 1];
              var c3 = bytes[i + 2];
              var c4 = bytes[i + 3];

              var b1 = (c1 - 32 & 0x3F) << 2 | (c2 - 32 & 0x3F) >> 4;
              var b2 = (c2 - 32 & 0x3F) << 4 | (c3 - 32 & 0x3F) >> 2;
              var b3 = (c3 - 32 & 0x3F) << 6 | c4 - 32 & 0x3F;

              result.push(b1 & 0xFF);
              result.push(b2 & 0xFF);
              result.push(b3 & 0xFF);

              i += 4;
              n -= 3;
            }

            ++i;
          } else {
            break;
          }
        } while (true);

        return result.slice(0, length);
      }
    }

    function toBits(callback) {
      return function(data) {
        var bytes = callback(data);

        var bits = bytes.map(function(singleByte) {
          return singleByte.toString(2);
        });

        return bits;
      }
    }

    function decodeBERCompressedIntegers(callback) {
      return function(data) {
        var bytes = callback(data), result = [], buffer = '';

        for (var i = 0; i < bytes.length; i++) {
          var singleByte = bytes[i],
              bits = singleByte.toString(2);

          bits = Array(8 - bits.length + 1).join('0').concat(bits);

          var firstBit = bits[0];
          bits = bits.slice(1, bits.length);

          buffer = buffer.concat(bits);

          if (firstBit === '0') {
            var decoded = parseInt(buffer, 2);
            result.push(decoded);
            buffer = ''
          }
        }

        return result;
      }
    }

    function base64Decode(callback) {
      return function(data) {
        return $$('Base64').$decode64(callback(data));
      }
    }

    // quoted-printable decode
    function qpdecode(callback) {
      return function(data) {
        var string = callback(data);

        return string
          .replace(/[\t\x20]$/gm, '')
          .replace(/=(?:\r\n?|\n|$)/g, '')
          .replace(/=([a-fA-F0-9]{2})/g, function($0, $1) {
            var codePoint = parseInt($1, 16);
            return String.fromCharCode(codePoint);
          });
      }
    }

    function identityFunction(value) { return value; }

    var handlers = {
      // Integer
      'C': identityFunction,
      'S': mapChunksToWords(chunkBy(2, identityFunction)),
      'L': mapChunksToWords(chunkBy(4, identityFunction)),
      'Q': mapChunksToWords(chunkBy(8, identityFunction)),
      'J': null,

      'S>': mapChunksToWords(invertChunks(chunkBy(2, identityFunction))),
      'L>': mapChunksToWords(invertChunks(chunkBy(4, identityFunction))),
      'Q>': mapChunksToWords(invertChunks(chunkBy(8, identityFunction))),

      'c': toNByteSigned(1, identityFunction),
      's': toNByteSigned(2, mapChunksToWords(chunkBy(2, identityFunction))),
      'l': toNByteSigned(4, mapChunksToWords(chunkBy(4, identityFunction))),
      'q': toNByteSigned(8, mapChunksToWords(chunkBy(8, identityFunction))),
      'j': null,

      's>': toNByteSigned(2, mapChunksToWords(invertChunks(chunkBy(2, identityFunction)))),
      'l>': toNByteSigned(4, mapChunksToWords(invertChunks(chunkBy(4, identityFunction)))),
      'q>': toNByteSigned(8, mapChunksToWords(invertChunks(chunkBy(8, identityFunction)))),

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': identityFunction,
      'w': decodeBERCompressedIntegers(identityFunction),

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': wrapIntoArray(joinChars(bytesToAsciiChars(filterTrailingZerosAndSpaces(identityFunction)))),
      'a': wrapIntoArray(joinChars(bytesToAsciiChars(identityFunction))),
      'Z': joinChars(bytesToAsciiChars(identityFunction)),
      'B': joinChars(identityFunction),
      'b': joinChars(identityFunction),
      'H': joinChars(identityFunction),
      'h': joinChars(identityFunction),
      'u': joinChars(bytesToAsciiChars(uudecode(identityFunction))),
      'M': qpdecode(joinChars(bytesToAsciiChars(identityFunction))),
      'm': base64Decode(joinChars(bytesToAsciiChars(identityFunction))),

      'P': null,
      'p': null
    };

    function readBytes(n) {
      return function(bytes) {
        var chunk = bytes.slice(0, n);
        bytes = bytes.slice(n, bytes.length);
        return { chunk: chunk, rest: bytes };
      }
    }

    function readUnicodeCharChunk(bytes) {
      var currentByteIndex = 0;
      var bytesLength = bytes.length;
      function readByte() {
        var result = bytes[currentByteIndex++];
        bytesLength = bytes.length - currentByteIndex;
        return result;
      }

      var c = readByte(), extraLength;

      if (c >> 7 == 0) {
        // 0xxx xxxx
        return { chunk: [c], rest: bytes.slice(currentByteIndex) };
      }

      if (c >> 6 == 0x02) {
        $Kernel.$raise($$$('ArgumentError'), "malformed UTF-8 character")
      }

      if (c >> 5 == 0x06) {
        // 110x xxxx (two bytes)
        extraLength = 1;
      } else if (c >> 4 == 0x0e) {
        // 1110 xxxx (three bytes)
        extraLength = 2;
      } else if (c >> 3 == 0x1e) {
        // 1111 0xxx (four bytes)
        extraLength = 3;
      } else if (c >> 2 == 0x3e) {
        // 1111 10xx (five bytes)
        extraLength = 4;
      } else if (c >> 1 == 0x7e) {
        // 1111 110x (six bytes)
        extraLength = 5;
      } else {
        $Kernel.$raise("malformed UTF-8 character")
      }

      if (extraLength > bytesLength) {
        ((expected = extraLength + 1), (given = bytesLength + 1), $Kernel.$raise($$$('ArgumentError'), "malformed UTF-8 character (expected " + (expected) + " bytes, given " + (given) + " bytes)"))
      }

      // Remove the UTF-8 prefix from the char
      var mask = (1 << (8 - extraLength - 1)) - 1,
          result = c & mask;

      for (var i = 0; i < extraLength; i++) {
        c = readByte();

        if (c >> 6 != 0x02) {
          $Kernel.$raise("Invalid multibyte sequence")
        }

        result = (result << 6) | (c & 0x3f);
      }

      if (result <= 0xffff) {
        return { chunk: [result], rest: bytes.slice(currentByteIndex) };
      } else {
        result -= 0x10000;
        var high = ((result >> 10) & 0x3ff) + 0xd800,
            low = (result & 0x3ff) + 0xdc00;
        return { chunk: [high, low], rest: bytes.slice(currentByteIndex) };
      }
    }

    function readUuencodingChunk(buffer) {
      var length = buffer.indexOf(32); // 32 = space

      if (length === -1) {
        return { chunk: buffer, rest: [] };
      } else {
        return { chunk: buffer.slice(0, length), rest: buffer.slice(length, buffer.length) };
      }
    }

    function readNBitsLSBFirst(buffer, count) {
      var result = '';

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            bitsToTake = Math.min(count, 8),
            bytesToTake = Math.ceil(bitsToTake / 8);

        buffer = buffer.slice(1, buffer.length);

        if (singleByte != null) {
          var bits = singleByte.toString(2);
          bits = Array(8 - bits.length + 1).join('0').concat(bits).split('').reverse().join('');

          for (var j = 0; j < bitsToTake; j++) {
            result += bits[j] || '0';
            count--;
          }
        }
      }

      return { chunk: [result], rest: buffer };
    }

    function readNBitsMSBFirst(buffer, count) {
      var result = '';

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            bitsToTake = Math.min(count, 8),
            bytesToTake = Math.ceil(bitsToTake / 8);

        buffer = buffer.slice(1, buffer.length);

        if (singleByte != null) {
          var bits = singleByte.toString(2);
          bits = Array(8 - bits.length + 1).join('0').concat(bits);

          for (var j = 0; j < bitsToTake; j++) {
            result += bits[j] || '0';
            count--;
          }
        }
      }

      return { chunk: [result], rest: buffer };
    }

    function readWhileFirstBitIsOne(buffer) {
      var result = [];

      for (var i = 0; i < buffer.length; i++) {
        var singleByte = buffer[i];

        result.push(singleByte);

        if ((singleByte & 128) === 0) {
          break;
        }
      }

      return { chunk: result, rest: buffer.slice(result.length, buffer.length) };
    }

    function readTillNullCharacter(buffer, count) {
      var result = [];

      for (var i = 0; i < count && i < buffer.length; i++) {
        var singleByte = buffer[i];

        if (singleByte === 0) {
          break;
        } else {
          result.push(singleByte);
        }
      }

      if (count === Infinity) {
        count = result.length;
      }

      if (buffer[count] === 0) {
        count++;
      }

      buffer = buffer.slice(count, buffer.length);

      return { chunk: result, rest: buffer };
    }

    function readHexCharsHighNibbleFirst(buffer, count) {
      var result = [];

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            hex = singleByte.toString(16);

        buffer = buffer.slice(1, buffer.length);
        hex = Array(2 - hex.length + 1).join('0').concat(hex);

        if (count === 1) {
          result.push(hex[0]);
          count--;
        } else {
          result.push(hex[0], hex[1]);
          count -= 2;
        }
      }

      return { chunk: result, rest: buffer };
    }

    function readHexCharsLowNibbleFirst(buffer, count) {
      var result = [];

      while (count > 0 && buffer.length > 0) {
        var singleByte = buffer[0],
            hex = singleByte.toString(16);

        buffer = buffer.slice(1, buffer.length);
        hex = Array(2 - hex.length + 1).join('0').concat(hex);

        if (count === 1) {
          result.push(hex[1]);
          count--;
        } else {
          result.push(hex[1], hex[0]);
          count -= 2;
        }
      }

      return { chunk: result, rest: buffer };
    }

    function readNTimesAndMerge(callback) {
      return function(buffer, count) {
        var chunk = [], chunkData;

        if (count === Infinity) {
          while (buffer.length > 0) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        } else {
          for (var i = 0; i < count; i++) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    function readAll(buffer, count) {
      return { chunk: buffer, rest: [] };
    }

    var readChunk = {
      // Integer
      'C': readNTimesAndMerge(readBytes(1)),
      'S': readNTimesAndMerge(readBytes(2)),
      'L': readNTimesAndMerge(readBytes(4)),
      'Q': readNTimesAndMerge(readBytes(8)),
      'J': null,

      'S>': readNTimesAndMerge(readBytes(2)),
      'L>': readNTimesAndMerge(readBytes(4)),
      'Q>': readNTimesAndMerge(readBytes(8)),

      'c': readNTimesAndMerge(readBytes(1)),
      's': readNTimesAndMerge(readBytes(2)),
      'l': readNTimesAndMerge(readBytes(4)),
      'q': readNTimesAndMerge(readBytes(8)),
      'j': null,

      's>': readNTimesAndMerge(readBytes(2)),
      'l>': readNTimesAndMerge(readBytes(4)),
      'q>': readNTimesAndMerge(readBytes(8)),

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': readNTimesAndMerge(readUnicodeCharChunk),
      'w': readNTimesAndMerge(readWhileFirstBitIsOne),

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': readNTimesAndMerge(readBytes(1)),
      'a': readNTimesAndMerge(readBytes(1)),
      'Z': readTillNullCharacter,
      'B': readNBitsMSBFirst,
      'b': readNBitsLSBFirst,
      'H': readHexCharsHighNibbleFirst,
      'h': readHexCharsLowNibbleFirst,
      'u': readNTimesAndMerge(readUuencodingChunk),
      'M': readAll,
      'm': readAll,

      'P': null,
      'p': null
    }

    var autocompletion = {
      // Integer
      'C': true,
      'S': true,
      'L': true,
      'Q': true,
      'J': null,

      'S>': true,
      'L>': true,
      'Q>': true,

      'c': true,
      's': true,
      'l': true,
      'q': true,
      'j': null,

      's>': true,
      'l>': true,
      'q>': true,

      'n': null, // aliased later
      'N': null, // aliased later
      'v': null, // aliased later
      'V': null, // aliased later

      'U': false,
      'w': false,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': false,
      'a': false,
      'Z': false,
      'B': false,
      'b': false,
      'H': false,
      'h': false,
      'u': false,
      'M': false,
      'm': false,

      'P': null,
      'p': null
    }

    var optimized = {
      'C*': handlers['C'],
      'c*': handlers['c'],
      'A*': handlers['A'],
      'a*': handlers['a'],
      'M*': wrapIntoArray(handlers['M']),
      'm*': wrapIntoArray(handlers['m']),
      'S*': handlers['S'],
      's*': handlers['s'],
      'L*': handlers['L'],
      'l*': handlers['l'],
      'Q*': handlers['Q'],
      'q*': handlers['q'],
      'S>*': handlers['S>'],
      's>*': handlers['s>'],
      'L>*': handlers['L>'],
      'l>*': handlers['l>'],
      'Q>*': handlers['Q>'],
      'q>*': handlers['q>']
    }

    function alias(existingDirective, newDirective) {
      readChunk[newDirective] = readChunk[existingDirective];
      handlers[newDirective] = handlers[existingDirective];
      autocompletion[newDirective] = autocompletion[existingDirective];
    }

    alias('S>', 'n');
    alias('L>', 'N');

    alias('S', 'v');
    alias('L', 'V');
  ;
    
    $def(self, '$unpack', function $$unpack(format, $kwargs) {
      var offset, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      offset = $kwargs.$$smap["offset"];if (offset == null) offset = 0;
      if ($truthy($rb_lt(offset, 0))) {
        $Kernel.$raise($$$('ArgumentError'), "offset can't be negative")
      };
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      
      var output = [];

      // A very optimized handler for U*.
      if (format == "U*" &&
          self.internal_encoding.name === "UTF-8" &&
          typeof self.codePointAt === "function") {

        var cp, j = 0;

        output = new Array(self.length);
        for (var i = offset; i < self.length; i++) {
          cp = output[j++] = self.codePointAt(i);
          if (cp > 0xffff) i++;
        }
        return output.slice(0, j);
      }

      var buffer = self.$bytes();

      ($truthy($rb_gt(offset, (buffer).$length())) ? ($Kernel.$raise($$$('ArgumentError'), "offset outside of string")) : nil)

      buffer = buffer.slice(offset);


      // optimization
      var optimizedHandler = optimized[format];
      if (optimizedHandler) {
        return optimizedHandler(buffer);
      }

      function autocomplete(array, size) {
        while (array.length < size) {
          array.push(nil);
        }

        return array;
      }

      function processChunk(directive, count) {
        var chunk,
            chunkReader = readChunk[directive];

        if (chunkReader == null) {
          $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no chunk reader defined)")
        }

        var chunkData = chunkReader(buffer, count);
        chunk = chunkData.chunk;
        buffer = chunkData.rest;

        var handler = handlers[directive];

        if (handler == null) {
          $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no handler defined)")
        }

        return handler(chunk);
      }

      eachDirectiveAndCount(format, function(directive, count) {
        var part = processChunk(directive, count);

        if (count !== Infinity) {
          var shouldAutocomplete = autocompletion[directive];

          if (shouldAutocomplete == null) {
            $Kernel.$raise("Unsupported unpack directive " + ((directive).$inspect()) + " (no autocompletion rule defined)")
          }

          if (shouldAutocomplete) {
            autocomplete(part, count);
          }
        }

        output = output.concat(part);
      });

      return output;
    ;
    }, -2);
    return $def(self, '$unpack1', function $$unpack1(format, $kwargs) {
      var offset, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      offset = $kwargs.$$smap["offset"];if (offset == null) offset = 0;
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      return self.$unpack(format['$[]'](0), $hash2(["offset"], {"offset": offset}))['$[]'](0);
    }, -2);
  })('::', null, $nesting);
};

Opal.modules["corelib/array/pack"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $coerce_to = Opal.coerce_to, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $def = Opal.def, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,raise,delete,gsub,coerce_to!,inspect');
  
  self.$require("corelib/pack_unpack/format_string_parser");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    
    
    // Format Parser
    var eachDirectiveAndCount = Opal.PackUnpack.eachDirectiveAndCount;

    function identityFunction(value) { return value; }

    function utf8BytesToUtf16LEString(bytes) {
      var str = String.fromCharCode.apply(null, bytes), out = "", i = 0, len = str.length, c, char2, char3;
      while (i < len) {
        c = str.charCodeAt(i++);
        switch (c >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            // 0xxxxxxx
            out += str.charAt(i - 1);
            break;
          case 12:
          case 13:
            // 110x xxxx 10xx xxxx
            char2 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
            break;
          case 14:
            // 1110 xxxx10xx xxxx10xx xxxx
            char2 = str.charCodeAt(i++);
            char3 = str.charCodeAt(i++);
            out += String.fromCharCode(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
            break;
        }
      }
      return out;
    }

    function asciiBytesToUtf16LEString(bytes) {
      return String.fromCharCode.apply(null, bytes);
    }

    function asciiStringFromUnsignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function asciiStringFromSignedInt(bytes, callback) {
      return function(data) {
        var buffer = callback(data),
            bits = bytes * 8,
            limit = Math.pow(2, bits);

        return buffer.map(function(item) {
          if (item < 0) {
            item += limit;
          }

          var result = [];

          for (var i = 0; i < bytes; i++) {
            var bit = item & 255;
            result.push(bit);
            item = item >> 8;
          };

          return asciiBytesToUtf16LEString(result);
        });
      }
    }

    function toInt(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$$('Integer'), 'to_int')
        });
      }
    }

    function ToStr(callback) {
      return function(data) {
        var buffer = callback(data);

        return buffer.map(function(item) {
          return $coerce_to(item, $$$('String'), 'to_str')
        });
      }
    }

    function fromCodePoint(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.map(function(item) {
          try {
            return String.fromCodePoint(item);
          } catch (error) {
            if (error instanceof RangeError) {
              $Kernel.$raise($$$('RangeError'), "value out of range");
            }
            throw error;
          }
        });
      }
    }

    function joinChars(callback) {
      return function(data) {
        var buffer = callback(data);
        return buffer.join('');
      }
    }

    var handlers = {
      // Integer
      'C': joinChars(asciiStringFromUnsignedInt(1, toInt(identityFunction))),
      'S': joinChars(asciiStringFromUnsignedInt(2, toInt(identityFunction))),
      'L': joinChars(asciiStringFromUnsignedInt(4, toInt(identityFunction))),
      'Q': joinChars(asciiStringFromUnsignedInt(8, toInt(identityFunction))),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': joinChars(asciiStringFromSignedInt(1, toInt(identityFunction))),
      's': joinChars(asciiStringFromSignedInt(2, toInt(identityFunction))),
      'l': joinChars(asciiStringFromSignedInt(4, toInt(identityFunction))),
      'q': joinChars(asciiStringFromSignedInt(8, toInt(identityFunction))),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': joinChars(fromCodePoint(toInt(identityFunction))),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': joinChars(identityFunction),
      'a': joinChars(identityFunction),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    function readNTimesFromBufferAndMerge(callback) {
      return function(buffer, count) {
        var chunk = [], chunkData;

        if (count === Infinity) {
          while (buffer.length > 0) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        } else {
          if (buffer.length < count) {
            $Kernel.$raise($$$('ArgumentError'), "too few arguments");
          }
          for (var i = 0; i < count; i++) {
            chunkData = callback(buffer);
            buffer = chunkData.rest;
            chunk = chunk.concat(chunkData.chunk);
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    function readItem(buffer) {
      var chunk = buffer.slice(0, 1);
      buffer = buffer.slice(1, buffer.length);
      return { chunk: chunk, rest: buffer };
    }

    function readNCharsFromTheFirstItemAndMergeWithFallback(fallback, callback) {
      return function(buffer, count) {
        var chunk = [], source = buffer[0];

        if (source === nil) {
          source = '';
        } else if (source === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "too few arguments");
        } else {
          source = $coerce_to(source, $$$('String'), 'to_str');
        }

        buffer = buffer.slice(1, buffer.length);

        function infiniteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = []
          }

          chunk = chunk.concat(subChunk);
        }

        function finiteReeder() {
          var chunkData = callback(source);
          source = chunkData.rest;
          var subChunk = chunkData.chunk;

          if (subChunk.length === 0) {
            subChunk = [fallback];
          }

          if (subChunk.length === 1 && subChunk[0] === nil) {
            subChunk = [fallback];
          }

          chunk = chunk.concat(subChunk);
        }

        if (count === Infinity) {
          while (source.length > 0) {
            infiniteReeder();
          }
        } else {
          for (var i = 0; i < count; i++) {
            finiteReeder();
          }
        }

        return { chunk: chunk, rest: buffer };
      }
    }

    var readChunk = {
      // Integer
      'C': readNTimesFromBufferAndMerge(readItem),
      'S': readNTimesFromBufferAndMerge(readItem),
      'L': readNTimesFromBufferAndMerge(readItem),
      'Q': readNTimesFromBufferAndMerge(readItem),
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': readNTimesFromBufferAndMerge(readItem),
      's': readNTimesFromBufferAndMerge(readItem),
      'l': readNTimesFromBufferAndMerge(readItem),
      'q': readNTimesFromBufferAndMerge(readItem),
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': readNTimesFromBufferAndMerge(readItem),
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': readNCharsFromTheFirstItemAndMergeWithFallback(" ", readItem),
      'a': readNCharsFromTheFirstItemAndMergeWithFallback("\x00", readItem),
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': null,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };

    var autocompletion = {
      // Integer
      'C': false,
      'S': false,
      'L': false,
      'Q': false,
      'J': null,

      'S>': null,
      'L>': null,
      'Q>': null,

      'c': false,
      's': false,
      'l': false,
      'q': false,
      'j': null,

      's>': null,
      'l>': null,
      'q>': null,

      'n': null,
      'N': null,
      'v': null,
      'V': null,

      'U': false,
      'w': null,

      // Float
      'D': null,
      'd': null,
      'F': null,
      'f': null,
      'E': null,
      'e': null,
      'G': null,
      'g': null,

      // String
      'A': false,
      'a': false,
      'Z': null,
      'B': null,
      'b': null,
      'H': null,
      'h': null,
      'u': false,
      'M': null,
      'm': null,

      'P': null,
      'p': null
    };
  ;
    return $def(self, '$pack', function $$pack(format) {
      var self = this;

      
      format = $Opal['$coerce_to!'](format, $$$('String'), "to_str").$gsub(/\s/, "").$delete("\u0000");
      
      var output = '';

      var buffer = self.slice();

      function autocomplete(array, size) {
        while (array.length < size) {
          array.push(nil);
        }

        return array;
      }

      function processChunk(directive, count) {
        var chunk,
            chunkReader = readChunk[directive];

        if (chunkReader == null) {
          $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no chunk reader defined)")
        }

        var chunkData = chunkReader(buffer, count);
        chunk = chunkData.chunk;
        buffer = chunkData.rest;

        var handler = handlers[directive];

        if (handler == null) {
          $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no handler defined)")
        }

        return handler(chunk);
      }

      eachDirectiveAndCount(format, function(directive, count) {
        var part = processChunk(directive, count);

        if (count !== Infinity) {
          var shouldAutocomplete = autocompletion[directive]

          if (shouldAutocomplete == null) {
            $Kernel.$raise("Unsupported pack directive " + ((directive).$inspect()) + " (no autocompletion rule defined)")
          }

          if (shouldAutocomplete) {
            autocomplete(part, count);
          }
        }

        output = output.concat(part);
      });

      if (format.match(/^(U\*?)+$/)) {
        return output;
      }
      else {
        return Opal.enc(output, "binary");
      }
    ;
    });
  })('::', null);
};

Opal.modules["corelib/object_space"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $respond_to = Opal.respond_to, $truthy = Opal.truthy, $module = Opal.module, $Kernel = Opal.Kernel, $def = Opal.def, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $slice = Opal.slice, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('module_function,call,proc,raise,class,__id__,include,[],[]=,key?,each,define_method,include?');
  return (function($base) {
    var self = $module($base, 'ObjectSpace');

    
    
    self.$module_function();
    
    var callers = {}, registry, add_caller, delete_callers;
    if (typeof FinalizationRegistry === "function") {
      registry = new FinalizationRegistry(function(id) {
        if (typeof callers[id] !== "undefined") {
          for (var i = 0; i < callers[id].length; i++) {
            (callers[id][i]).$call(id);
          }
          delete callers[id];
        }
      });
      add_caller = function(id, value) {
        callers[id] = callers[id] || [];
        callers[id].push(value);
      }
      delete_callers = function(id) {
        delete callers[id];
      }
    }
    else {
      // A weak polyfill for FinalizationRegistry
      registry = {
        register: function(){},
        unregister: function(){}
      };
      add_caller = function(){};
      delete_callers = function(){};
    }
  ;
    
    $def(self, '$define_finalizer', function $$define_finalizer(obj, aproc) {
      var block = $$define_finalizer.$$p || nil;

      $$define_finalizer.$$p = null;
      
      ;
      ;
      
      if ($truthy(block)) aproc = block;
      if (!$truthy(aproc)) aproc = $Kernel.$proc();
      if (!$respond_to(aproc, '$call')) {
        $Kernel.$raise($$$('ArgumentError'), "Wrong type argument " + (aproc.$class()) + " (should be callable)");
      }
      var id = obj.$__id__();
      add_caller(id, aproc);
      try {
        registry.register(obj, id, obj);
      }
      catch (e) {
        delete_callers(id);
        $Kernel.$raise($$$('ArgumentError'), "cannot define finalizer for " + (obj.$class()));
      }
      return [0, aproc];
    ;
    }, -2);
    
    $def(self, '$undefine_finalizer', function $$undefine_finalizer(obj) {
      
      return "\n" + "      var id = " + (obj.$__id__()) + ";\n" + "      registry.unregister(obj);\n" + "      delete_callers(id);\n" + "      return obj;\n" + "    "
    });
    return (function($base, $super) {
      var self = $klass($base, $super, 'WeakMap');

      var $proto = self.$$prototype;

      $proto.primitive_map = $proto.weak_map = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.weak_map = new WeakMap();
        return (self.primitive_map = $hash2([], {}));
      });
      
      $def(self, '$[]', function $WeakMap_$$$1(p1) {
        var self = this;

        
        if (typeof p1 !== "function" && typeof p1 !== "object") return self.primitive_map['$[]'](p1);
        return self.weak_map.get(p1);
      
      });
      
      $def(self, '$[]=', function $WeakMap_$$$eq$2(p1, p2) {
        var $a, self = this;

        
        if (typeof p1 !== "function" && typeof p1 !== "object") return ($a = [p1, p2], $send(self.primitive_map, '[]=', $a), $a[$a.length - 1]);
        return self.weak_map.set(p1, p2);
      
      });
      
      $def(self, '$include?', function $WeakMap_include$ques$3(p1) {
        var self = this;

        
        if (typeof p1 !== "function" && typeof p1 !== "object") return self.primitive_map['$key?'](p1);
        return self.weak_map.has(p1);
      
      });
      $send(["each", "each_key", "each_value", "each_pair", "keys", "values", "size", "length"], 'each', [], function $WeakMap$4(i){var self = $WeakMap$4.$$s == null ? this : $WeakMap$4.$$s;

        
        if (i == null) i = nil;
        return $send(self, 'define_method', [i], function $$5($a){var $post_args, $fwd_rest;

          
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return $Kernel.$raise($$$('NotImplementedError'), "#" + (i) + " can't be implemented on top of JS interfaces");}, -1);}, {$$s: self});
      $alias(self, "member?", "include?");
      return $alias(self, "key?", "include?");
    })(self, null);
  })('::')
};

Opal.modules["corelib/pattern_matching/base"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $klass = Opal.klass, $return_self = Opal.return_self, $def = Opal.def, $alias = Opal.alias, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $rb_gt = Opal.rb_gt, $hash2 = Opal.hash2, $send = Opal.send, $rb_lt = Opal.rb_lt, $thrower = Opal.thrower, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('to_a,nil?,to_h,===,raise,>,length,values,each,<,!,include?,members,[]=,[]');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    return $def(self, '$deconstruct', $return_self)
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    return $def(self, '$deconstruct_keys', $return_self)
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Struct');

    
    
    $alias(self, "deconstruct", "to_a");
    return $def(self, '$deconstruct_keys', function $$deconstruct_keys(keys) {
      var self = this, out = nil;

      
      if ($truthy(keys['$nil?']())) {
        return self.$to_h()
      };
      if (!$eqeqeq($$$('Array'), keys)) {
        $Kernel.$raise($$$('TypeError'), "expected Array or nil")
      };
      if ($truthy($rb_gt(keys.$length(), self.$values().$length()))) {
        return $hash2([], {})
      };
      out = $hash2([], {});
      (function(){try { var $t_break = $thrower('break'); return $send(keys, 'each', [], function $$1(key){var $a, self = $$1.$$s == null ? this : $$1.$$s, should_break = nil, $ret_or_1 = nil;

        
        if (key == null) key = nil;
        should_break = ($eqeqeq($$$('Integer'), ($ret_or_1 = key)) ? ($rb_lt(self.$values().$length(), key)) : ($eqeqeq($$$('Symbol'), $ret_or_1) ? (self.$members()['$include?'](key)['$!']()) : (nil)));
        if ($truthy(should_break)) {
          $t_break.$throw()
        };
        return ($a = [key, self['$[]'](key)], $send(out, '[]=', $a), $a[$a.length - 1]);}, {$$s: self})} catch($e) {
        if ($e === $t_break) return $e.$v;
        throw $e;
      }})();
      return out;
    });
  })('::', null);
  return ($klass('::', $$$('StandardError'), 'NoMatchingPatternError'), nil);
};

Opal.modules["corelib/pattern_matching"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $eqeq = Opal.eqeq, $to_a = Opal.to_a, $slice = Opal.slice, $send = Opal.send, $neqeq = Opal.neqeq, $rb_lt = Opal.rb_lt, $to_ary = Opal.to_ary, $rb_minus = Opal.rb_minus, $rb_plus = Opal.rb_plus, $not = Opal.not, $thrower = Opal.thrower, self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require,new,match,returns,attr_reader,==,<<,[],===,any?,all?,respond_to?,deconstruct,!=,length,<,each_with_index,-,size,+,dup,times,to_h,deconstruct_keys,keys,key?,except,!,empty?');
  
  self.$require("corelib/pattern_matching/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'PatternMatching');

    var $proto = self.$$prototype;

    $proto.from = $proto.pattern = $proto.returns = nil;
    
    $defs(self, '$call', function $$call(from, pattern) {
      var self = this, pm = nil, $ret_or_1 = nil;

      
      pm = self.$new(from, pattern);
      if ($truthy(($ret_or_1 = pm.$match()))) {
        $ret_or_1
      } else {
        
        return nil;
      };
      return pm.$returns();
    });
    
    $def(self, '$initialize', function $$initialize(from, pattern) {
      var $a, self = this;

      
      $a = [from, pattern], (self.from = $a[0]), (self.pattern = $a[1]), $a;
      return (self.returns = []);
    });
    self.$attr_reader("returns");
    return $def(self, '$match', function $$match(from, pattern) {try { var $t_return = $thrower('return'); 
      var $a, $b, self = this, type = nil, args = nil, fixed_size = nil, array_size = nil, array_match = nil, a = nil, skip_elems = nil, skip_rests = nil, find_match = nil, first = nil, last = nil, pattern_length = nil, a_length = nil, returns_backup = nil, iterations = nil, any_size = nil, hash_match = nil, $ret_or_2 = nil;

      
      if (from == null) from = self.from;
      if (pattern == null) pattern = self.pattern;
      if ($eqeq(pattern, "var")) {
        
        self.returns['$<<'](from);
        return true;
      } else {
        
        $a = [].concat($to_a(pattern)), (type = ($a[0] == null ? nil : $a[0])), (args = $slice($a, 1)), $a;
        
        switch (type) {
          case "save":
            
            self.returns['$<<'](from);
            return self.$match(from, args['$[]'](0));
          case "lit":
            return args['$[]'](0)['$==='](from)
          case "any":
            return $send(args, 'any?', [], function $$1(arg){var self = $$1.$$s == null ? this : $$1.$$s;

              
              if (arg == null) arg = nil;
              return self.$match(from, arg);}, {$$s: self})
          case "all":
            return $send(args, 'all?', [], function $$2(arg){var self = $$2.$$s == null ? this : $$2.$$s;

              
              if (arg == null) arg = nil;
              return self.$match(from, arg);}, {$$s: self})
          case "array":
            
            $a = [].concat($to_a(args)), (fixed_size = ($a[0] == null ? nil : $a[0])), (array_size = ($a[1] == null ? nil : $a[1])), (array_match = ($a[2] == null ? nil : $a[2])), $a;
            if (!$truthy(from['$respond_to?']("deconstruct"))) {
              return false
            };
            a = from.$deconstruct();
            if (($truthy(fixed_size) && ($neqeq(a.$length(), array_size)))) {
              return false
            };
            if ($truthy($rb_lt(a.$length(), array_size))) {
              return false
            };
            skip_elems = 0;
            skip_rests = 0;
            return $send(array_match.$each_with_index(), 'all?', [], function $$3(elem, i){var $b, $c, self = $$3.$$s == null ? this : $$3.$$s;

              
              if (elem == null) elem = nil;
              if (i == null) i = nil;
              $c = elem, $b = $to_ary($c), (type = ($b[0] == null ? nil : $b[0])), (args = $slice($b, 1)), $c;
              
              switch (type) {
                case "rest":
                  
                  skip_elems = $rb_minus(a.$size(), array_size);
                  skip_rests = 1;
                  if ($truthy(args['$[]'](0))) {
                    self.$match(a['$[]'](Opal.Range.$new(i,$rb_plus(i, skip_elems), true)), args['$[]'](0))
                  };
                  return true;
                default:
                  return self.$match(a['$[]']($rb_minus($rb_plus(i, skip_elems), skip_rests)), elem)
              };}, {$$s: self});
          case "find":
            
            $a = [].concat($to_a(args)), (find_match = ($a[0] == null ? nil : $a[0])), $a;
            $a = [].concat($to_a(find_match)), (first = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (find_match = $slice($a, 1, $b)), (last = ($a[$b] == null ? nil : $a[$b])), $a;
            pattern_length = find_match.$length();
            if (!$truthy(from['$respond_to?']("deconstruct"))) {
              return false
            };
            a = from.$deconstruct();
            a_length = a.$length();
            if ($truthy($rb_lt(a_length, pattern_length))) {
              return false
            };
            returns_backup = self.returns.$dup();
            $a = [first['$[]'](1), last['$[]'](1)], (first = $a[0]), (last = $a[1]), $a;
            iterations = $rb_plus($rb_minus(a_length, pattern_length), 1);
            return $send(iterations.$times(), 'any?', [], function $$4(skip){var self = $$4.$$s == null ? this : $$4.$$s, first_part = nil, content = nil, last_part = nil, success = nil;

              
              if (skip == null) skip = nil;
              first_part = a['$[]'](0, skip);
              content = a['$[]'](skip, pattern_length);
              last_part = a['$[]'](Opal.Range.$new($rb_plus(skip, pattern_length), -1, false));
              if ($truthy(first)) {
                self.$match(first_part, first)
              };
              success = $send(content.$each_with_index(), 'all?', [], function $$5(e, i){var self = $$5.$$s == null ? this : $$5.$$s;

                
                if (e == null) e = nil;
                if (i == null) i = nil;
                return self.$match(e, find_match['$[]'](i));}, {$$s: self});
              if ($truthy(last)) {
                self.$match(last_part, last)
              };
              if (!$truthy(success)) {
                self.returns = returns_backup.$dup()
              };
              return success;}, {$$s: self});
          case "hash":
            
            $a = [].concat($to_a(args)), (any_size = ($a[0] == null ? nil : $a[0])), (hash_match = ($a[1] == null ? nil : $a[1])), $a;
            hash_match = hash_match.$to_h();
            if (!$truthy(from['$respond_to?']("deconstruct_keys"))) {
              return false
            };
            if (($truthy(any_size) && ($neqeq(any_size, true)))) {
              a = from.$deconstruct_keys(nil)
            } else {
              a = from.$deconstruct_keys(hash_match.$keys())
            };
            if ($truthy(($ret_or_2 = $send(hash_match, 'all?', [], function $$6(k, v){var self = $$6.$$s == null ? this : $$6.$$s;

              
              if (k == null) k = nil;
              if (v == null) v = nil;
              if (!$truthy(a['$key?'](k))) {
                $t_return.$throw(false)
              };
              return self.$match(a['$[]'](k), v);}, {$$s: self, $$ret: $t_return})))) {
              $ret_or_2
            } else {
              
              return false;
            };
            if (($truthy(any_size) && ($neqeq(any_size, true)))) {
              self.$match($send(a, 'except', $to_a(hash_match.$keys())), args['$[]'](0))
            } else if ($not(any_size)) {
              if (!$truthy($send(a, 'except', $to_a(hash_match.$keys()))['$empty?']())) {
                return false
              }
            };
            return true;
          default:
            return nil
        };
      };} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
  })('::', null);
};

Opal.modules["corelib/trace_point"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $def = Opal.def, $slice = Opal.slice, $return_ivar = Opal.return_ivar, nil = Opal.nil;

  Opal.add_stubs('enable,new,to_proc,attr_reader,==,raise,enabled?,disable');
  return (function($base, $super) {
    var self = $klass($base, $super, 'TracePoint');

    var $proto = self.$$prototype;

    $proto.event = $proto.tracers_for_evt = $proto.trace_evt = nil;
    
    $defs(self, '$trace', function $$trace(event) {
      var block = $$trace.$$p || nil, self = this;

      $$trace.$$p = null;
      
      ;
      return $send(self, 'new', [event], block.$to_proc()).$enable();
    });
    self.$attr_reader("event");
    
    $def(self, '$initialize', function $$initialize(event) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (!$eqeq(event, "class")) {
        $Kernel.$raise("Only the :class event is supported")
      };
      self.event = event;
      self.block = block;
      self.trace_object = nil;
      self.trace_evt = "trace_" + (self.event);
      return (self.tracers_for_evt = "tracers_for_" + (self.event));
    });
    
    $def(self, '$enable', function $$enable($a) {
      var enable_block = $$enable.$$p || nil, $post_args, args, self = this, previous_state = nil;

      $$enable.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      previous_state = self['$enabled?']();
      
      Opal[self.tracers_for_evt].push(self);
      Opal[self.trace_evt] = true;
    ;
      if ((enable_block !== nil)) {
        
        Opal.yieldX(enable_block, []);
        self.$disable();
      };
      return previous_state;
    }, -1);
    
    $def(self, '$enabled?', function $TracePoint_enabled$ques$1() {
      var self = this;

      return Opal[self.trace_evt] && Opal[self.tracers_for_evt].includes(self)
    });
    
    $def(self, '$disable', function $$disable() {
      var self = this;

      
      var idx = Opal[self.tracers_for_evt].indexOf(self)

      if (idx > -1) {
        Opal[self.tracers_for_evt].splice(idx, 1);

        if (Opal[self.tracers_for_evt].length === 0) {
          Opal[self.trace_evt] = false;
        }

        return true;
      } else {
        return false;
      }
    
    });
    return $def(self, '$self', $return_ivar("trace_object"));
  })('::', null)
};

Opal.modules["opal/full"] = function(Opal) {/* Generated by Opal 1.7.1 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('autoload,require');
  
  $Object.$autoload("Marshal", "corelib/marshal");
  $Object.$require("corelib/string/unpack");
  $Object.$require("corelib/array/pack");
  $Object.$autoload("ObjectSpace", "corelib/object_space");
  $Object.$require("corelib/pattern_matching/base");
  $Object.$autoload("PatternMatching", "corelib/pattern_matching");
  return $Object.$autoload("TracePoint", "corelib/trace_point");
};
