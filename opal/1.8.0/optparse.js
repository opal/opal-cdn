Opal.modules["optparse/version"] = function(Opal) {/* Generated by Opal 1.8.0 */
  var $slice = Opal.slice, $send = Opal.send, $eqeq = Opal.eqeq, $Object = Opal.Object, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $def = Opal.def, $regexp = Opal.regexp, $neqeq = Opal.neqeq, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('program_name,options,proc,to_s,==,===,join,<<,find,const_defined?,const_get,puts,[],size,search_const,call,intern,each,inject,split,raise,grep,constants,shift,!=');
  return (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$show_version', function $$show_version($a) {
      var $post_args, pkgs, self = this, progname = nil, result = nil, show = nil;

      
      $post_args = $slice(arguments);
      pkgs = $post_args;
      progname = $$('ARGV').$options().$program_name();
      result = false;
      show = $send(self, 'proc', [], function $$1(klass, cname, version){var self = $$1.$$s == null ? this : $$1.$$s, str = nil;

        
        if (klass == null) klass = nil;
        if (cname == null) cname = nil;
        if (version == null) version = nil;
        str = progname.$to_s();
        if (!($eqeq(klass, $Object) && ($eqeq(cname, "VERSION")))) {
          
          if ($eqeqeq($$('Array'), version)) {
            version = version.$join(".")
          };
          if (!$eqeq(klass, $$('Object'))) {
            str['$<<'](": " + (klass))
          };
          str['$<<'](" version " + (version));
        };
        $send(["Release", "RELEASE"], 'find', [], function $$2(rel){
          
          if (rel == null) rel = nil;
          if ($truthy(klass['$const_defined?'](rel))) {
            return str['$<<'](" (" + (klass.$const_get(rel)) + ")")
          } else {
            return nil
          };});
        self.$puts(str);
        return (result = true);}, {$$s: self});
      if (($eqeq(pkgs.$size(), 1) && ($eqeq(pkgs['$[]'](0), "all")))) {
        $send(self, 'search_const', [$Object, /^V(?:ERSION|ersion)$/], function $$3(klass, cname, version){
          
          if (klass == null) klass = nil;
          if (cname == null) cname = nil;
          if (version == null) version = nil;
          if (($eqeq(cname['$[]'](1), "e") && ($truthy(klass['$const_defined?']("Version"))))) {
            return nil
          } else {
            return show.$call(klass, cname.$intern(), version)
          };})
      } else {
        $send(pkgs, 'each', [], function $$4(pkg){var v = nil, n = nil;

          
          if (pkg == null) pkg = nil;
          try {
            
            pkg = $send(pkg.$split(/::|\//), 'inject', [$Object], function $$5(m, c){
              
              if (m == null) m = nil;
              if (c == null) c = nil;
              return m.$const_get(c);});
            v = ($truthy(pkg['$const_defined?']("Version")) ? (pkg.$const_get((n = "Version"))) : ($truthy(pkg['$const_defined?']("VERSION")) ? (pkg.$const_get((n = "VERSION"))) : (((n = nil), "unknown"))));
            return show.$call(pkg, n, v);
          } catch ($err) {
            if (Opal.rescue($err, [$$('NameError')])) {
              try {
                return nil
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          };})
      };
      return result;
    }, -1);
    
    $def(self, '$each_const', function $$each_const(path, base) {
      var self = this;

      
      if (base == null) base = $Object;
      return $send(path.$split(/::|\//), 'inject', [base], function $$6(klass, name){var self = $$6.$$s == null ? this : $$6.$$s;

        
        if (klass == null) klass = nil;
        if (name == null) name = nil;
        if (!$eqeqeq($$('Module'), klass)) {
          self.$raise($$('NameError'), path)
        };
        return $send(klass.$constants(), 'grep', [$regexp([name], 'i')], function $$7(c){var $ret_or_1 = nil;

          
          if (c == null) c = nil;
          if ($truthy(($ret_or_1 = klass['$const_defined?'](c)))) {
            $ret_or_1
          } else {
            return nil
          };
          return klass.$const_get(c);});}, {$$s: self});
    }, -2);
    return $def(self, '$search_const', function $$search_const(klass, name) {
      var $yield = $$search_const.$$p || nil, klasses = nil;

      $$search_const.$$p = null;
      
      klasses = [klass];
      while ($truthy((klass = klasses.$shift()))) {
      $send(klass.$constants(), 'each', [], function $$8(cname){var $ret_or_1 = nil, const$ = nil;

          
          if (cname == null) cname = nil;
          if ($truthy(($ret_or_1 = klass['$const_defined?'](cname)))) {
            $ret_or_1
          } else {
            return nil
          };
          const$ = klass.$const_get(cname);
          if ($eqeqeq(name, cname)) {
            Opal.yieldX($yield, [klass, cname, const$])
          };
          if (($eqeqeq($$('Module'), const$) && ($neqeq(const$, $Object)))) {
            return klasses['$<<'](const$)
          } else {
            return nil
          };})
      };
    });
  })(Opal.get_singleton_class($$('OptionParser')), $nesting)
};

Opal.modules["shellwords"] = function(Opal) {/* Generated by Opal 1.8.0 */
  var $module = Opal.module, $rb_plus = Opal.rb_plus, $send = Opal.send, $to_ary = Opal.to_ary, $truthy = Opal.truthy, $def = Opal.def, $alias = Opal.alias, $klass = Opal.klass, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('+,new,scan,raise,inspect,gsub,<<,shellsplit,module_function,to_s,empty?,dup,shellescape,join,map,shelljoin,split,escape');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Shellwords');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$shellsplit', function $$shellsplit(line) {
      var self = this, words = nil, field = nil;

      
      line = $rb_plus(line, " ");
      words = [];
      field = $$('String').$new();
      $send(line, 'scan', [/\s*(?:([^\s\\\'\"]+)|'([^\']*)'|"((?:[^\"\\]|\\.)*)"|(\\.?)|(\S))(\r?\n?\Z|\s)?/m], function $$1($mlhs_tmp1){var $a, $b, self = $$1.$$s == null ? this : $$1.$$s, word = nil, sq = nil, dq = nil, esc = nil, garbage = nil, sep = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

        
        if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;
        $b = $mlhs_tmp1, $a = $to_ary($b), (word = ($a[0] == null ? nil : $a[0])), (sq = ($a[1] == null ? nil : $a[1])), (dq = ($a[2] == null ? nil : $a[2])), (esc = ($a[3] == null ? nil : $a[3])), (garbage = ($a[4] == null ? nil : $a[4])), (sep = ($a[5] == null ? nil : $a[5])), $b;
        if ($truthy(garbage)) {
          self.$raise($$('ArgumentError'), "Unmatched quote: " + (line.$inspect()))
        };
        field = $rb_plus(field, ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = word)) ? ($ret_or_3) : (sq)))) ? ($ret_or_2) : (($truthy(($ret_or_3 = dq)) ? (dq.$gsub(/\\([$`"\\\n])/, "\\1")) : ($ret_or_3)))))) ? ($ret_or_1) : (esc.$gsub(/\\(.)/, "\\1"))));
        if ($truthy(sep)) {
          
          words['$<<'](field);
          return (field = $$('String').$new());
        } else {
          return nil
        };}, {$$s: self, $$has_top_level_mlhs_arg: true});
      return words;
    });
    $alias(self, "shellwords", "shellsplit");
    self.$module_function("shellsplit", "shellwords");
    (function(self, $parent_nesting) {
      
      return $alias(self, "split", "shellsplit")
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$shellescape', function $$shellescape(str) {
      
      
      str = str.$to_s();
      if ($truthy(str['$empty?']())) {
        return "''".$dup()
      };
      str = str.$dup();
      str = str.$gsub(/[^A-Za-z0-9_\-.,:+\/@\n]/, "\\\\\\&");
      return str.$gsub(/\n/, "'\n'");
    });
    self.$module_function("shellescape");
    (function(self, $parent_nesting) {
      
      return $alias(self, "escape", "shellescape")
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$shelljoin', function $$shelljoin(array) {
      var self = this;

      return $send(array, 'map', [], function $$2(arg){var self = $$2.$$s == null ? this : $$2.$$s;

        
        if (arg == null) arg = nil;
        return self.$shellescape(arg);}, {$$s: self}).$join(" ")
    });
    self.$module_function("shelljoin");
    return (function(self, $parent_nesting) {
      
      return $alias(self, "join", "shelljoin")
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$shellsplit', function $$shellsplit() {
      var self = this;

      return $$('Shellwords').$split(self)
    });
    return $def(self, '$shellescape', function $$shellescape() {
      var self = this;

      return $$('Shellwords').$escape(self)
    });
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$shelljoin', function $$shelljoin() {
      var self = this;

      return $$('Shellwords').$join(self)
    })
  })($nesting[0], null, $nesting);
};

Opal.modules["optparse"] = function(Opal) {/* Generated by Opal 1.8.0 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $module = Opal.module, $rb_plus = Opal.rb_plus, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $to_a = Opal.to_a, $rb_ge = Opal.rb_ge, $rb_minus = Opal.rb_minus, $rb_lt = Opal.rb_lt, $rb_times = Opal.rb_times, $not = Opal.not, $thrower = Opal.thrower, $return_val = Opal.return_val, $gvars = Opal.gvars, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_le = Opal.rb_le, $neqeq = Opal.neqeq, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $lambda = Opal.lambda, $regexp = Opal.regexp, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('freeze,new,+,gsub,quote,regexp,call,===,id2name,empty?,<<,candidate,to_proc,method,public,sort_by,size,==,[],>,shift,each,rindex,throw,include,attr_reader,>=,incompatible_argument_styles,raise,filter_backtrace,caller,pattern,match,to_a,length,private,conv,proc,block,-,fetch,[]=,join,dup,desc,arg,<,+@,*,sub,to_i,max,collect,!,ljust,to_s,=~,first,long,short,last_match,conv_arg,parse_arg,respond_to?,delete,update,invert,delete_if,unshift,push,__send__,complete,keys,list,reverse_each,summarize,concat,reverse,each_line,add_banner,compsys,catch,basename,visit,puts,help,exit,require,show_version,split,abort,program_name,ver,instance_eval,nonzero?,inc,class,add_officious,base,terminate,accept,top,reject,attr_writer,attr_accessor,banner=,program_name=,summary_width=,summary_indent=,version,release,pop,index,banner,<=,search,notwice,!=,any?,guess,tr,downcase,append,make_switch,define,prepend,define_head,define_tail,order!,default_argv,to_sym,parse_in_order,include?,require_exact,set_option,parse,switch_name,delete_prefix,match_nonswitch?,permute!,parse!,scan,compact,getopts,curry,select!,is_a?,message_for,formatter,&,correct,map,map!,load,expand_path,readlines,upcase,shellwords,nil?,Integer,to_f,Rational,Float,|,args,reason,additional,message,const_set,undef_method,default_argv=,warn,options,extend');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'OptionParser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), decimal = nil, binary = nil, hex = nil, octal = nil, integer = nil, float$ = nil, floatpat = nil, real = nil, yesno = nil, $proto = self.$$prototype;

    $proto.banner = $proto.program_name = $proto.version = $proto.release = $proto.stack = $proto.summary_width = $proto.summary_indent = nil;
    
    $const_set($$('OptionParser'), 'Version', "0.1.1");
    $const_set($nesting[0], 'NoArgument', [$const_set($nesting[0], 'NO_ARGUMENT', "NONE"), nil].$freeze());
    $const_set($nesting[0], 'RequiredArgument', [$const_set($nesting[0], 'REQUIRED_ARGUMENT', "REQUIRED"), true].$freeze());
    $const_set($nesting[0], 'OptionalArgument', [$const_set($nesting[0], 'OPTIONAL_ARGUMENT', "OPTIONAL"), false].$freeze());
    (function($base, $parent_nesting) {
      var self = $module($base, 'Completion');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$regexp', function $$regexp(key, icase) {
        
        return $$('Regexp').$new($rb_plus("\\A", $$('Regexp').$quote(key).$gsub(/\w+\b/, "\\&\\w*")), icase)
      });
      $defs(self, '$candidate', function $$candidate(key, icase, pat) {
        var block = $$candidate.$$p || nil, $ret_or_1 = nil, candidates = nil;

        $$candidate.$$p = null;
        
        ;
        if (icase == null) icase = false;
        if (pat == null) pat = nil;
        pat = ($truthy(($ret_or_1 = pat)) ? ($ret_or_1) : ($$('Completion').$regexp(key, icase)));
        candidates = [];
        $send(block, 'call', [], function $$1(k, $a){var $post_args, v, $b, $c, $d, $e, kn = nil;

          
          if (k == null) k = nil;
          $post_args = $slice(arguments, 1);
          v = $post_args;
          if ($truthy(($ret_or_1 = ($eqeqeq($$('Regexp'), k) ? (((kn = ""), k['$==='](key))) : (((kn = ($truthy(((($b = k) && ($c = $b, $c) && ($d = $c) && ((($e = $d.$id2name) && !$e.$$stub) || $d['$respond_to_missing?']('id2name'))) ? 'method' : nil)) ? (k.$id2name()) : (k))), pat['$==='](kn))))))) {
            $ret_or_1
          } else {
            return nil
          };
          if ($truthy(v['$empty?']())) {
            v['$<<'](k)
          };
          return candidates['$<<']([k, v, kn]);}, -2);
        return candidates;
      }, -2);
      
      $def(self, '$candidate', function $$candidate(key, icase, pat) {
        var self = this;

        
        if (icase == null) icase = false;
        if (pat == null) pat = nil;
        return $send($$('Completion'), 'candidate', [key, icase, pat], self.$method("each").$to_proc());
      }, -2);
      self.$public();
      
      $def(self, '$complete', function $$complete(key, icase, pat) {
        var $a, $b, $yield = $$complete.$$p || nil, self = this, candidates = nil, canon = nil, sw = nil, cn = nil, $ret_or_1 = nil;

        $$complete.$$p = null;
        
        if (icase == null) icase = false;
        if (pat == null) pat = nil;
        candidates = $send($send(self, 'candidate', [key, icase, pat], self.$method("each").$to_proc()), 'sort_by', [], function $$2(k, v, kn){
          
          if (k == null) k = nil;
          if (v == null) v = nil;
          if (kn == null) kn = nil;
          return kn.$size();});
        if ($eqeq(candidates.$size(), 1)) {
          $b = candidates['$[]'](0), $a = $to_ary($b), (canon = ($a[0] == null ? nil : $a[0])), (sw = ($a[1] == null ? nil : $a[1])), $b
        } else if ($truthy($rb_gt(candidates.$size(), 1))) {
          
          $b = candidates.$shift(), $a = $to_ary($b), (canon = ($a[0] == null ? nil : $a[0])), (sw = ($a[1] == null ? nil : $a[1])), (cn = ($a[2] == null ? nil : $a[2])), $b;
          $send(candidates, 'each', [], function $$3(k, v, kn){var $c, self = $$3.$$s == null ? this : $$3.$$s;

            
            if (k == null) k = nil;
            if (v == null) v = nil;
            if (kn == null) kn = nil;
            if ($eqeq(sw, v)) {
              return nil
            };
            if (($eqeqeq($$('String'), cn) && ($eqeqeq($$('String'), kn)))) {
              if ($truthy(cn.$rindex(kn, 0))) {
                
                $c = [k, v, kn], (canon = $c[0]), (sw = $c[1]), (cn = $c[2]), $c;
                return nil;
              } else if ($truthy(kn.$rindex(cn, 0))) {
                return nil
              }
            };
            return self.$throw("ambiguous", key);}, {$$s: self});
        };
        if ($truthy(canon)) {
          
          if ($truthy(($ret_or_1 = ($yield !== nil)))) {
            $ret_or_1
          } else {
            
            return [key].concat($to_a(sw));
          };
          return Opal.yieldX($yield, [key].concat($to_a(sw)));;
        } else {
          return nil
        };
      }, -2);
      return $def(self, '$convert', function $$convert($a, $b, $c) {
        var $post_args, opt, val, $fwd_rest;

        
        $post_args = $slice(arguments);
        
        if ($post_args.length > 0) opt = $post_args.shift();if (opt == null) opt = nil;
        
        if ($post_args.length > 0) val = $post_args.shift();if (val == null) val = nil;
        $fwd_rest = $post_args;
        return val;
      }, -1);
    })($nesting[0], $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'OptionMap');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return self.$include($$('Completion'))
    })($nesting[0], $$('Hash'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Switch');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["short"] = $proto["long"] = $proto.pattern = nil;
      
      self.$attr_reader("pattern", "conv", "short", "long", "arg", "desc", "block");
      $defs(self, '$guess', function $$guess(arg) {
        var self = this, $ret_or_1 = nil, t = nil;

        
        if ($eqeqeq("", ($ret_or_1 = arg))) {
          t = self
        } else if ($eqeqeq(/^=?\[/, $ret_or_1)) {
          t = $$$($$('Switch'), 'OptionalArgument')
        } else if ($eqeqeq(/^\s+\[/, $ret_or_1)) {
          t = $$$($$('Switch'), 'PlacedArgument')
        } else {
          t = $$$($$('Switch'), 'RequiredArgument')
        };
        if ($truthy(($ret_or_1 = $rb_ge(self, t)))) {
          $ret_or_1
        } else {
          self.$incompatible_argument_styles(arg, t)
        };
        return t;
      });
      $defs(self, '$incompatible_argument_styles', function $$incompatible_argument_styles(arg, t) {
        var self = this;

        return self.$raise($$('ArgumentError'), "" + (arg) + ": incompatible argument styles\n  " + (self) + ", " + (t), $$('ParseError').$filter_backtrace(self.$caller(2)))
      });
      $defs(self, '$pattern', function $$pattern() {
        
        return $$('NilClass')
      });
      
      $def(self, '$initialize', function $$initialize(pattern, conv, short$, long$, arg, desc, block) {
        var _block = $$initialize.$$p || nil, $a, self = this, $ret_or_1 = nil;

        $$initialize.$$p = null;
        
        ;
        if (pattern == null) pattern = nil;
        if (conv == null) conv = nil;
        if (short$ == null) short$ = nil;
        if (long$ == null) long$ = nil;
        if (arg == null) arg = nil;
        if (desc == null) desc = (($truthy(short$) || ($truthy(long$))) ? ([]) : nil);
        if (block == null) block = nil;
        if ($eqeqeq($$('Array'), pattern)) {
          self.$raise()
        };
        block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : (_block));
        return $a = [pattern, conv, short$, long$, arg, desc, block], (self.pattern = $a[0]), (self.conv = $a[1]), (self["short"] = $a[2]), (self["long"] = $a[3]), (self.arg = $a[4]), (self.desc = $a[5]), (self.block = $a[6]), $a;
      }, -1);
      
      $def(self, '$parse_arg', function $$parse_arg(arg) {
        var $yield = $$parse_arg.$$p || nil, self = this, $ret_or_1 = nil, m = nil, s = nil;

        $$parse_arg.$$p = null;
        
        if ($truthy(($ret_or_1 = self.$pattern()))) {
          $ret_or_1
        } else {
          
          return [nil, [arg]];
        };
        if (!$truthy((m = self.$pattern().$match(arg)))) {
          
          Opal.yieldX($yield, [$$('InvalidArgument'), arg]);
          return [arg, []];
        };
        if ($eqeqeq($$('String'), m)) {
          m = [(s = m)]
        } else {
          
          m = m.$to_a();
          s = m['$[]'](0);
          if (!$eqeqeq($$('String'), s)) {
            return [nil, m]
          };
        };
        if (!$truthy(arg.$rindex(s, 0))) {
          self.$raise($$('InvalidArgument'), arg)
        };
        if ($eqeq(s.$length(), arg.$length())) {
          return [nil, m]
        };
        Opal.yieldX($yield, [$$('InvalidArgument'), arg]);
        return [arg['$[]'](Opal.Range.$new(s.$length(), -1, false)), m];
      });
      self.$private("parse_arg");
      
      $def(self, '$conv_arg', function $$conv_arg(arg, val) {
        var self = this;

        
        if (val == null) val = [];
        if ($truthy(self.$conv())) {
          val = $send(self.$conv(), 'call', $to_a(val))
        } else {
          val = $send($send(self, 'proc', [], function $$4(v){
            
            if (v == null) v = nil;
            return v;}), 'call', $to_a(val))
        };
        return [arg, self.$block(), val];
      }, -2);
      self.$private("conv_arg");
      
      $def(self, '$summarize', function $$summarize(sdone, ldone, width, max, indent) {
        var $a, $yield = $$summarize.$$p || nil, self = this, sopts = nil, lopts = nil, left = nil, right = nil, s = nil, l = nil, $ret_or_1 = nil, $ret_or_2 = nil, mlen = nil, r = nil;

        $$summarize.$$p = null;
        
        if (sdone == null) sdone = (new Map());
        if (ldone == null) ldone = (new Map());
        if (width == null) width = 1;
        if (max == null) max = $rb_minus(width, 1);
        if (indent == null) indent = "";
        $a = [[], [], nil], (sopts = $a[0]), (lopts = $a[1]), $a;
        if ($truthy(self["short"])) {
          $send(self["short"], 'each', [], function $$5(s){var $b;

            
            if (s == null) s = nil;
            $send(sdone, 'fetch', [s], function $$6(){
              return sopts['$<<'](s)});
            return ($b = [s, true], $send(sdone, '[]=', $b), $b[$b.length - 1]);})
        };
        if ($truthy(self["long"])) {
          $send(self["long"], 'each', [], function $$7(s){var $b;

            
            if (s == null) s = nil;
            $send(ldone, 'fetch', [s], function $$8(){
              return lopts['$<<'](s)});
            return ($b = [s, true], $send(ldone, '[]=', $b), $b[$b.length - 1]);})
        };
        if (($truthy(sopts['$empty?']()) && ($truthy(lopts['$empty?']())))) {
          return nil
        };
        left = [sopts.$join(", ")];
        right = self.$desc().$dup();
        while ($truthy((s = lopts.$shift()))) {
        
          l = $rb_plus(left['$[]'](-1).$length(), s.$length());
          if (($eqeq(left.$size(), 1) && ($truthy(self.$arg())))) {
            l = $rb_plus(l, self.$arg().$length())
          };
          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $rb_lt(l, max))) ? ($ret_or_2) : (sopts['$empty?']()))))) {
            $ret_or_1
          } else {
            left['$<<'](""['$+@']())
          };
          left['$[]='](-1, $rb_plus(left['$[]'](-1), $rb_plus(($truthy(left['$[]'](-1)['$empty?']()) ? ($rb_times(" ", 4)) : (", ")), s)));
        };
        if ($truthy(self.$arg())) {
          left['$[]='](0, $rb_plus(left['$[]'](0), ($truthy(left['$[]'](1)) ? ($rb_plus(self.$arg().$sub(/^(\[?)=/, "\\1"), ",")) : (self.$arg()))))
        };
        mlen = $send(left, 'collect', [], "length".$to_proc()).$max().$to_i();
        while ($truthy(($truthy(($ret_or_1 = $rb_gt(mlen, width))) ? ((l = left.$shift())) : ($ret_or_1)))) {
        
          if ($eqeq(l.$length(), mlen)) {
            mlen = $send(left, 'collect', [], "length".$to_proc()).$max().$to_i()
          };
          if ((($truthy($rb_lt(l.$length(), width)) && ($truthy((r = right['$[]'](0))))) && ($not(r['$empty?']())))) {
            
            l = $rb_plus($rb_plus(l.$to_s().$ljust(width), " "), r);
            right.$shift();
          };
          Opal.yield1($yield, $rb_plus(indent, l));
        };
        while ($truthy(((l = left.$shift()), (r = right.$shift()), ($truthy(($ret_or_1 = l)) ? ($ret_or_1) : (r))))) {
        
          if (($truthy(r) && ($not(r['$empty?']())))) {
            l = $rb_plus($rb_plus(l.$to_s().$ljust(width), " "), r)
          };
          Opal.yield1($yield, $rb_plus(indent, l));
        };
        return self;
      }, -1);
      
      $def(self, '$add_banner', function $$add_banner(to) {
        var self = this, s = nil;

        
        if (!($truthy(self["short"]) || ($truthy(self["long"])))) {
          
          s = self.$desc().$join();
          if (!$truthy(s['$empty?']())) {
            to['$<<']($rb_plus($rb_plus(" [", s), "]..."))
          };
        };
        return to;
      });
      
      $def(self, '$match_nonswitch?', function $Switch_match_nonswitch$ques$9(str) {
        var self = this;

        if (($truthy(self["short"]) || ($truthy(self["long"])))) {
          return nil
        } else {
          return self.pattern['$=~'](str)
        }
      });
      
      $def(self, '$switch_name', function $$switch_name() {
        var self = this, $ret_or_1 = nil;

        return ($truthy(($ret_or_1 = self.$long().$first())) ? ($ret_or_1) : (self.$short().$first())).$sub(/^-+(?:\[no-\])?/, "")
      });
      
      $def(self, '$compsys', function $$compsys(sdone, ldone) {
        var $a, $yield = $$compsys.$$p || nil, self = this, sopts = nil, lopts = nil;

        $$compsys.$$p = null;
        
        $a = [[], []], (sopts = $a[0]), (lopts = $a[1]), $a;
        if ($truthy(self["short"])) {
          $send(self["short"], 'each', [], function $$10(s){var $b;

            
            if (s == null) s = nil;
            $send(sdone, 'fetch', [s], function $$11(){
              return sopts['$<<'](s)});
            return ($b = [s, true], $send(sdone, '[]=', $b), $b[$b.length - 1]);})
        };
        if ($truthy(self["long"])) {
          $send(self["long"], 'each', [], function $$12(s){var $b;

            
            if (s == null) s = nil;
            $send(ldone, 'fetch', [s], function $$13(){
              return lopts['$<<'](s)});
            return ($b = [s, true], $send(ldone, '[]=', $b), $b[$b.length - 1]);})
        };
        if (($truthy(sopts['$empty?']()) && ($truthy(lopts['$empty?']())))) {
          return nil
        };
        return $send($rb_plus(sopts, lopts), 'each', [], function $$14(opt){var self = $$14.$$s == null ? this : $$14.$$s, o = nil;

          
          if (opt == null) opt = nil;
          if ($truthy(/^--\[no-\](.+)$/['$=~'](opt))) {
            
            o = $$('Regexp').$last_match(1);
            Opal.yieldX($yield, ["--" + (o), self.$desc().$join("")]);
            return Opal.yieldX($yield, ["--no-" + (o), self.$desc().$join("")]);;
          } else {
            return Opal.yieldX($yield, [opt.$to_s(), self.$desc().$join("")]);
          };}, {$$s: self});
      });
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NoArgument');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$parse', function $$parse(arg, argv) {
          var $yield = $$parse.$$p || nil, self = this;

          $$parse.$$p = null;
          
          if ($truthy(arg)) {
            Opal.yieldX($yield, [$$('NeedlessArgument'), arg])
          };
          return self.$conv_arg(arg);
        });
        $defs(self, '$incompatible_argument_styles', function $$incompatible_argument_styles($a) {
          var $post_args, $fwd_rest;

          
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          return nil;
        }, -1);
        return $defs(self, '$pattern', function $$pattern() {
          
          return $$('Object')
        });
      })($nesting[0], self, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'RequiredArgument');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $def(self, '$parse', function $$parse(arg, argv) {
          var self = this;

          
          if (!$truthy(arg)) {
            
            if ($truthy(argv['$empty?']())) {
              self.$raise($$('MissingArgument'))
            };
            arg = argv.$shift();
          };
          return $send(self, 'conv_arg', $to_a($send(self, 'parse_arg', [arg], self.$method("raise").$to_proc())));
        })
      })($nesting[0], self, $nesting);
      (function($base, $super) {
        var self = $klass($base, $super, 'OptionalArgument');

        
        return $def(self, '$parse', function $$parse(arg, argv) {
          var error = $$parse.$$p || nil, self = this;

          $$parse.$$p = null;
          
          ;
          if ($truthy(arg)) {
            return $send(self, 'conv_arg', $to_a($send(self, 'parse_arg', [arg], error.$to_proc())))
          } else {
            return self.$conv_arg(arg)
          };
        })
      })($nesting[0], self);
      return (function($base, $super) {
        var self = $klass($base, $super, 'PlacedArgument');

        
        return $def(self, '$parse', function $$parse(arg, argv) {
          var error = $$parse.$$p || nil, self = this, val = nil, opt = nil;

          $$parse.$$p = null;
          
          ;
          if (($not((val = arg)) && (($truthy(argv['$empty?']()) || ($truthy(/^-/['$=~']((val = argv['$[]'](0))))))))) {
            return [nil, self.$block(), nil]
          };
          opt = (val = $send(self, 'parse_arg', [val], error.$to_proc()))['$[]'](1);
          val = $send(self, 'conv_arg', $to_a(val));
          if (($truthy(opt) && ($not(arg)))) {
            argv.$shift()
          } else {
            val['$[]='](0, nil)
          };
          return val;
        })
      })($nesting[0], self);
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'List');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.atype = $proto["short"] = $proto["long"] = $proto.list = nil;
      
      self.$attr_reader("atype");
      self.$attr_reader("short");
      self.$attr_reader("long");
      self.$attr_reader("list");
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.atype = (new Map());
        self["short"] = $$('OptionMap').$new();
        self["long"] = $$('OptionMap').$new();
        return (self.list = []);
      });
      
      $def(self, '$accept', function $$accept(t, pat) {
        var block = $$accept.$$p || nil, $a, self = this, $ret_or_1 = nil;

        $$accept.$$p = null;
        
        ;
        if (pat == null) pat = /.*/m;
        if ($truthy(pat)) {
          if ($truthy(($ret_or_1 = pat['$respond_to?']("match")))) {
            $ret_or_1
          } else {
            self.$raise($$('TypeError'), "has no `match'", $$('ParseError').$filter_backtrace(self.$caller(2)))
          }
        } else if ($truthy(t['$respond_to?']("match"))) {
          pat = t
        };
        if (!$truthy(block)) {
          if ($truthy(pat['$respond_to?']("convert"))) {
            block = pat.$method("convert").$to_proc()
          }
        };
        return ($a = [t, [pat, block]], $send(self.atype, '[]=', $a), $a[$a.length - 1]);
      }, -2);
      
      $def(self, '$reject', function $$reject(t) {
        var self = this;

        return self.atype.$delete(t)
      });
      
      $def(self, '$update', function $$update(sw, sopts, lopts, nsw, nlopts) {
        var self = this, used = nil;

        
        if (nsw == null) nsw = nil;
        if (nlopts == null) nlopts = nil;
        if ($truthy(sopts)) {
          $send(sopts, 'each', [], function $$15(o){var $a, self = $$15.$$s == null ? this : $$15.$$s;
            if (self["short"] == null) self["short"] = nil;

            
            if (o == null) o = nil;
            return ($a = [o, sw], $send(self["short"], '[]=', $a), $a[$a.length - 1]);}, {$$s: self})
        };
        if ($truthy(lopts)) {
          $send(lopts, 'each', [], function $$16(o){var $a, self = $$16.$$s == null ? this : $$16.$$s;
            if (self["long"] == null) self["long"] = nil;

            
            if (o == null) o = nil;
            return ($a = [o, sw], $send(self["long"], '[]=', $a), $a[$a.length - 1]);}, {$$s: self})
        };
        if (($truthy(nsw) && ($truthy(nlopts)))) {
          $send(nlopts, 'each', [], function $$17(o){var $a, self = $$17.$$s == null ? this : $$17.$$s;
            if (self["long"] == null) self["long"] = nil;

            
            if (o == null) o = nil;
            return ($a = [o, nsw], $send(self["long"], '[]=', $a), $a[$a.length - 1]);}, {$$s: self})
        };
        used = self["short"].$invert().$update(self["long"].$invert());
        return $send(self.list, 'delete_if', [], function $$18(o){var $ret_or_1 = nil;

          
          if (o == null) o = nil;
          if ($truthy(($ret_or_1 = $$('Switch')['$==='](o)))) {
            return used['$[]'](o)['$!']()
          } else {
            return $ret_or_1
          };});
      }, -4);
      self.$private("update");
      
      $def(self, '$prepend', function $$prepend($a) {
        var $post_args, args, self = this;

        
        $post_args = $slice(arguments);
        args = $post_args;
        $send(self, 'update', $to_a(args));
        return self.list.$unshift(args['$[]'](0));
      }, -1);
      
      $def(self, '$append', function $$append($a) {
        var $post_args, args, self = this;

        
        $post_args = $slice(arguments);
        args = $post_args;
        $send(self, 'update', $to_a(args));
        return self.list.$push(args['$[]'](0));
      }, -1);
      
      $def(self, '$search', function $$search(id, key) {try { var $t_return = $thrower('return'); 
        var $yield = $$search.$$p || nil, self = this, list = nil, val = nil;

        $$search.$$p = null;
        if ($truthy((list = self.$__send__(id)))) {
          
          val = $send(list, 'fetch', [key], function $$19(){
            $t_return.$throw(nil, $$19.$$is_lambda)}, {$$ret: $t_return});
          if (($yield !== nil)) {
            return Opal.yield1($yield, val);
          } else {
            return val
          };
        } else {
          return nil
        }} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        } finally {$t_return.is_orphan = true;}
      });
      
      $def(self, '$complete', function $$complete(id, opt, $a, $b) {
        var block = $$complete.$$p || nil, $post_args, icase, pat, self = this;

        $$complete.$$p = null;
        
        ;
        $post_args = $slice(arguments, 2);
        
        if ($post_args.length > 0) icase = $post_args.shift();if (icase == null) icase = false;
        pat = $post_args;
        return $send(self.$__send__(id), 'complete', [opt, icase].concat($to_a(pat)), block.$to_proc());
      }, -3);
      
      $def(self, '$get_candidates', function $$get_candidates(id) {
        var $yield = $$get_candidates.$$p || nil, self = this;

        $$get_candidates.$$p = null;
        return Opal.yield1($yield, self.$__send__(id).$keys());
      });
      
      $def(self, '$each_option', function $$each_option() {
        var block = $$each_option.$$p || nil, self = this;

        $$each_option.$$p = null;
        
        ;
        return $send(self.$list(), 'each', [], block.$to_proc());
      });
      
      $def(self, '$summarize', function $$summarize($a) {
        var block = $$summarize.$$p || nil, $post_args, args, self = this, sum = nil;

        $$summarize.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        sum = [];
        $send(self.$list(), 'reverse_each', [], function $$20(opt){var s = nil;

          
          if (opt == null) opt = nil;
          if ($truthy(opt['$respond_to?']("summarize"))) {
            
            s = [];
            $send(opt, 'summarize', $to_a(args), function $$21(l){
              
              if (l == null) l = nil;
              return s['$<<'](l);});
            return sum.$concat(s.$reverse());
          } else if (($not(opt) || ($truthy(opt['$empty?']())))) {
            return sum['$<<']("")
          } else if ($truthy(opt['$respond_to?']("each_line"))) {
            return sum.$concat([].concat($to_a(opt.$each_line())).$reverse())
          } else {
            return sum.$concat([].concat($to_a(opt.$each())).$reverse())
          };});
        return $send(sum, 'reverse_each', [], block.$to_proc());
      }, -1);
      
      $def(self, '$add_banner', function $$add_banner(to) {
        var self = this;

        
        $send(self.$list(), 'each', [], function $$22(opt){
          
          if (opt == null) opt = nil;
          if ($truthy(opt['$respond_to?']("add_banner"))) {
            return opt.$add_banner(to)
          } else {
            return nil
          };});
        return to;
      });
      return $def(self, '$compsys', function $$compsys($a) {
        var block = $$compsys.$$p || nil, $post_args, args, self = this;

        $$compsys.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self.$list(), 'each', [], function $$23(opt){
          
          if (opt == null) opt = nil;
          if ($truthy(opt['$respond_to?']("compsys"))) {
            return $send(opt, 'compsys', $to_a(args), block.$to_proc())
          } else {
            return nil
          };});
      }, -1);
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompletingHash');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$('Completion'));
      return $def(self, '$match', function $$match(key) {try { var $t_return = $thrower('return'); 
        var $a, $b, self = this, values = nil;

        
        $b = $send(self, 'fetch', [key], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$raise($$('AmbiguousArgument'), $send(self, 'catch', ["ambiguous"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

            $t_return.$throw(self.$complete(key), $$25.$$is_lambda)}, {$$s: self, $$ret: $t_return}))}, {$$s: self}), $a = $to_ary($b), (values = $slice($a, 0)), $b;
        return [key].concat($to_a(values));} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        } finally {$t_return.is_orphan = true;}
      });
    })($nesting[0], $$('Hash'), $nesting);
    $const_set($nesting[0], 'ArgumentStyle', (new Map()));
    $send($$('NoArgument'), 'each', [], function $OptionParser$26(el){var $a;

      
      if (el == null) el = nil;
      return ($a = [el, $$$($$('Switch'), 'NoArgument')], $send($$('ArgumentStyle'), '[]=', $a), $a[$a.length - 1]);});
    $send($$('RequiredArgument'), 'each', [], function $OptionParser$27(el){var $a;

      
      if (el == null) el = nil;
      return ($a = [el, $$$($$('Switch'), 'RequiredArgument')], $send($$('ArgumentStyle'), '[]=', $a), $a[$a.length - 1]);});
    $send($$('OptionalArgument'), 'each', [], function $OptionParser$28(el){var $a;

      
      if (el == null) el = nil;
      return ($a = [el, $$$($$('Switch'), 'OptionalArgument')], $send($$('ArgumentStyle'), '[]=', $a), $a[$a.length - 1]);});
    $$('ArgumentStyle').$freeze();
    $const_set($nesting[0], 'DefaultList', $$('List').$new());
    $$('DefaultList').$short()['$[]=']("-", $send($$$($$('Switch'), 'NoArgument'), 'new', [], $return_val(nil)));
    $$('DefaultList').$long()['$[]=']("", $send($$$($$('Switch'), 'NoArgument'), 'new', [], function $OptionParser$29(){var self = $OptionParser$29.$$s == null ? this : $OptionParser$29.$$s;

      return self.$throw("terminate")}, {$$s: self}));
    $const_set($nesting[0], 'COMPSYS_HEADER', "\n" + "typeset -A opt_args\n" + "local context state line\n" + "\n" + "_arguments -s -S \\\n");
    
    $def(self, '$compsys', function $$compsys(to, name) {
      var self = this;
      if ($gvars["0"] == null) $gvars["0"] = nil;

      
      if (name == null) name = $$('File').$basename($gvars["0"]);
      to['$<<']("#compdef " + (name) + "\n");
      to['$<<']($$('COMPSYS_HEADER'));
      $send(self, 'visit', ["compsys", (new Map()), (new Map())], function $$30(o, d){
        
        if (o == null) o = nil;
        if (d == null) d = nil;
        return to['$<<']("  \"" + (o) + "[" + (d.$gsub(/[\"\[\]]/, "\\\\\\&")) + "]\" \\\n");});
      return to['$<<']("  '*:file:_files' && return 0\n");
    }, -2);
    $const_set($nesting[0], 'Officious', (new Map()));
    $$('Officious')['$[]=']("help", $send(self, 'proc', [], function $OptionParser$31(parser){var self = $OptionParser$31.$$s == null ? this : $OptionParser$31.$$s;

      
      if (parser == null) parser = nil;
      return $send($$$($$('Switch'), 'NoArgument'), 'new', [], function $$32(arg){var self = $$32.$$s == null ? this : $$32.$$s;

        
        if (arg == null) arg = nil;
        self.$puts(parser.$help());
        return self.$exit();}, {$$s: self});}, {$$s: self}));
    $$('Officious')['$[]=']("*-completion-bash", $send(self, 'proc', [], function $OptionParser$33(parser){var self = $OptionParser$33.$$s == null ? this : $OptionParser$33.$$s;

      
      if (parser == null) parser = nil;
      return $send($$$($$('Switch'), 'RequiredArgument'), 'new', [], function $$34(arg){var self = $$34.$$s == null ? this : $$34.$$s;

        
        if (arg == null) arg = nil;
        self.$puts(parser.$candidate(arg));
        return self.$exit();}, {$$s: self});}, {$$s: self}));
    $$('Officious')['$[]=']("*-completion-zsh", $send(self, 'proc', [], function $OptionParser$35(parser){var self = $OptionParser$35.$$s == null ? this : $OptionParser$35.$$s;

      
      if (parser == null) parser = nil;
      return $send($$$($$('Switch'), 'OptionalArgument'), 'new', [], function $$36(arg){var self = $$36.$$s == null ? this : $$36.$$s;

        
        if (arg == null) arg = nil;
        parser.$compsys($$('STDOUT'), arg);
        return self.$exit();}, {$$s: self});}, {$$s: self}));
    $$('Officious')['$[]=']("version", $send(self, 'proc', [], function $OptionParser$37(parser){var self = $OptionParser$37.$$s == null ? this : $OptionParser$37.$$s;

      
      if (parser == null) parser = nil;
      return $send($$$($$('Switch'), 'OptionalArgument'), 'new', [], function $$38(pkg){var self = $$38.$$s == null ? this : $$38.$$s, $ret_or_1 = nil, v = nil;

        
        if (pkg == null) pkg = nil;
        if ($truthy(pkg)) {
          
          
          var $no_errors = true;try {
            self.$require("optparse/version")
          } catch ($err) {
            $no_errors = false;
            if (Opal.rescue($err, [$$('LoadError')])) {
              try {
                nil
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          }finally {
            if ($no_errors) { 
              
              if ($truthy(($ret_or_1 = $send(self, 'show_version', $to_a(pkg.$split(/,/)))))) {
                $ret_or_1
              } else {
                self.$abort("" + (parser.$program_name()) + ": no version found in package " + (pkg))
              };
              self.$exit();
            }};
        };
        if ($truthy(($ret_or_1 = (v = parser.$ver())))) {
          $ret_or_1
        } else {
          self.$abort("" + (parser.$program_name()) + ": version unknown")
        };
        self.$puts(v);
        return self.$exit();}, {$$s: self});}, {$$s: self}));
    $defs(self, '$with', function $OptionParser_with$39($a) {
      var block = $OptionParser_with$39.$$p || nil, $post_args, args, self = this, opts = nil;

      $OptionParser_with$39.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      opts = $send(self, 'new', $to_a(args));
      $send(opts, 'instance_eval', [], block.$to_proc());
      return opts;
    }, -1);
    $defs(self, '$inc', function $$inc(arg, default$) {
      var $ret_or_1 = nil;

      
      if (default$ == null) default$ = nil;
      if ($eqeqeq($$('Integer'), ($ret_or_1 = arg))) {
        return arg['$nonzero?']()
      } else if ($eqeqeq(nil, $ret_or_1)) {
        return $rb_plus(default$.$to_i(), 1)
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$inc', function $$inc($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self.$class(), 'inc', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize(banner, width, indent) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (banner == null) banner = nil;
      if (width == null) width = 32;
      if (indent == null) indent = $rb_times(" ", 4);
      self.stack = [$$('DefaultList'), $$('List').$new(), $$('List').$new()];
      self.program_name = nil;
      self.banner = banner;
      self.summary_width = width;
      self.summary_indent = indent;
      self.default_argv = $$('ARGV');
      self.require_exact = false;
      self.$add_officious();
      if (($yield !== nil)) {
        return Opal.yield1($yield, self);
      } else {
        return nil
      };
    }, -1);
    
    $def(self, '$add_officious', function $$add_officious() {
      var self = this, list = nil;

      
      list = self.$base();
      return $send($$('Officious'), 'each', [], function $$40(opt, block){var $a, self = $$40.$$s == null ? this : $$40.$$s, $logical_op_recvr_tmp_1 = nil, $ret_or_1 = nil;

        
        if (opt == null) opt = nil;
        if (block == null) block = nil;
        $logical_op_recvr_tmp_1 = list.$long();
        if ($truthy(($ret_or_1 = $logical_op_recvr_tmp_1['$[]'](opt)))) {
          return $ret_or_1
        } else {
          return ($a = [opt, block.$call(self)], $send($logical_op_recvr_tmp_1, '[]=', $a), $a[$a.length - 1])
        };}, {$$s: self});
    });
    
    $def(self, '$terminate', function $$terminate(arg) {
      var self = this;

      
      if (arg == null) arg = nil;
      return self.$class().$terminate(arg);
    }, -1);
    $defs(self, '$terminate', function $$terminate(arg) {
      var self = this;

      
      if (arg == null) arg = nil;
      return self.$throw("terminate", arg);
    }, -1);
    self.stack = [$$('DefaultList')];
    $defs(self, '$top', function $$top() {
      
      return $$('DefaultList')
    });
    
    $def(self, '$accept', function $$accept($a) {
      var blk = $$accept.$$p || nil, $post_args, args, self = this;

      $$accept.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self.$top(), 'accept', $to_a(args), blk.$to_proc());
    }, -1);
    $defs(self, '$accept', function $$accept($a) {
      var blk = $$accept.$$p || nil, $post_args, args, self = this;

      $$accept.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self.$top(), 'accept', $to_a(args), blk.$to_proc());
    }, -1);
    
    $def(self, '$reject', function $$reject($a) {
      var blk = $$reject.$$p || nil, $post_args, args, self = this;

      $$reject.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self.$top(), 'reject', $to_a(args), blk.$to_proc());
    }, -1);
    $defs(self, '$reject', function $$reject($a) {
      var blk = $$reject.$$p || nil, $post_args, args, self = this;

      $$reject.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self.$top(), 'reject', $to_a(args), blk.$to_proc());
    }, -1);
    self.$attr_writer("banner");
    self.$attr_writer("program_name");
    self.$attr_accessor("summary_width");
    self.$attr_accessor("summary_indent");
    self.$attr_accessor("default_argv");
    self.$attr_accessor("require_exact");
    
    $def(self, '$banner', function $$banner() {
      var self = this;

      
      if (!$truthy(self.banner)) {
        
        self.banner = ((("Usage: ") + (self.$program_name())) + " [options]")['$+@']();
        self.$visit("add_banner", self.banner);
      };
      return self.banner;
    });
    
    $def(self, '$program_name', function $$program_name() {
      var self = this, $ret_or_1 = nil;
      if ($gvars["0"] == null) $gvars["0"] = nil;

      if ($truthy(($ret_or_1 = self.program_name))) {
        return $ret_or_1
      } else {
        return $$('File').$basename($gvars["0"], ".*")
      }
    });
    $alias(self, "set_banner", "banner=");
    $alias(self, "set_program_name", "program_name=");
    $alias(self, "set_summary_width", "summary_width=");
    $alias(self, "set_summary_indent", "summary_indent=");
    self.$attr_writer("version");
    self.$attr_writer("release");
    
    $def(self, '$version', function $$version() {
      var $a, $b, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = (($a = self['version'], $a != null && $a !== nil) ? 'instance-variable' : nil))) ? (self.version) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        
        if ($truthy(($ret_or_2 = (($b = $$$('::', 'Version', 'skip_raise')) ? 'constant' : nil)))) {
          return $$$('Version')
        } else {
          return $ret_or_2
        };
      }
    });
    
    $def(self, '$release', function $$release() {
      var $a, $b, $c, self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = (($a = self['release'], $a != null && $a !== nil) ? 'instance-variable' : nil))) ? (self.release) : ($ret_or_3)))) ? ($ret_or_2) : (($truthy(($ret_or_3 = (($b = $$$('::', 'Release', 'skip_raise')) ? 'constant' : nil))) ? ($$$('Release')) : ($ret_or_3))))))) {
        return $ret_or_1
      } else {
        
        if ($truthy(($ret_or_2 = (($c = $$$('::', 'RELEASE', 'skip_raise')) ? 'constant' : nil)))) {
          return $$$('RELEASE')
        } else {
          return $ret_or_2
        };
      }
    });
    
    $def(self, '$ver', function $$ver() {
      var self = this, v = nil, str = nil;

      if ($truthy((v = self.$version()))) {
        
        str = ((("" + (self.$program_name())) + " ") + ([v].$join(".")))['$+@']();
        if ($truthy((v = self.$release()))) {
          str['$<<'](" (" + (v) + ")")
        };
        return str;
      } else {
        return nil
      }
    });
    
    $def(self, '$warn', function $$warn(mesg) {
      var $yield = $$warn.$$p || nil, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      $$warn.$$p = null;
      
      if (mesg == null) mesg = $gvars["!"];
      return $send2(self, $find_super(self, 'warn', $$warn, false, true), 'warn', ["" + (self.$program_name()) + ": " + (mesg)], null);
    }, -1);
    
    $def(self, '$abort', function $$abort(mesg) {
      var $yield = $$abort.$$p || nil, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      $$abort.$$p = null;
      
      if (mesg == null) mesg = $gvars["!"];
      return $send2(self, $find_super(self, 'abort', $$abort, false, true), 'abort', ["" + (self.$program_name()) + ": " + (mesg)], null);
    }, -1);
    
    $def(self, '$top', function $$top() {
      var self = this;

      return self.stack['$[]'](-1)
    });
    
    $def(self, '$base', function $$base() {
      var self = this;

      return self.stack['$[]'](1)
    });
    
    $def(self, '$new', function $OptionParser_new$41() {
      var $yield = $OptionParser_new$41.$$p || nil, self = this;

      $OptionParser_new$41.$$p = null;
      
      self.stack.$push($$('List').$new());
      if (($yield !== nil)) {
        return Opal.yield1($yield, self);
      } else {
        return self
      };
    });
    
    $def(self, '$remove', function $$remove() {
      var self = this;

      return self.stack.$pop()
    });
    
    $def(self, '$summarize', function $$summarize(to, width, max, indent) {
      var blk = $$summarize.$$p || nil, self = this, nl = nil, $ret_or_1 = nil;

      $$summarize.$$p = null;
      
      ;
      if (to == null) to = [];
      if (width == null) width = self.summary_width;
      if (max == null) max = $rb_minus(width, 1);
      if (indent == null) indent = self.summary_indent;
      nl = "\n";
      blk = ($truthy(($ret_or_1 = blk)) ? ($ret_or_1) : ($send(self, 'proc', [], function $$42(l){
        
        if (l == null) l = nil;
        return to['$<<'](($truthy(l.$index(nl, -1)) ? (l) : ($rb_plus(l, nl))));})));
      $send(self, 'visit', ["summarize", (new Map()), (new Map()), width, max, indent], blk.$to_proc());
      return to;
    }, -1);
    
    $def(self, '$help', function $$help() {
      var self = this;

      return self.$summarize([self.$banner().$to_s().$sub(/\n?$/, "\n")]).$join()
    });
    $alias(self, "to_s", "help");
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return self.$summarize([self.$banner().$to_s().$split(/^/)]).$join()
    });
    
    $def(self, '$notwice', function $$notwice(obj, prv, msg) {
      var self = this;

      
      if (!($not(prv) || ($eqeq(prv, obj)))) {
        self.$raise($$('ArgumentError'), "argument " + (msg) + " given twice: " + (obj), $$('ParseError').$filter_backtrace(self.$caller(2)))
      };
      return obj;
    });
    self.$private("notwice");
    $const_set($nesting[0], 'SPLAT_PROC', $send(self, 'proc', [], function $OptionParser$43($a){var $post_args, a;

      
      $post_args = $slice(arguments);
      a = $post_args;
      if ($truthy($rb_le(a.$length(), 1))) {
        return a.$first()
      } else {
        return a
      };}, -1));
    
    $def(self, '$make_switch', function $$make_switch(opts, block) {
      var $a, $b, self = this, short$ = nil, long$ = nil, nolong = nil, style = nil, pattern = nil, conv = nil, not_pattern = nil, not_conv = nil, not_style = nil, ldesc = nil, sdesc = nil, desc = nil, arg = nil, default_style = nil, default_pattern = nil, klass = nil, q = nil, a = nil, has_arg = nil, $ret_or_2 = nil, s = nil;

      
      if (block == null) block = nil;
      $a = [[], [], []], (short$ = $a[0]), (long$ = $a[1]), (nolong = $a[2]), (style = ($a[3] == null ? nil : $a[3])), (pattern = ($a[4] == null ? nil : $a[4])), (conv = ($a[5] == null ? nil : $a[5])), (not_pattern = ($a[6] == null ? nil : $a[6])), (not_conv = ($a[7] == null ? nil : $a[7])), (not_style = ($a[8] == null ? nil : $a[8])), $a;
      $a = [[], [], []], (ldesc = $a[0]), (sdesc = $a[1]), (desc = $a[2]), (arg = ($a[3] == null ? nil : $a[3])), $a;
      default_style = $$$($$('Switch'), 'NoArgument');
      default_pattern = nil;
      klass = nil;
      $b = nil, $a = $to_ary($b), (q = ($a[0] == null ? nil : $a[0])), (a = ($a[1] == null ? nil : $a[1])), $b;
      has_arg = false;
      $send(opts, 'each', [], function $$44(o){var $c, $d, self = $$44.$$s == null ? this : $$44.$$s, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

        
        if (o == null) o = nil;
        if ($truthy($send(self, 'search', ["atype", o], function $$45(pat, c){var $c, self = $$45.$$s == null ? this : $$45.$$s;

          
          if (pat == null) pat = nil;
          if (c == null) c = nil;
          klass = self.$notwice(o, klass, "type");
          if (($truthy(not_style) && ($neqeq(not_style, $$$($$('Switch'), 'NoArgument'))))) {
            return $c = [pat, c], (not_pattern = $c[0]), (not_conv = $c[1]), $c
          } else {
            return $c = [pat, c], (default_pattern = $c[0]), (conv = $c[1]), $c
          };}, {$$s: self}))) {
          return nil
        };
        if (($not(($truthy(($ret_or_1 = $$('String')['$==='](o))) ? ($ret_or_1) : ($$('Symbol')['$==='](o)))) && ($truthy(o['$respond_to?']("match"))))) {
          
          pattern = self.$notwice(o, pattern, "pattern");
          if ($truthy(pattern['$respond_to?']("convert"))) {
            conv = pattern.$method("convert").$to_proc()
          } else {
            conv = $$('SPLAT_PROC')
          };
          return nil;
        };
        if (($eqeqeq($$('Proc'), ($ret_or_1 = o)) || ($eqeqeq($$('Method'), $ret_or_1)))) {
          return (block = self.$notwice(o, block, "block"))
        } else if (($eqeqeq($$('Array'), $ret_or_1) || ($eqeqeq($$('Hash'), $ret_or_1)))) {
          
          if (!$eqeqeq($$('CompletingHash'), ($ret_or_2 = pattern))) {
            if ($eqeqeq(nil, $ret_or_2)) {
              
              pattern = $$('CompletingHash').$new();
              if ($truthy(pattern['$respond_to?']("convert"))) {
                conv = pattern.$method("convert").$to_proc()
              };
            } else {
              self.$raise($$('ArgumentError'), "argument pattern given twice")
            }
          };
          return $send(o, 'each', [], function $$46(pat, $c){var $post_args, v, $d;

            
            if (pat == null) pat = nil;
            $post_args = $slice(arguments, 1);
            v = $post_args;
            return ($d = [pat, $send(v, 'fetch', [0], function $$47(){
              return pat})], $send(pattern, '[]=', $d), $d[$d.length - 1]);}, -2);
        } else if ($eqeqeq($$('Module'), $ret_or_1)) {
          return self.$raise($$('ArgumentError'), "unsupported argument type: " + (o), $$('ParseError').$filter_backtrace(self.$caller(4)))
        } else if ($truthy($send($$('ArgumentStyle').$keys(), 'any?', [], function $$48($ret_or_2){
          
          if ($ret_or_2 == null) $ret_or_2 = nil;
          return $ret_or_2['$===']($ret_or_1);}))) {
          return (style = self.$notwice($$('ArgumentStyle')['$[]'](o), style, "style"))
        } else if ($eqeqeq(/^--no-([^\[\]=\s]*)(.+)?/, $ret_or_1)) {
          
          $c = [$$('Regexp').$last_match(1), $$('Regexp').$last_match(2)], (q = $c[0]), (a = $c[1]), $c;
          o = self.$notwice(($truthy(a) ? ($$('Object')) : ($$('TrueClass'))), klass, "type");
          if (!$truthy(not_style)) {
            $d = self.$search("atype", o), $c = $to_ary($d), (not_pattern = ($c[0] == null ? nil : $c[0])), (not_conv = ($c[1] == null ? nil : $c[1])), $d
          };
          if ($truthy(a)) {
            not_style = ($truthy(($ret_or_3 = not_style)) ? ($ret_or_3) : (default_style)).$guess((arg = a))
          };
          default_style = $$$($$('Switch'), 'NoArgument');
          if (!$truthy(default_pattern)) {
            $d = self.$search("atype", $$('FalseClass')), $c = $to_ary($d), (default_pattern = ($c[0] == null ? nil : $c[0])), (conv = ($c[1] == null ? nil : $c[1])), $d
          };
          ldesc['$<<']("--no-" + (q));
          q = q.$downcase().$tr("_", "-");
          long$['$<<']("no-" + (q));
          return nolong['$<<'](q);
        } else if ($eqeqeq(/^--\[no-\]([^\[\]=\s]*)(.+)?/, $ret_or_1)) {
          
          $c = [$$('Regexp').$last_match(1), $$('Regexp').$last_match(2)], (q = $c[0]), (a = $c[1]), $c;
          o = self.$notwice(($truthy(a) ? ($$('Object')) : ($$('TrueClass'))), klass, "type");
          if ($truthy(a)) {
            
            default_style = default_style.$guess((arg = a));
            if (!$truthy(default_pattern)) {
              $d = self.$search("atype", o), $c = $to_ary($d), (default_pattern = ($c[0] == null ? nil : $c[0])), (conv = ($c[1] == null ? nil : $c[1])), $d
            };
          };
          ldesc['$<<']("--[no-]" + (q));
          o = q.$downcase().$tr("_", "-");
          long$['$<<'](o);
          if (!$truthy(not_style)) {
            $d = self.$search("atype", $$('FalseClass')), $c = $to_ary($d), (not_pattern = ($c[0] == null ? nil : $c[0])), (not_conv = ($c[1] == null ? nil : $c[1])), $d
          };
          not_style = $$$($$('Switch'), 'NoArgument');
          return nolong['$<<']("no-" + (o));
        } else if ($eqeqeq(/^--([^\[\]=\s]*)(.+)?/, $ret_or_1)) {
          
          $c = [$$('Regexp').$last_match(1), $$('Regexp').$last_match(2)], (q = $c[0]), (a = $c[1]), $c;
          if ($truthy(a)) {
            
            o = self.$notwice($$('NilClass'), klass, "type");
            default_style = default_style.$guess((arg = a));
            if (!$truthy(default_pattern)) {
              $d = self.$search("atype", o), $c = $to_ary($d), (default_pattern = ($c[0] == null ? nil : $c[0])), (conv = ($c[1] == null ? nil : $c[1])), $d
            };
          };
          ldesc['$<<']("--" + (q));
          o = q.$downcase().$tr("_", "-");
          return long$['$<<'](o);
        } else if ($eqeqeq(/^-(\[\^?\]?(?:[^\\\]]|\\.)*\])(.+)?/, $ret_or_1)) {
          
          $c = [$$('Regexp').$last_match(1), $$('Regexp').$last_match(2)], (q = $c[0]), (a = $c[1]), $c;
          o = self.$notwice($$('Object'), klass, "type");
          if ($truthy(a)) {
            
            default_style = default_style.$guess((arg = a));
            if (!$truthy(default_pattern)) {
              $d = self.$search("atype", o), $c = $to_ary($d), (default_pattern = ($c[0] == null ? nil : $c[0])), (conv = ($c[1] == null ? nil : $c[1])), $d
            };
          } else {
            has_arg = true
          };
          sdesc['$<<']("-" + (q));
          return short$['$<<']($$('Regexp').$new(q));
        } else if ($eqeqeq(/^-(.)(.+)?/, $ret_or_1)) {
          
          $c = [$$('Regexp').$last_match(1), $$('Regexp').$last_match(2)], (q = $c[0]), (a = $c[1]), $c;
          if ($truthy(a)) {
            
            o = self.$notwice($$('NilClass'), klass, "type");
            default_style = default_style.$guess((arg = a));
            if (!$truthy(default_pattern)) {
              $d = self.$search("atype", o), $c = $to_ary($d), (default_pattern = ($c[0] == null ? nil : $c[0])), (conv = ($c[1] == null ? nil : $c[1])), $d
            };
          };
          sdesc['$<<']("-" + (q));
          return short$['$<<'](q);
        } else if ($eqeqeq(/^=/, $ret_or_1)) {
          
          style = self.$notwice(default_style.$guess((arg = o)), style, "style");
          if ($truthy(default_pattern)) {
            return nil
          } else {
            return $d = self.$search("atype", $$('Object')), $c = $to_ary($d), (default_pattern = ($c[0] == null ? nil : $c[0])), (conv = ($c[1] == null ? nil : $c[1])), $d
          };
        } else {
          return desc.$push(o)
        };}, {$$s: self});
      if (!$truthy(default_pattern)) {
        $b = self.$search("atype", default_style.$pattern()), $a = $to_ary($b), (default_pattern = ($a[0] == null ? nil : $a[0])), (conv = ($a[1] == null ? nil : $a[1])), $b
      };
      if ($not(($truthy(($ret_or_2 = short$['$empty?']())) ? (long$['$empty?']()) : ($ret_or_2)))) {
        
        if (($truthy(has_arg) && ($eqeq(default_style, $$$($$('Switch'), 'NoArgument'))))) {
          default_style = $$$($$('Switch'), 'RequiredArgument')
        };
        s = ($truthy(($ret_or_2 = style)) ? ($ret_or_2) : (default_style)).$new(($truthy(($ret_or_2 = pattern)) ? ($ret_or_2) : (default_pattern)), conv, sdesc, ldesc, arg, desc, block);
      } else if ($not(block)) {
        
        if (($truthy(style) || ($truthy(pattern)))) {
          self.$raise($$('ArgumentError'), "no switch given", $$('ParseError').$filter_backtrace(self.$caller()))
        };
        s = desc;
      } else {
        
        short$['$<<'](pattern);
        s = ($truthy(($ret_or_2 = style)) ? ($ret_or_2) : (default_style)).$new(pattern, conv, nil, nil, arg, desc, block);
      };
      return [s, short$, long$, ($truthy(not_style) ? (not_style.$new(not_pattern, not_conv, sdesc, ldesc, nil, desc, block)) : nil), nolong];
    }, -2);
    
    $def(self, '$define', function $$define($a) {
      var block = $$define.$$p || nil, $post_args, opts, self = this, sw = nil;

      $$define.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      opts = $post_args;
      $send(self.$top(), 'append', $to_a((sw = self.$make_switch(opts, block))));
      return sw['$[]'](0);
    }, -1);
    
    $def(self, '$on', function $$on($a) {
      var block = $$on.$$p || nil, $post_args, opts, self = this;

      $$on.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      opts = $post_args;
      $send(self, 'define', $to_a(opts), block.$to_proc());
      return self;
    }, -1);
    $alias(self, "def_option", "define");
    
    $def(self, '$define_head', function $$define_head($a) {
      var block = $$define_head.$$p || nil, $post_args, opts, self = this, sw = nil;

      $$define_head.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      opts = $post_args;
      $send(self.$top(), 'prepend', $to_a((sw = self.$make_switch(opts, block))));
      return sw['$[]'](0);
    }, -1);
    
    $def(self, '$on_head', function $$on_head($a) {
      var block = $$on_head.$$p || nil, $post_args, opts, self = this;

      $$on_head.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      opts = $post_args;
      $send(self, 'define_head', $to_a(opts), block.$to_proc());
      return self;
    }, -1);
    $alias(self, "def_head_option", "define_head");
    
    $def(self, '$define_tail', function $$define_tail($a) {
      var block = $$define_tail.$$p || nil, $post_args, opts, self = this, sw = nil;

      $$define_tail.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      opts = $post_args;
      $send(self.$base(), 'append', $to_a((sw = self.$make_switch(opts, block))));
      return sw['$[]'](0);
    }, -1);
    
    $def(self, '$on_tail', function $$on_tail($a) {
      var block = $$on_tail.$$p || nil, $post_args, opts, self = this;

      $$on_tail.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      opts = $post_args;
      $send(self, 'define_tail', $to_a(opts), block.$to_proc());
      return self;
    }, -1);
    $alias(self, "def_tail_option", "define_tail");
    
    $def(self, '$separator', function $$separator(string) {
      var self = this;

      return self.$top().$append(string, nil, nil)
    });
    
    $def(self, '$order', function $$order($a, $b) {
      var nonopt = $$order.$$p || nil, $post_args, $kwargs, argv, into, self = this;

      $$order.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      argv = $post_args;
      
      into = $hash_get($kwargs, "into");if (into == null) into = nil;
      if (($eqeq(argv.$size(), 1) && ($eqeqeq($$('Array'), argv['$[]'](0))))) {
        argv = argv['$[]'](0).$dup()
      };
      return $send(self, 'order!', [argv, (new Map([["into", into]]))], nonopt.$to_proc());
    }, -1);
    
    $def(self, '$order!', function $OptionParser_order$excl$49($a, $b) {
      var nonopt = $OptionParser_order$excl$49.$$p || nil, $post_args, $kwargs, argv, into, self = this, setter = nil;

      $OptionParser_order$excl$49.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) argv = $post_args.shift();if (argv == null) argv = self.$default_argv();
      
      into = $hash_get($kwargs, "into");if (into == null) into = nil;
      if ($truthy(into)) {
        setter = $lambda(function $$50(name, val){var $c;

          
          if (name == null) name = nil;
          if (val == null) val = nil;
          return ($c = [name.$to_sym(), val], $send(into, '[]=', $c), $c[$c.length - 1]);})
      };
      return $send(self, 'parse_in_order', [argv, setter], nonopt.$to_proc());
    }, -1);
    
    $def(self, '$parse_in_order', function $$parse_in_order(argv, setter) {
      var nonopt = $$parse_in_order.$$p || nil, $a, $b, self = this, opt = nil, arg = nil, val = nil, rest = nil, $ret_or_2 = nil;

      $$parse_in_order.$$p = null;
      
      ;
      if (argv == null) argv = self.$default_argv();
      if (setter == null) setter = nil;
      $b = nil, $a = $to_ary($b), (opt = ($a[0] == null ? nil : $a[0])), (arg = ($a[1] == null ? nil : $a[1])), (val = ($a[2] == null ? nil : $a[2])), (rest = ($a[3] == null ? nil : $a[3])), $b;
      nonopt = ($truthy(($ret_or_2 = nonopt)) ? ($ret_or_2) : ($send(self, 'proc', [], function $$51(a){var self = $$51.$$s == null ? this : $$51.$$s;

        
        if (a == null) a = nil;
        return self.$throw("terminate", a);}, {$$s: self})));
      if ($truthy((arg = $send(self, 'catch', ["terminate"], function $$52(){var $c, $d, self = $$52.$$s == null ? this : $$52.$$s, sw = nil, cb = nil, eq = nil, has_arg = nil, $ret_or_3 = nil;
        if ($gvars["!"] == null) $gvars["!"] = nil;

        
        while ($truthy((arg = argv.$shift()))) {
        if ($eqeqeq(/^--([^=]*)(?:=(.*))?/m, ($ret_or_2 = arg))) {
            
            $c = [$$('Regexp').$last_match(1), $$('Regexp').$last_match(2)], (opt = $c[0]), (rest = $c[1]), $c;
            opt = opt.$tr("_", "-");
            
            try {
              
              $d = self.$complete("long", opt, true), $c = $to_ary($d), (sw = ($c[0] == null ? nil : $c[0])), $d;
              if (($truthy(self.$require_exact()) && ($not(sw.$long()['$include?'](arg))))) {
                self.$raise($$('InvalidOption'), arg)
              };
            } catch ($err) {
              if (Opal.rescue($err, [$$('ParseError')])) {
                try {
                  self.$raise($gvars["!"].$set_option(arg, true))
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            };;
            
            try {
              
              $d = $send(sw, 'parse', [rest, argv], function $$53($e){var $post_args, exc, self = $$53.$$s == null ? this : $$53.$$s;

                
                $post_args = $slice(arguments);
                exc = $post_args;
                return $send(self, 'raise', $to_a(exc));}, {$$arity: -1, $$s: self}), $c = $to_ary($d), (opt = ($c[0] == null ? nil : $c[0])), (cb = ($c[1] == null ? nil : $c[1])), (val = ($c[2] == null ? nil : $c[2])), $d;
              if ($truthy(cb)) {
                val = cb.$call(val)
              };
              if ($truthy(setter)) {
                setter.$call(sw.$switch_name(), val)
              };
            } catch ($err) {
              if (Opal.rescue($err, [$$('ParseError')])) {
                try {
                  self.$raise($gvars["!"].$set_option(arg, rest))
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            };;
          } else if ($eqeqeq(/^-(.)((=).*|.+)?/m, $ret_or_2)) {
            
            $c = [$$('Regexp').$last_match(3), $$('Regexp').$last_match(2), $$('Regexp').$last_match(1)], (eq = $c[0]), (rest = $c[1]), (opt = $c[2]), $c;
            $c = [eq, rest], (has_arg = $c[0]), (val = $c[1]), $c;
            
            try {
              
              $d = self.$search("short", opt), $c = $to_ary($d), (sw = ($c[0] == null ? nil : $c[0])), $d;
              if (!$truthy(sw)) {
                
                try {
                  
                  $d = self.$complete("short", opt), $c = $to_ary($d), (sw = ($c[0] == null ? nil : $c[0])), $d;
                  val = arg.$delete_prefix("-");
                  has_arg = true;
                } catch ($err) {
                  if (Opal.rescue($err, [$$('InvalidOption')])) {
                    try {
                      
                      if ($truthy(self.$require_exact())) {
                        self.$raise()
                      };
                      $d = self.$complete("long", opt), $c = $to_ary($d), (sw = ($c[0] == null ? nil : $c[0])), $d;
                      eq = ($truthy(($ret_or_3 = eq)) ? ($ret_or_3) : (rest['$!']()));
                    } finally { Opal.pop_exception($err); }
                  } else { throw $err; }
                };
              };
            } catch ($err) {
              if (Opal.rescue($err, [$$('ParseError')])) {
                try {
                  self.$raise($gvars["!"].$set_option(arg, true))
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            };;
            
            
            var $no_errors = true;try {
              $d = $send(sw, 'parse', [val, argv], function $$54($e){var $post_args, exc, self = $$54.$$s == null ? this : $$54.$$s;

                
                $post_args = $slice(arguments);
                exc = $post_args;
                if ($truthy(eq)) {
                  return $send(self, 'raise', $to_a(exc))
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self}), $c = $to_ary($d), (opt = ($c[0] == null ? nil : $c[0])), (cb = ($c[1] == null ? nil : $c[1])), (val = ($c[2] == null ? nil : $c[2])), $d
            } catch ($err) {
              $no_errors = false;
              if (Opal.rescue($err, [$$('ParseError')])) {
                try {
                  self.$raise($gvars["!"].$set_option(arg, $rb_gt(arg.$length(), 2)))
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            }finally {
              if ($no_errors) { 
                if ((($truthy(has_arg) && ($not(eq))) && ($eqeq(arg, "-" + (opt))))) {
                  self.$raise($$('InvalidOption'), arg)
                }
              }};;
            
            try {
              
              if (($truthy(opt) && (($not(rest) || ($neqeq((opt = opt.$sub(/^-*/, "-")), "-")))))) {
                argv.$unshift(opt)
              };
              if ($truthy(cb)) {
                val = cb.$call(val)
              };
              if ($truthy(setter)) {
                setter.$call(sw.$switch_name(), val)
              };
            } catch ($err) {
              if (Opal.rescue($err, [$$('ParseError')])) {
                try {
                  self.$raise($gvars["!"].$set_option(arg, $rb_gt(arg.$length(), 2)))
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            };;
          } else {
            $send(self, 'catch', ["prune"], function $$55(){var self = $$55.$$s == null ? this : $$55.$$s;

              
              $send(self, 'visit', ["each_option"], function $$56(sw0){
                
                if (sw0 == null) sw0 = nil;
                sw = sw0;
                if (($eqeqeq($$('Switch'), sw) && ($truthy(sw['$match_nonswitch?'](arg))))) {
                  return sw.$block().$call(arg)
                } else {
                  return nil
                };});
              return nonopt.$call(arg);}, {$$s: self})
          }
        };
        return nil;}, {$$s: self})))) {
        argv.$unshift(arg)
      };
      $send(self, 'visit', ["search", "short", nil], function $$57(sw){
        
        if (sw == null) sw = nil;
        if ($truthy(sw.$pattern())) {
          return nil
        } else {
          return $send(sw.$block(), 'call', $to_a(argv))
        };});
      return argv;
    }, -1);
    self.$private("parse_in_order");
    
    $def(self, '$permute', function $$permute($a, $b) {
      var $post_args, $kwargs, argv, into, self = this;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      argv = $post_args;
      
      into = $hash_get($kwargs, "into");if (into == null) into = nil;
      if (($eqeq(argv.$size(), 1) && ($eqeqeq($$('Array'), argv['$[]'](0))))) {
        argv = argv['$[]'](0).$dup()
      };
      return self['$permute!'](argv, (new Map([["into", into]])));
    }, -1);
    
    $def(self, '$permute!', function $OptionParser_permute$excl$58($a, $b) {
      var $post_args, $kwargs, argv, into, self = this, nonopts = nil;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) argv = $post_args.shift();if (argv == null) argv = self.$default_argv();
      
      into = $hash_get($kwargs, "into");if (into == null) into = nil;
      nonopts = [];
      $send(self, 'order!', [argv, (new Map([["into", into]]))], nonopts.$method("<<").$to_proc());
      argv['$[]='](0, 0, nonopts);
      return argv;
    }, -1);
    
    $def(self, '$parse', function $$parse($a, $b) {
      var $post_args, $kwargs, argv, into, self = this;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      argv = $post_args;
      
      into = $hash_get($kwargs, "into");if (into == null) into = nil;
      if (($eqeq(argv.$size(), 1) && ($eqeqeq($$('Array'), argv['$[]'](0))))) {
        argv = argv['$[]'](0).$dup()
      };
      return self['$parse!'](argv, (new Map([["into", into]])));
    }, -1);
    
    $def(self, '$parse!', function $OptionParser_parse$excl$59($a, $b) {
      var $post_args, $kwargs, argv, into, self = this;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) argv = $post_args.shift();if (argv == null) argv = self.$default_argv();
      
      into = $hash_get($kwargs, "into");if (into == null) into = nil;
      if ($truthy($$('ENV')['$include?']("POSIXLY_CORRECT"))) {
        return self['$order!'](argv, (new Map([["into", into]])))
      } else {
        return self['$permute!'](argv, (new Map([["into", into]])))
      };
    }, -1);
    
    $def(self, '$getopts', function $$getopts($a) {
      var $post_args, args, $b, self = this, argv = nil, single_options = nil, long_options = nil, result = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      argv = ($eqeqeq($$('Array'), args.$first()) ? (args.$shift()) : (self.$default_argv()));
      $b = [].concat($to_a(args)), (single_options = ($b[0] == null ? nil : $b[0])), (long_options = $slice($b, 1)), $b;
      result = (new Map());
      if ($truthy(single_options)) {
        $send(single_options, 'scan', [/(.)(:)?/], function $$60(opt, val){var self = $$60.$$s == null ? this : $$60.$$s;

          
          if (opt == null) opt = nil;
          if (val == null) val = nil;
          if ($truthy(val)) {
            
            result['$[]='](opt, nil);
            return self.$define("-" + (opt) + " VAL");
          } else {
            
            result['$[]='](opt, false);
            return self.$define("-" + (opt));
          };}, {$$s: self})
      };
      $send(long_options, 'each', [], function $$61(arg){var $c, $d, self = $$61.$$s == null ? this : $$61.$$s, desc = nil, opt = nil, val = nil, $ret_or_2 = nil;

        
        if (arg == null) arg = nil;
        $d = arg.$split(";", 2), $c = $to_ary($d), (arg = ($c[0] == null ? nil : $c[0])), (desc = ($c[1] == null ? nil : $c[1])), $d;
        $d = arg.$split(":", 2), $c = $to_ary($d), (opt = ($c[0] == null ? nil : $c[0])), (val = ($c[1] == null ? nil : $c[1])), $d;
        if ($truthy(val)) {
          
          result['$[]='](opt, ($truthy(val['$empty?']()) ? (nil) : (val)));
          return $send(self, 'define', ["--" + (opt) + "=" + (($truthy(($ret_or_2 = result['$[]'](opt))) ? ($ret_or_2) : ("VAL")))].concat($to_a([desc].$compact())));
        } else {
          
          result['$[]='](opt, false);
          return $send(self, 'define', ["--" + (opt)].concat($to_a([desc].$compact())));
        };}, {$$s: self});
      self.$parse_in_order(argv, result.$method("[]="));
      return result;
    }, -1);
    $defs(self, '$getopts', function $$getopts($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self.$new(), 'getopts', $to_a(args));
    }, -1);
    
    $def(self, '$visit', function $$visit(id, $a) {
      var block = $$visit.$$p || nil, $post_args, args, self = this;

      $$visit.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      $send(self.stack, 'reverse_each', [], function $$62(el){
        
        if (el == null) el = nil;
        return $send(el, '__send__', [id].concat($to_a(args)), block.$to_proc());});
      return nil;
    }, -2);
    self.$private("visit");
    
    $def(self, '$search', function $$search(id, key) {
      var $yield = $$search.$$p || nil, self = this, block_given = nil, retval = nil;

      $$search.$$p = null;
      
      block_given = ($yield !== nil);
      retval = nil;
      (function(){try { var $t_break = $thrower('break'); return $send(self, 'visit', ["search", id, key], function $$63(k){
        
        if (k == null) k = nil;
        retval = ($truthy(block_given) ? (Opal.yield1($yield, k)) : (k));
        $t_break.$throw(nil, $$63.$$is_lambda);})} catch($e) {
        if ($e === $t_break) return $e.$v;
        throw $e;
      } finally {$t_break.is_orphan = true;}})();
      return retval;
    });
    self.$private("search");
    
    $def(self, '$complete', function $$complete(typ, opt, $a, $b) {try { var $t_return = $thrower('return'); 
      var $post_args, icase, pat, self = this, retval = nil, ambiguous = nil, exc = nil;

      
      $post_args = $slice(arguments, 2);
      
      if ($post_args.length > 0) icase = $post_args.shift();if (icase == null) icase = false;
      pat = $post_args;
      if ($truthy(pat['$empty?']())) {
        
        retval = nil;
        (function(){try { var $t_break = $thrower('break'); return $send(self, 'search', [typ, opt], function $$64(sw){
          
          if (sw == null) sw = nil;
          retval = [sw, opt];
          $t_break.$throw(nil, $$64.$$is_lambda);})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();
        if ($truthy(retval)) {
          return retval
        };
      };
      ambiguous = $send(self, 'catch', ["ambiguous"], function $$65(){var self = $$65.$$s == null ? this : $$65.$$s;

        
        retval = nil;
        (function(){try { var $t_break = $thrower('break'); return $send(self, 'visit', ["complete", typ, opt, icase].concat($to_a(pat)), function $$66(o, $c){var $post_args, sw;

          
          if (o == null) o = nil;
          $post_args = $slice(arguments, 1);
          sw = $post_args;
          retval = sw;
          $t_break.$throw(nil, $$66.$$is_lambda);}, -2)} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();
        if ($truthy(retval)) {
          $t_return.$throw(retval, $$65.$$is_lambda)
        } else {
          return nil
        };}, {$$s: self, $$ret: $t_return});
      exc = ($truthy(ambiguous) ? ($$('AmbiguousOption')) : ($$('InvalidOption')));
      return self.$raise(exc.$new(opt, (new Map([["additional", self.$method("additional_message").$curry()['$[]'](typ)]]))));} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -3);
    self.$private("complete");
    
    $def(self, '$additional_message', function $$additional_message(typ, opt) {
      var $a, $b, self = this, all_candidates = nil, checker = nil;

      
      if (!(($truthy(typ) && ($truthy(opt))) && ($truthy((($b = $$('DidYouMean', 'skip_raise')) && ($a = $$$($b, 'SpellChecker', 'skip_raise')) ? 'constant' : nil))))) {
        return nil
      };
      all_candidates = [];
      $send(self, 'visit', ["get_candidates", typ], function $$67(candidates){
        
        if (candidates == null) candidates = nil;
        return all_candidates.$concat(candidates);});
      $send(all_candidates, 'select!', [], function $$68(cand){
        
        if (cand == null) cand = nil;
        return cand['$is_a?']($$('String'));});
      checker = $$$($$('DidYouMean'), 'SpellChecker').$new((new Map([["dictionary", all_candidates]])));
      return $$('DidYouMean').$formatter().$message_for(all_candidates['$&'](checker.$correct(opt)));
    });
    
    $def(self, '$candidate', function $$candidate(word) {
      var $a, $b, self = this, list = nil, $ret_or_2 = nil, long$ = nil, short$ = nil, arg = nil, argpat = nil, pat = nil;

      
      list = [];
      if ($eqeqeq("-", ($ret_or_2 = word))) {
        long$ = (short$ = true)
      } else if ($eqeqeq(/^--/, $ret_or_2)) {
        
        $b = word.$split(/=/, 2), $a = $to_ary($b), (word = ($a[0] == null ? nil : $a[0])), (arg = ($a[1] == null ? nil : $a[1])), $b;
        if (($truthy(arg) && ($not(arg['$empty?']())))) {
          argpat = $$('Completion').$regexp(arg, false)
        };
        long$ = true;
      } else if ($eqeqeq(/^-/, $ret_or_2)) {
        short$ = true
      } else {
        nil
      };
      pat = $$('Completion').$regexp(word, long$);
      $send(self, 'visit', ["each_option"], function $$69(opt){var opts = nil;

        
        if (opt == null) opt = nil;
        if (!$eqeqeq($$('Switch'), opt)) {
          return nil
        };
        opts = $rb_plus(($truthy(long$) ? (opt.$long()) : ([])), ($truthy(short$) ? (opt.$short()) : ([])));
        if ($truthy(pat)) {
          opts = $send($send($$('Completion'), 'candidate', [word, true, pat], opts.$method("each").$to_proc()), 'map', [], "first".$to_proc())
        };
        if ($truthy(/^=/['$=~'](opt.$arg()))) {
          
          $send(opts, 'map!', [], function $$70(sw){
            
            if (sw == null) sw = nil;
            return $rb_plus(sw, "=");});
          if (($truthy(arg) && ($eqeqeq($$('CompletingHash'), opt.$pattern())))) {
            if ($truthy((opts = opt.$pattern().$candidate(arg, false, argpat)))) {
              $send(opts, 'map!', [], "last".$to_proc())
            }
          };
        };
        return list.$concat(opts);});
      return list;
    });
    
    $def(self, '$load', function $$load(filename) {
      var $a, self = this, basename = nil;
      if ($gvars["0"] == null) $gvars["0"] = nil;

      
      if (filename == null) filename = nil;
      if (!$truthy(filename)) {
        
        basename = $$('File').$basename($gvars["0"], ".*");
        
        try {
          if ($truthy(self.$load($$('File').$expand_path(basename, "~/.options")))) {
            return true
          }
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              nil
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };;
        basename['$<<'](".options");
        return $send([$$('ENV')['$[]']("XDG_CONFIG_HOME"), "~/.config"].concat($to_a(($a = $$('ENV')['$[]']("XDG_CONFIG_DIRS"), ($a === nil || $a == null) ? nil : $a.$split($$$($$('File'), 'PATH_SEPARATOR'))))).concat(["~/config/settings"]), 'any?', [], function $$71(dir){var self = $$71.$$s == null ? this : $$71.$$s;

          
          if (dir == null) dir = nil;
          if (($not(dir) || ($truthy(dir['$empty?']())))) {
            return nil
          };
          
          try {
            return self.$load($$('File').$expand_path(basename, dir))
          } catch ($err) {
            if (Opal.rescue($err, [$$('StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          };;}, {$$s: self});
      };
      
      try {
        
        $send(self, 'parse', $to_a($send($$('IO').$readlines(filename), 'each', [], "chomp!".$to_proc())));
        return true;
      } catch ($err) {
        if (Opal.rescue($err, [$$$($$('Errno'), 'ENOENT'), $$$($$('Errno'), 'ENOTDIR')])) {
          try {
            return false
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };;
    }, -1);
    
    $def(self, '$environment', function $$environment(env) {
      var self = this, $ret_or_2 = nil, $ret_or_3 = nil;
      if ($gvars["0"] == null) $gvars["0"] = nil;

      
      if (env == null) env = $$('File').$basename($gvars["0"], ".*");
      if ($truthy(($ret_or_2 = (env = ($truthy(($ret_or_3 = $$('ENV')['$[]'](env))) ? ($ret_or_3) : ($$('ENV')['$[]'](env.$upcase()))))))) {
        $ret_or_2
      } else {
        return nil
      };
      self.$require("shellwords");
      return $send(self, 'parse', $to_a($$('Shellwords').$shellwords(env)));
    }, -1);
    $send(self, 'accept', [$$('Object')], function $OptionParser$72(s){var $ret_or_2 = nil;

      
      if (s == null) s = nil;
      if ($truthy(($ret_or_2 = s))) {
        return $ret_or_2
      } else {
        return s['$nil?']()
      };}, {$$has_trailing_comma_in_args: true});
    $send(self, 'accept', [$$('NilClass')], function $OptionParser$73(s){
      
      if (s == null) s = nil;
      return s;}, {$$has_trailing_comma_in_args: true});
    $send(self, 'accept', [$$('String'), /.+/m], function $OptionParser$74(s, $a){var $post_args, $fwd_rest;

      
      if (s == null) s = nil;
      $post_args = $slice(arguments, 1);
      $fwd_rest = $post_args;
      return s;}, -2);
    decimal = "\\d+(?:_\\d+)*";
    binary = "b[01]+(?:_[01]+)*";
    hex = "x[\\da-f]+(?:_[\\da-f]+)*";
    octal = "0(?:[0-7]+(?:_[0-7]+)*|" + (binary) + "|" + (hex) + ")?";
    integer = "" + (octal) + "|" + (decimal);
    $send(self, 'accept', [$$('Integer'), $regexp(["\\A[-+]?(?:", integer, ")\\z"], 'i')], function $OptionParser$75(s){var self = $OptionParser$75.$$s == null ? this : $OptionParser$75.$$s;

      
      if (s == null) s = nil;
      if ($truthy(s)) {
        
        try {
          return self.$Integer(s)
        } catch ($err) {
          if (Opal.rescue($err, [$$('ArgumentError')])) {
            try {
              return self.$raise($$$($$('OptionParser'), 'InvalidArgument'), s)
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      } else {
        return nil
      };}, {$$s: self, $$has_trailing_comma_in_args: true});
    float$ = "(?:" + (decimal) + "(?=(.)?)(?:\\.(?:" + (decimal) + ")?)?|\\." + (decimal) + ")(?:E[-+]?" + (decimal) + ")?";
    floatpat = $regexp(["\\A[-+]?", float$, "\\z"], 'i');
    $send(self, 'accept', [$$('Float'), floatpat], function $OptionParser$76(s){
      
      if (s == null) s = nil;
      if ($truthy(s)) {
        return s.$to_f()
      } else {
        return nil
      };}, {$$has_trailing_comma_in_args: true});
    real = "[-+]?(?:" + (octal) + "|" + (float$) + ")";
    $send(self, 'accept', [$$('Numeric'), $regexp(["\\A(", real, ")(?:/(", real, "))?\\z"], 'i')], function $OptionParser$77(s, d, f, n){var self = $OptionParser$77.$$s == null ? this : $OptionParser$77.$$s;

      
      if (s == null) s = nil;
      if (d == null) d = nil;
      if (f == null) f = nil;
      if (n == null) n = nil;
      if ($truthy(n)) {
        return self.$Rational(d, n)
      } else if ($truthy(f)) {
        return self.$Float(s)
      } else {
        return self.$Integer(s)
      };}, {$$s: self, $$has_trailing_comma_in_args: true});
    $const_set($nesting[0], 'DecimalInteger', $regexp(["\\A[-+]?", decimal, "\\z"], 'i'));
    $send(self, 'accept', [$$('DecimalInteger'), $$('DecimalInteger')], function $OptionParser$78(s){var self = $OptionParser$78.$$s == null ? this : $OptionParser$78.$$s;

      
      if (s == null) s = nil;
      if ($truthy(s)) {
        
        try {
          return self.$Integer(s, 10)
        } catch ($err) {
          if (Opal.rescue($err, [$$('ArgumentError')])) {
            try {
              return self.$raise($$$($$('OptionParser'), 'InvalidArgument'), s)
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      } else {
        return nil
      };}, {$$s: self, $$has_trailing_comma_in_args: true});
    $const_set($nesting[0], 'OctalInteger', $regexp(["\\A[-+]?(?:[0-7]+(?:_[0-7]+)*|0(?:", binary, "|", hex, "))\\z"], 'i'));
    $send(self, 'accept', [$$('OctalInteger'), $$('OctalInteger')], function $OptionParser$79(s){var self = $OptionParser$79.$$s == null ? this : $OptionParser$79.$$s;

      
      if (s == null) s = nil;
      if ($truthy(s)) {
        
        try {
          return self.$Integer(s, 8)
        } catch ($err) {
          if (Opal.rescue($err, [$$('ArgumentError')])) {
            try {
              return self.$raise($$$($$('OptionParser'), 'InvalidArgument'), s)
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      } else {
        return nil
      };}, {$$s: self, $$has_trailing_comma_in_args: true});
    $const_set($nesting[0], 'DecimalNumeric', floatpat);
    $send(self, 'accept', [$$('DecimalNumeric'), floatpat], function $OptionParser$80(s, f){var self = $OptionParser$80.$$s == null ? this : $OptionParser$80.$$s;

      
      if (s == null) s = nil;
      if (f == null) f = nil;
      if ($truthy(s)) {
        
        try {
          if ($truthy(f)) {
            return self.$Float(s)
          } else {
            return self.$Integer(s)
          }
        } catch ($err) {
          if (Opal.rescue($err, [$$('ArgumentError')])) {
            try {
              return self.$raise($$$($$('OptionParser'), 'InvalidArgument'), s)
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      } else {
        return nil
      };}, {$$s: self});
    yesno = $$('CompletingHash').$new();
    $send(["-", "no", "false"], 'each', [], function $OptionParser$81(el){var $a;

      
      if (el == null) el = nil;
      return ($a = [el, false], $send(yesno, '[]=', $a), $a[$a.length - 1]);});
    $send(["+", "yes", "true"], 'each', [], function $OptionParser$82(el){var $a;

      
      if (el == null) el = nil;
      return ($a = [el, true], $send(yesno, '[]=', $a), $a[$a.length - 1]);});
    yesno['$[]=']("nil", false);
    $send(self, 'accept', [$$('TrueClass'), yesno], function $OptionParser$83(arg, val){var $ret_or_2 = nil;

      
      if (arg == null) arg = nil;
      if (val == null) val = nil;
      if ($truthy(($ret_or_2 = val['$nil?']()))) {
        return $ret_or_2
      } else {
        return val
      };});
    $send(self, 'accept', [$$('FalseClass'), yesno], function $OptionParser$84(arg, val){var $ret_or_2 = nil;

      
      if (arg == null) arg = nil;
      if (val == null) val = nil;
      if ($truthy(($ret_or_2 = val['$nil?']()['$!']()))) {
        return val
      } else {
        return $ret_or_2
      };});
    $send(self, 'accept', [$$('Array')], function $OptionParser$85(s){
      
      if (s == null) s = nil;
      if ($truthy(s)) {
        s = $send(s.$split(","), 'collect', [], function $$86(ss){
          
          if (ss == null) ss = nil;
          if ($truthy(ss['$empty?']())) {
            return nil
          } else {
            return ss
          };})
      };
      return s;}, {$$has_trailing_comma_in_args: true});
    $send(self, 'accept', [$$('Regexp'), /^\/((?:\\.|[^\\])*)\/([[:alpha:]]+)?$|.*/], function $OptionParser$87(all, s, o){var f = nil, k = nil, $ret_or_2 = nil;

      
      if (all == null) all = nil;
      if (s == null) s = nil;
      if (o == null) o = nil;
      f = 0;
      if ($truthy(o)) {
        
        if ($truthy(/i/['$=~'](o))) {
          f = f['$|']($$$($$('Regexp'), 'IGNORECASE'))
        };
        if ($truthy(/m/['$=~'](o))) {
          f = f['$|']($$$($$('Regexp'), 'MULTILINE'))
        };
        if ($truthy(/x/['$=~'](o))) {
          f = f['$|']($$$($$('Regexp'), 'EXTENDED'))
        };
        k = o.$delete("imx");
        if ($truthy(k['$empty?']())) {
          k = nil
        };
      };
      return $$('Regexp').$new(($truthy(($ret_or_2 = s)) ? ($ret_or_2) : (all)), f, k);});
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ParseError');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.args = $proto.reason = $proto.arg0 = nil;
      
      $const_set($nesting[0], 'Reason', "parse error");
      
      $def(self, '$initialize', function $$initialize($a, $b) {
        var $post_args, $kwargs, args, additional, $c, $d, self = this;

        
        $post_args = $slice(arguments);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        args = $post_args;
        
        additional = $hash_get($kwargs, "additional");if (additional == null) additional = nil;
        self.additional = additional;
        $d = args, $c = $to_ary($d), (self.arg0 = ($c[0] == null ? nil : $c[0])), $d;
        self.args = args;
        return (self.reason = nil);
      }, -1);
      self.$attr_reader("args");
      self.$attr_writer("reason");
      self.$attr_accessor("additional");
      
      $def(self, '$recover', function $$recover(argv) {
        var self = this;

        
        argv['$[]='](0, 0, self.args);
        return argv;
      });
      $defs(self, '$filter_backtrace', function $$filter_backtrace(array) {
                if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

        
        if (!$truthy($gvars.DEBUG)) {
          $send(array, 'delete_if', [], $regexp(["\\A", $$('Regexp').$quote("./optparse.rb"), ":"]).$method("=~").$to_proc())
        };
        return array;
      });
      
      $def(self, '$set_backtrace', function $$set_backtrace(array) {
        var $yield = $$set_backtrace.$$p || nil, self = this;

        $$set_backtrace.$$p = null;
        return $send2(self, $find_super(self, 'set_backtrace', $$set_backtrace, false, true), 'set_backtrace', [self.$class().$filter_backtrace(array)], null)
      });
      
      $def(self, '$set_option', function $$set_option(opt, eq) {
        var self = this;

        
        if ($truthy(eq)) {
          self.args['$[]='](0, opt)
        } else {
          self.args.$unshift(opt)
        };
        return self;
      });
      
      $def(self, '$reason', function $$reason() {
        var self = this, $ret_or_2 = nil;

        if ($truthy(($ret_or_2 = self.reason))) {
          return $ret_or_2
        } else {
          return $$$(self.$class(), 'Reason')
        }
      });
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + (self.$class()) + ": " + (self.$args().$join(" ")) + ">"
      });
      
      $def(self, '$message', function $$message() {
        var self = this;

        return "" + (self.$reason()) + ": " + (self.$args().$join(" ")) + (($truthy(self.$additional()) ? (self.$additional()['$[]'](self.arg0)) : nil))
      });
      return $alias(self, "to_s", "message");
    })($nesting[0], $$('RuntimeError'), $nesting);
    (function($base, $super) {
      var self = $klass($base, $super, 'AmbiguousOption');

      
      return self.$const_set("Reason", "ambiguous option")
    })($nesting[0], $$('ParseError'));
    (function($base, $super) {
      var self = $klass($base, $super, 'NeedlessArgument');

      
      return self.$const_set("Reason", "needless argument")
    })($nesting[0], $$('ParseError'));
    (function($base, $super) {
      var self = $klass($base, $super, 'MissingArgument');

      
      return self.$const_set("Reason", "missing argument")
    })($nesting[0], $$('ParseError'));
    (function($base, $super) {
      var self = $klass($base, $super, 'InvalidOption');

      
      return self.$const_set("Reason", "invalid option")
    })($nesting[0], $$('ParseError'));
    (function($base, $super) {
      var self = $klass($base, $super, 'InvalidArgument');

      
      return self.$const_set("Reason", "invalid argument")
    })($nesting[0], $$('ParseError'));
    (function($base, $super) {
      var self = $klass($base, $super, 'AmbiguousArgument');

      
      return self.$const_set("Reason", "ambiguous argument")
    })($nesting[0], $$('InvalidArgument'));
    (function($base, $parent_nesting) {
      var self = $module($base, 'Arguable');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$options=', function $Arguable_options$eq$88(opt) {
        var self = this;

        if ($truthy((self.optparse = opt))) {
          return nil
        } else {
          return (function(self, $parent_nesting) {
            
            
            self.$undef_method("options");
            return self.$undef_method("options=");
          })(Opal.get_singleton_class(self), $nesting)
        }
      });
      
      $def(self, '$options', function $$options() {
        var $yield = $$options.$$p || nil, self = this, $ret_or_2 = nil;
        if (self.optparse == null) self.optparse = nil;
        if ($gvars["!"] == null) $gvars["!"] = nil;

        $$options.$$p = null;
        
        self.optparse = ($truthy(($ret_or_2 = self.optparse)) ? ($ret_or_2) : ($$('OptionParser').$new()));
        self.optparse['$default_argv='](self);
        if ($truthy(($ret_or_2 = ($yield !== nil)))) {
          $ret_or_2
        } else {
          
          return self.optparse;
        };
        
        try {
          return Opal.yield1($yield, self.optparse);
        } catch ($err) {
          if (Opal.rescue($err, [$$('ParseError')])) {
            try {
              
              self.optparse.$warn($gvars["!"]);
              return nil;
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };;
      });
      
      $def(self, '$order!', function $Arguable_order$excl$89() {
        var blk = $Arguable_order$excl$89.$$p || nil, self = this;

        $Arguable_order$excl$89.$$p = null;
        
        ;
        return $send(self.$options(), 'order!', [self], blk.$to_proc());
      });
      
      $def(self, '$permute!', function $Arguable_permute$excl$90() {
        var self = this;

        return self.$options()['$permute!'](self)
      });
      
      $def(self, '$parse!', function $Arguable_parse$excl$91() {
        var self = this;

        return self.$options()['$parse!'](self)
      });
      
      $def(self, '$getopts', function $$getopts($a) {
        var $post_args, args, self = this;

        
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self.$options(), 'getopts', [self].concat($to_a(args)));
      }, -1);
      $defs(self, '$extend_object', function $$extend_object(obj) {
        var $yield = $$extend_object.$$p || nil, self = this;

        $$extend_object.$$p = null;
        
        $send2(self, $find_super(self, 'extend_object', $$extend_object, false, true), 'extend_object', [obj], $yield);
        return $send(obj, 'instance_eval', [], function $$92(){var self = $$92.$$s == null ? this : $$92.$$s;

          return (self.optparse = nil)}, {$$s: self});
      });
      return $def(self, '$initialize', function $$initialize($a) {
        var $post_args, args, $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        $post_args = $slice(arguments);
        args = $post_args;
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a(args), $yield);
        return (self.optparse = nil);
      }, -1);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Acceptables');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$const_set("DecimalInteger", $$$($$('OptionParser'), 'DecimalInteger'));
      self.$const_set("OctalInteger", $$$($$('OptionParser'), 'OctalInteger'));
      return self.$const_set("DecimalNumeric", $$$($$('OptionParser'), 'DecimalNumeric'));
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  $$('ARGV').$extend($$$($$('OptionParser'), 'Arguable'));
  return $const_set($nesting[0], 'OptParse', $$('OptionParser'));
};
