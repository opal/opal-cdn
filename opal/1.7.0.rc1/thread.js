Opal.queue(function(Opal) {/* Generated by Opal 1.7.0.rc1 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $hash2 = Opal.hash2, $Opal = Opal.Opal, $alias = Opal.alias, $return_ivar = Opal.return_ivar, $const_set = Opal.const_set, $assign_ivar_val = Opal.assign_ivar_val, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('allocate,core_initialize!,current,raise,[],coerce_key_name,[]=,key?,keys,private,coerce_to!,clear,empty?,size,shift,push,each,to_proc,pop,=~,last_match,to_i,inspect,attr_reader,path,locked?,lock,unlock');
  
  $klass($nesting[0], $$('StandardError'), 'ThreadError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Thread');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.fiber_locals = $proto.thread_locals = nil;
    
    $defs(self, '$current', function $$current() {
      var self = this;
      if (self.current == null) self.current = nil;

      
      if (!$truthy(self.current)) {
        
        self.current = self.$allocate();
        self.current['$core_initialize!']();
      };
      return self.current;
    });
    $defs(self, '$list', function $$list() {
      var self = this;

      return [self.$current()]
    });
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.$raise($$('NotImplementedError'), "Thread creation not available");
    }, -1);
    
    $def(self, '$[]', function $Thread_$$$1(key) {
      var self = this;

      return self.fiber_locals['$[]'](self.$coerce_key_name(key))
    });
    
    $def(self, '$[]=', function $Thread_$$$eq$2(key, value) {
      var $a, self = this;

      return ($a = [self.$coerce_key_name(key), value], $send(self.fiber_locals, '[]=', $a), $a[$a.length - 1])
    });
    
    $def(self, '$key?', function $Thread_key$ques$3(key) {
      var self = this;

      return self.fiber_locals['$key?'](self.$coerce_key_name(key))
    });
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      return self.fiber_locals.$keys()
    });
    
    $def(self, '$thread_variable_get', function $$thread_variable_get(key) {
      var self = this;

      return self.thread_locals['$[]'](self.$coerce_key_name(key))
    });
    
    $def(self, '$thread_variable_set', function $$thread_variable_set(key, value) {
      var $a, self = this;

      return ($a = [self.$coerce_key_name(key), value], $send(self.thread_locals, '[]=', $a), $a[$a.length - 1])
    });
    
    $def(self, '$thread_variable?', function $Thread_thread_variable$ques$4(key) {
      var self = this;

      return self.thread_locals['$key?'](self.$coerce_key_name(key))
    });
    
    $def(self, '$thread_variables', function $$thread_variables() {
      var self = this;

      return self.thread_locals.$keys()
    });
    self.$private();
    
    $def(self, '$core_initialize!', function $Thread_core_initialize$excl$5() {
      var self = this;

      
      self.thread_locals = $hash2([], {});
      return (self.fiber_locals = $hash2([], {}));
    });
    
    $def(self, '$coerce_key_name', function $$coerce_key_name(key) {
      
      return $Opal['$coerce_to!'](key, $$('String'), "to_s")
    });
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Queue');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.storage = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        return self.$clear()
      });
      
      $def(self, '$clear', function $$clear() {
        var self = this;

        return (self.storage = [])
      });
      
      $def(self, '$empty?', function $Queue_empty$ques$6() {
        var self = this;

        return self.storage['$empty?']()
      });
      
      $def(self, '$size', function $$size() {
        var self = this;

        return self.storage.$size()
      });
      
      $def(self, '$pop', function $$pop(non_block) {
        var self = this;

        
        if (non_block == null) non_block = false;
        if ($truthy(self['$empty?']())) {
          
          if ($truthy(non_block)) {
            self.$raise($$('ThreadError'), "Queue empty")
          };
          self.$raise($$('ThreadError'), "Deadlock");
        };
        return self.storage.$shift();
      }, -1);
      
      $def(self, '$push', function $$push(value) {
        var self = this;

        return self.storage.$push(value)
      });
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        return $send(self.storage, 'each', [], block.$to_proc());
      });
      $alias(self, "<<", "push");
      $alias(self, "deq", "pop");
      $alias(self, "enq", "push");
      $alias(self, "length", "size");
      return $alias(self, "shift", "pop");
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Backtrace');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Location');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.label = $proto.str = nil;
        
        
        $def(self, '$initialize', function $$initialize(str) {
          var self = this, $ret_or_1 = nil;

          
          self.str = str;
          str['$=~'](/^(.*?):(\d+):(\d+):in `(.*?)'$/);
          self.path = $$('Regexp').$last_match(1);
          self.label = $$('Regexp').$last_match(4);
          self.lineno = $$('Regexp').$last_match(2).$to_i();
          self.label['$=~'](/(\w+)$/);
          return (self.base_label = ($truthy(($ret_or_1 = $$('Regexp').$last_match(1))) ? ($ret_or_1) : (self.label)));
        });
        
        $def(self, '$to_s', $return_ivar("str"));
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return self.str.$inspect()
        });
        self.$attr_reader("base_label", "label", "lineno", "path");
        return $alias(self, "absolute_path", "path");
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting);
  })($nesting[0], null, $nesting);
  $const_set($nesting[0], 'Queue', $$$($$('Thread'), 'Queue'));
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Mutex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.locked = nil;
    
    
    $def(self, '$initialize', $assign_ivar_val("locked", false));
    
    $def(self, '$lock', function $$lock() {
      var self = this;

      
      if ($truthy(self.locked)) {
        self.$raise($$('ThreadError'), "Deadlock")
      };
      self.locked = true;
      return self;
    });
    
    $def(self, '$locked?', $return_ivar("locked"));
    
    $def(self, '$owned?', $return_ivar("locked"));
    
    $def(self, '$try_lock', function $$try_lock() {
      var self = this;

      if ($truthy(self['$locked?']())) {
        return false
      } else {
        
        self.$lock();
        return true;
      }
    });
    
    $def(self, '$unlock', function $$unlock() {
      var self = this;

      
      if (!$truthy(self.locked)) {
        self.$raise($$('ThreadError'), "Mutex not locked")
      };
      self.locked = false;
      return self;
    });
    return $def(self, '$synchronize', function $$synchronize() {
      var $yield = $$synchronize.$$p || nil, self = this;

      $$synchronize.$$p = null;
      
      self.$lock();
      
      return (function() { try {
      return Opal.yieldX($yield, []);
      } finally {
        self.$unlock()
      }; })();;
    });
  })($nesting[0], null, $nesting);
});
